<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>geoengine.tasks API documentation</title>
<meta name="description" content="Module for encapsulating Geo Engine tasks API" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geoengine.tasks</code></h1>
</header>
<section id="section-intro">
<p>Module for encapsulating Geo Engine tasks API</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;
Module for encapsulating Geo Engine tasks API
&#39;&#39;&#39;

from __future__ import annotations

import time
from enum import Enum
from typing import List, Tuple
from uuid import UUID
import asyncio
import datetime

import geoengine_openapi_client
from geoengine.types import DEFAULT_ISO_TIME_FORMAT
from geoengine.auth import get_session
from geoengine.error import GeoEngineException, TypeException
from geoengine import backports


class TaskId:
    &#39;&#39;&#39;A wrapper for a task id&#39;&#39;&#39;

    def __init__(self, task_id: UUID) -&gt; None:
        self.__task_id = task_id

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.TaskResponse) -&gt; TaskId:
        &#39;&#39;&#39;Parse a http response to an `TaskId`&#39;&#39;&#39;

        return TaskId(UUID(response.task_id))

    def __eq__(self, other) -&gt; bool:
        &#39;&#39;&#39;Checks if two dataset ids are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.__task_id == other.__task_id  # pylint: disable=protected-access

    def __str__(self) -&gt; str:
        return str(self.__task_id)

    def __repr__(self) -&gt; str:
        return repr(self.__task_id)


class TaskStatus(Enum):
    &#39;&#39;&#39;An enum of task status types&#39;&#39;&#39;

    RUNNING = &#34;running&#34;
    COMPLETED = &#34;completed&#34;
    ABORTED = &#34;aborted&#34;
    FAILED = &#34;failed&#34;


class TaskStatusInfo:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;A wrapper for a task status type&#39;&#39;&#39;

    status: TaskStatus
    time_started: datetime.datetime

    def __init__(self, status, time_started) -&gt; None:
        self.status = status
        self.time_started = time_started

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.TaskStatus) -&gt; TaskStatusInfo:
        &#39;&#39;&#39;
        Parse a http response to a `TaskStatusInfo`

        The task can be one of:
        RunningTaskStatusInfo, CompletedTaskStatusInfo, AbortedTaskStatusInfo or FailedTaskStatusInfo
        &#39;&#39;&#39;

        inner = response.actual_instance
        if inner is None:
            raise TypeException(&#39;Unknown `TaskStatus` type&#39;)

        status = TaskStatus(inner.status)
        time_started = None
        if isinstance(inner,
                      (geoengine_openapi_client.TaskStatusRunning, geoengine_openapi_client.TaskStatusCompleted)) \
                and inner.time_started is not None:
            time_started = datetime.datetime.strptime(inner.time_started, DEFAULT_ISO_TIME_FORMAT)

        if isinstance(inner, geoengine_openapi_client.TaskStatusRunning):
            return RunningTaskStatusInfo(status, time_started, inner.pct_complete, inner.estimated_time_remaining,
                                         inner.info, inner.task_type, inner.description)
        if isinstance(inner, geoengine_openapi_client.TaskStatusCompleted):
            return CompletedTaskStatusInfo(status, time_started, inner.info, inner.time_total,
                                           inner.task_type, inner.description)
        if isinstance(inner, geoengine_openapi_client.TaskStatusAborted):
            return AbortedTaskStatusInfo(status, time_started, inner.clean_up)
        if isinstance(inner, geoengine_openapi_client.TaskStatusFailed):
            return FailedTaskStatusInfo(status, time_started, inner.error, inner.clean_up)
        raise GeoEngineException(response)


class RunningTaskStatusInfo(TaskStatusInfo):
    &#39;&#39;&#39;A wrapper for a running task status with information about completion progress&#39;&#39;&#39;

    def __init__(self, status, start_time, pct_complete, estimated_time_remaining, info, task_type, description) -&gt; None:  # pylint: disable=too-many-arguments,line-too-long
        super().__init__(status, start_time)
        self.pct_complete = pct_complete
        self.estimated_time_remaining = estimated_time_remaining
        self.info = info
        self.task_type = task_type
        self.description = description

    def __eq__(self, other):
        &#39;&#39;&#39;Check if two task statuses are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.status == other.status and self.pct_complete == other.pct_complete \
            and self.estimated_time_remaining == other.estimated_time_remaining and self.info == other.info \
            and self.task_type == other.task_type and self.description == other.description

    def __str__(self) -&gt; str:
        return f&#34;status={self.status.value}, time_started={self.time_started}, &#34; \
            f&#34;pct_complete={self.pct_complete}, &#34; \
            f&#34;estimated_time_remaining={self.estimated_time_remaining}, info={self.info}, &#34; \
            f&#34;task_type={self.task_type}, description={self.description}&#34;

    def __repr__(self) -&gt; str:
        return f&#34;TaskStatusInfo(status={self.status.value!r}, pct_complete={self.pct_complete!r}, &#34; \
               f&#34;estimated_time_remaining={self.estimated_time_remaining!r}, info={self.info!r}, &#34; \
               f&#34;task_type={self.task_type!r}, description={self.description!r})&#34;


class CompletedTaskStatusInfo(TaskStatusInfo):
    &#39;&#39;&#39;A wrapper for a completed task status with information about the completion&#39;&#39;&#39;

    def __init__(self, status, time_started, info, time_total, task_type, description) -&gt; None:  # pylint: disable=too-many-arguments
        super().__init__(status, time_started)
        self.info = info
        self.time_total = time_total
        self.task_type = task_type
        self.description = description

    def __eq__(self, other):
        &#39;&#39;&#39;Check if two task statuses are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.status == other.status and self.info == other.info and self.time_total == other.time_total \
            and self.task_type == other.task_type and self.description == other.description

    def __str__(self) -&gt; str:
        return f&#34;status={self.status.value}, time_started={self.time_started}, info={self.info}, &#34; \
            f&#34;time_total={self.time_total}, task_type={self.task_type}, description={self.description}&#34;

    def __repr__(self) -&gt; str:
        return f&#34;TaskStatusInfo(status={self.status.value!r}, time_started={self.time_started!r}, &#34; \
            f&#34;info = {self.info!r}, time_total = {self.time_total!r}, task_type={self.task_type!r}, &#34; \
            f&#34;description={self.description!r})&#34;


class AbortedTaskStatusInfo(TaskStatusInfo):
    &#39;&#39;&#39;A wrapper for an aborted task status with information about the termination&#39;&#39;&#39;

    def __init__(self, status, time_started, clean_up) -&gt; None:
        super().__init__(status, time_started)
        self.clean_up = clean_up

    def __eq__(self, other):
        &#39;&#39;&#39;Check if two task statuses are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.status == other.status and self.clean_up == other.clean_up

    def __str__(self) -&gt; str:
        return f&#34;status={self.status.value}, time_started={self.time_started}, clean_up={self.clean_up}&#34;

    def __repr__(self) -&gt; str:
        return f&#34;TaskStatusInfo(status={self.status.value!r}, time_started={self.time_started!r}, &#34; \
            f&#34;clean_up={self.clean_up!r})&#34;


class FailedTaskStatusInfo(TaskStatusInfo):
    &#39;&#39;&#39;A wrapper for a failed task status with information about the failure&#39;&#39;&#39;

    def __init__(self, status, time_started, error, clean_up) -&gt; None:
        super().__init__(status, time_started)
        self.error = error
        self.clean_up = clean_up

    def __eq__(self, other):
        &#39;&#39;&#39;Check if two task statuses are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.status == other.status and self.error == other.error and self.clean_up == other.clean_up

    def __str__(self) -&gt; str:
        return f&#34;status={self.status.value}, time_started={self.time_started}, error={self.error}, &#34; \
            f&#34;clean_up={self.clean_up}&#34;

    def __repr__(self) -&gt; str:
        return f&#34;TaskStatusInfo(status={self.status.value!r}, time_started={self.time_started!r}, &#34; \
            f&#34;error={self.error!r}, clean_up={self.clean_up!r})&#34;


class Task:
    &#39;&#39;&#39;
    Holds a task id, allows querying and manipulating the task status
    &#39;&#39;&#39;

    def __init__(self, task_id: TaskId):
        self.__task_id = task_id

    def __eq__(self, other):
        &#39;&#39;&#39;Check if two task representations are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.__task_id == other.__task_id  # pylint: disable=protected-access

    def get_status(self, timeout: int = 3600) -&gt; TaskStatusInfo:
        &#39;&#39;&#39;
        Returns the status of a task in a Geo Engine instance
        &#39;&#39;&#39;
        session = get_session()

        task_id_str = str(self.__task_id)

        with geoengine_openapi_client.ApiClient(session.configuration) as api_client:
            tasks_api = geoengine_openapi_client.TasksApi(api_client)
            response = tasks_api.status_handler(task_id_str, _request_timeout=timeout)

        return TaskStatusInfo.from_response(response)

    def abort(self, force: bool = False, timeout: int = 3600) -&gt; None:
        &#39;&#39;&#39;
        Abort a running task in a Geo Engine instance
        &#39;&#39;&#39;
        session = get_session()

        task_id_str = str(self.__task_id)

        with geoengine_openapi_client.ApiClient(session.configuration) as api_client:
            tasks_api = geoengine_openapi_client.TasksApi(api_client)
            tasks_api.abort_handler(
                task_id_str,
                None if force is False else True,
                _request_timeout=timeout
            )

    def wait_for_finish(
            self,
            check_interval_seconds: float = 5,
            request_timeout: int = 3600,
            print_status: bool = True) -&gt; TaskStatusInfo:
        &#39;&#39;&#39;
        Wait for the given task in a Geo Engine instance to finish (status either complete, aborted or failed).
        The status is printed after each check-in. Check-ins happen in intervals of check_interval_seconds seconds.
        &#39;&#39;&#39;
        current_status = self.get_status(request_timeout)

        while current_status.status == TaskStatus.RUNNING:
            current_status = self.get_status(request_timeout)

            if print_status:
                print(current_status)
            if current_status.status == TaskStatus.RUNNING:
                time.sleep(check_interval_seconds)

        return current_status

    def __str__(self) -&gt; str:
        return str(self.__task_id)

    def __repr__(self) -&gt; str:
        return repr(self.__task_id)

    async def as_future(
            self,
            request_interval: int = 5,
            print_status=False
    ) -&gt; TaskStatusInfo:
        &#39;&#39;&#39;
        Returns a future that will be resolved when the task is finished in the backend.
        &#39;&#39;&#39;

        def get_status_inner(tasks_api: geoengine_openapi_client.TasksApi, task_id_str: str, timeout: int = 3600):
            return tasks_api.status_handler(task_id_str, _request_timeout=timeout)

        session = get_session()
        task_id_str = str(self.__task_id)

        last_status = None
        with geoengine_openapi_client.ApiClient(session.configuration) as api_client:
            tasks_api = geoengine_openapi_client.TasksApi(api_client)
            while True:
                response = await backports.to_thread(get_status_inner, tasks_api, task_id_str)

                last_status = TaskStatusInfo.from_response(response)

                if print_status:
                    print(last_status)

                if last_status.status != TaskStatus.RUNNING:
                    return last_status

                await asyncio.sleep(request_interval)


def get_task_list(timeout: int = 3600) -&gt; List[Tuple[Task, TaskStatusInfo]]:
    &#39;&#39;&#39;
    Returns the status of all tasks in a Geo Engine instance
    &#39;&#39;&#39;
    session = get_session()

    with geoengine_openapi_client.ApiClient(session.configuration) as api_client:
        tasks_api = geoengine_openapi_client.TasksApi(api_client)
        response = tasks_api.list_handler(None, 0, 10, _request_timeout=timeout)

    result = []
    for item in response:
        result.append((Task(TaskId(UUID(item.task_id))), TaskStatusInfo.from_response(item)))

    return result</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="geoengine.tasks.get_task_list"><code class="name flex">
<span>def <span class="ident">get_task_list</span></span>(<span>timeout: int = 3600) ‑> List[Tuple[<a title="geoengine.tasks.Task" href="#geoengine.tasks.Task">Task</a>, <a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the status of all tasks in a Geo Engine instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_task_list(timeout: int = 3600) -&gt; List[Tuple[Task, TaskStatusInfo]]:
    &#39;&#39;&#39;
    Returns the status of all tasks in a Geo Engine instance
    &#39;&#39;&#39;
    session = get_session()

    with geoengine_openapi_client.ApiClient(session.configuration) as api_client:
        tasks_api = geoengine_openapi_client.TasksApi(api_client)
        response = tasks_api.list_handler(None, 0, 10, _request_timeout=timeout)

    result = []
    for item in response:
        result.append((Task(TaskId(UUID(item.task_id))), TaskStatusInfo.from_response(item)))

    return result</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="geoengine.tasks.AbortedTaskStatusInfo"><code class="flex name class">
<span>class <span class="ident">AbortedTaskStatusInfo</span></span>
<span>(</span><span>status, time_started, clean_up)</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper for an aborted task status with information about the termination</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AbortedTaskStatusInfo(TaskStatusInfo):
    &#39;&#39;&#39;A wrapper for an aborted task status with information about the termination&#39;&#39;&#39;

    def __init__(self, status, time_started, clean_up) -&gt; None:
        super().__init__(status, time_started)
        self.clean_up = clean_up

    def __eq__(self, other):
        &#39;&#39;&#39;Check if two task statuses are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.status == other.status and self.clean_up == other.clean_up

    def __str__(self) -&gt; str:
        return f&#34;status={self.status.value}, time_started={self.time_started}, clean_up={self.clean_up}&#34;

    def __repr__(self) -&gt; str:
        return f&#34;TaskStatusInfo(status={self.status.value!r}, time_started={self.time_started!r}, &#34; \
            f&#34;clean_up={self.clean_up!r})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.tasks.AbortedTaskStatusInfo.status"><code class="name">var <span class="ident">status</span> : <a title="geoengine.tasks.TaskStatus" href="#geoengine.tasks.TaskStatus">TaskStatus</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.tasks.AbortedTaskStatusInfo.time_started"><code class="name">var <span class="ident">time_started</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.tasks.TaskStatusInfo.from_response" href="#geoengine.tasks.TaskStatusInfo.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.tasks.CompletedTaskStatusInfo"><code class="flex name class">
<span>class <span class="ident">CompletedTaskStatusInfo</span></span>
<span>(</span><span>status, time_started, info, time_total, task_type, description)</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper for a completed task status with information about the completion</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CompletedTaskStatusInfo(TaskStatusInfo):
    &#39;&#39;&#39;A wrapper for a completed task status with information about the completion&#39;&#39;&#39;

    def __init__(self, status, time_started, info, time_total, task_type, description) -&gt; None:  # pylint: disable=too-many-arguments
        super().__init__(status, time_started)
        self.info = info
        self.time_total = time_total
        self.task_type = task_type
        self.description = description

    def __eq__(self, other):
        &#39;&#39;&#39;Check if two task statuses are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.status == other.status and self.info == other.info and self.time_total == other.time_total \
            and self.task_type == other.task_type and self.description == other.description

    def __str__(self) -&gt; str:
        return f&#34;status={self.status.value}, time_started={self.time_started}, info={self.info}, &#34; \
            f&#34;time_total={self.time_total}, task_type={self.task_type}, description={self.description}&#34;

    def __repr__(self) -&gt; str:
        return f&#34;TaskStatusInfo(status={self.status.value!r}, time_started={self.time_started!r}, &#34; \
            f&#34;info = {self.info!r}, time_total = {self.time_total!r}, task_type={self.task_type!r}, &#34; \
            f&#34;description={self.description!r})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.tasks.CompletedTaskStatusInfo.status"><code class="name">var <span class="ident">status</span> : <a title="geoengine.tasks.TaskStatus" href="#geoengine.tasks.TaskStatus">TaskStatus</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.tasks.CompletedTaskStatusInfo.time_started"><code class="name">var <span class="ident">time_started</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.tasks.TaskStatusInfo.from_response" href="#geoengine.tasks.TaskStatusInfo.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.tasks.FailedTaskStatusInfo"><code class="flex name class">
<span>class <span class="ident">FailedTaskStatusInfo</span></span>
<span>(</span><span>status, time_started, error, clean_up)</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper for a failed task status with information about the failure</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FailedTaskStatusInfo(TaskStatusInfo):
    &#39;&#39;&#39;A wrapper for a failed task status with information about the failure&#39;&#39;&#39;

    def __init__(self, status, time_started, error, clean_up) -&gt; None:
        super().__init__(status, time_started)
        self.error = error
        self.clean_up = clean_up

    def __eq__(self, other):
        &#39;&#39;&#39;Check if two task statuses are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.status == other.status and self.error == other.error and self.clean_up == other.clean_up

    def __str__(self) -&gt; str:
        return f&#34;status={self.status.value}, time_started={self.time_started}, error={self.error}, &#34; \
            f&#34;clean_up={self.clean_up}&#34;

    def __repr__(self) -&gt; str:
        return f&#34;TaskStatusInfo(status={self.status.value!r}, time_started={self.time_started!r}, &#34; \
            f&#34;error={self.error!r}, clean_up={self.clean_up!r})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.tasks.FailedTaskStatusInfo.status"><code class="name">var <span class="ident">status</span> : <a title="geoengine.tasks.TaskStatus" href="#geoengine.tasks.TaskStatus">TaskStatus</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.tasks.FailedTaskStatusInfo.time_started"><code class="name">var <span class="ident">time_started</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.tasks.TaskStatusInfo.from_response" href="#geoengine.tasks.TaskStatusInfo.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.tasks.RunningTaskStatusInfo"><code class="flex name class">
<span>class <span class="ident">RunningTaskStatusInfo</span></span>
<span>(</span><span>status, start_time, pct_complete, estimated_time_remaining, info, task_type, description)</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper for a running task status with information about completion progress</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RunningTaskStatusInfo(TaskStatusInfo):
    &#39;&#39;&#39;A wrapper for a running task status with information about completion progress&#39;&#39;&#39;

    def __init__(self, status, start_time, pct_complete, estimated_time_remaining, info, task_type, description) -&gt; None:  # pylint: disable=too-many-arguments,line-too-long
        super().__init__(status, start_time)
        self.pct_complete = pct_complete
        self.estimated_time_remaining = estimated_time_remaining
        self.info = info
        self.task_type = task_type
        self.description = description

    def __eq__(self, other):
        &#39;&#39;&#39;Check if two task statuses are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.status == other.status and self.pct_complete == other.pct_complete \
            and self.estimated_time_remaining == other.estimated_time_remaining and self.info == other.info \
            and self.task_type == other.task_type and self.description == other.description

    def __str__(self) -&gt; str:
        return f&#34;status={self.status.value}, time_started={self.time_started}, &#34; \
            f&#34;pct_complete={self.pct_complete}, &#34; \
            f&#34;estimated_time_remaining={self.estimated_time_remaining}, info={self.info}, &#34; \
            f&#34;task_type={self.task_type}, description={self.description}&#34;

    def __repr__(self) -&gt; str:
        return f&#34;TaskStatusInfo(status={self.status.value!r}, pct_complete={self.pct_complete!r}, &#34; \
               f&#34;estimated_time_remaining={self.estimated_time_remaining!r}, info={self.info!r}, &#34; \
               f&#34;task_type={self.task_type!r}, description={self.description!r})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.tasks.RunningTaskStatusInfo.status"><code class="name">var <span class="ident">status</span> : <a title="geoengine.tasks.TaskStatus" href="#geoengine.tasks.TaskStatus">TaskStatus</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.tasks.RunningTaskStatusInfo.time_started"><code class="name">var <span class="ident">time_started</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.tasks.TaskStatusInfo.from_response" href="#geoengine.tasks.TaskStatusInfo.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.tasks.Task"><code class="flex name class">
<span>class <span class="ident">Task</span></span>
<span>(</span><span>task_id: <a title="geoengine.tasks.TaskId" href="#geoengine.tasks.TaskId">TaskId</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds a task id, allows querying and manipulating the task status</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Task:
    &#39;&#39;&#39;
    Holds a task id, allows querying and manipulating the task status
    &#39;&#39;&#39;

    def __init__(self, task_id: TaskId):
        self.__task_id = task_id

    def __eq__(self, other):
        &#39;&#39;&#39;Check if two task representations are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.__task_id == other.__task_id  # pylint: disable=protected-access

    def get_status(self, timeout: int = 3600) -&gt; TaskStatusInfo:
        &#39;&#39;&#39;
        Returns the status of a task in a Geo Engine instance
        &#39;&#39;&#39;
        session = get_session()

        task_id_str = str(self.__task_id)

        with geoengine_openapi_client.ApiClient(session.configuration) as api_client:
            tasks_api = geoengine_openapi_client.TasksApi(api_client)
            response = tasks_api.status_handler(task_id_str, _request_timeout=timeout)

        return TaskStatusInfo.from_response(response)

    def abort(self, force: bool = False, timeout: int = 3600) -&gt; None:
        &#39;&#39;&#39;
        Abort a running task in a Geo Engine instance
        &#39;&#39;&#39;
        session = get_session()

        task_id_str = str(self.__task_id)

        with geoengine_openapi_client.ApiClient(session.configuration) as api_client:
            tasks_api = geoengine_openapi_client.TasksApi(api_client)
            tasks_api.abort_handler(
                task_id_str,
                None if force is False else True,
                _request_timeout=timeout
            )

    def wait_for_finish(
            self,
            check_interval_seconds: float = 5,
            request_timeout: int = 3600,
            print_status: bool = True) -&gt; TaskStatusInfo:
        &#39;&#39;&#39;
        Wait for the given task in a Geo Engine instance to finish (status either complete, aborted or failed).
        The status is printed after each check-in. Check-ins happen in intervals of check_interval_seconds seconds.
        &#39;&#39;&#39;
        current_status = self.get_status(request_timeout)

        while current_status.status == TaskStatus.RUNNING:
            current_status = self.get_status(request_timeout)

            if print_status:
                print(current_status)
            if current_status.status == TaskStatus.RUNNING:
                time.sleep(check_interval_seconds)

        return current_status

    def __str__(self) -&gt; str:
        return str(self.__task_id)

    def __repr__(self) -&gt; str:
        return repr(self.__task_id)

    async def as_future(
            self,
            request_interval: int = 5,
            print_status=False
    ) -&gt; TaskStatusInfo:
        &#39;&#39;&#39;
        Returns a future that will be resolved when the task is finished in the backend.
        &#39;&#39;&#39;

        def get_status_inner(tasks_api: geoengine_openapi_client.TasksApi, task_id_str: str, timeout: int = 3600):
            return tasks_api.status_handler(task_id_str, _request_timeout=timeout)

        session = get_session()
        task_id_str = str(self.__task_id)

        last_status = None
        with geoengine_openapi_client.ApiClient(session.configuration) as api_client:
            tasks_api = geoengine_openapi_client.TasksApi(api_client)
            while True:
                response = await backports.to_thread(get_status_inner, tasks_api, task_id_str)

                last_status = TaskStatusInfo.from_response(response)

                if print_status:
                    print(last_status)

                if last_status.status != TaskStatus.RUNNING:
                    return last_status

                await asyncio.sleep(request_interval)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="geoengine.tasks.Task.abort"><code class="name flex">
<span>def <span class="ident">abort</span></span>(<span>self, force: bool = False, timeout: int = 3600) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Abort a running task in a Geo Engine instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abort(self, force: bool = False, timeout: int = 3600) -&gt; None:
    &#39;&#39;&#39;
    Abort a running task in a Geo Engine instance
    &#39;&#39;&#39;
    session = get_session()

    task_id_str = str(self.__task_id)

    with geoengine_openapi_client.ApiClient(session.configuration) as api_client:
        tasks_api = geoengine_openapi_client.TasksApi(api_client)
        tasks_api.abort_handler(
            task_id_str,
            None if force is False else True,
            _request_timeout=timeout
        )</code></pre>
</details>
</dd>
<dt id="geoengine.tasks.Task.as_future"><code class="name flex">
<span>async def <span class="ident">as_future</span></span>(<span>self, request_interval: int = 5, print_status=False) ‑> <a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns a future that will be resolved when the task is finished in the backend.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def as_future(
        self,
        request_interval: int = 5,
        print_status=False
) -&gt; TaskStatusInfo:
    &#39;&#39;&#39;
    Returns a future that will be resolved when the task is finished in the backend.
    &#39;&#39;&#39;

    def get_status_inner(tasks_api: geoengine_openapi_client.TasksApi, task_id_str: str, timeout: int = 3600):
        return tasks_api.status_handler(task_id_str, _request_timeout=timeout)

    session = get_session()
    task_id_str = str(self.__task_id)

    last_status = None
    with geoengine_openapi_client.ApiClient(session.configuration) as api_client:
        tasks_api = geoengine_openapi_client.TasksApi(api_client)
        while True:
            response = await backports.to_thread(get_status_inner, tasks_api, task_id_str)

            last_status = TaskStatusInfo.from_response(response)

            if print_status:
                print(last_status)

            if last_status.status != TaskStatus.RUNNING:
                return last_status

            await asyncio.sleep(request_interval)</code></pre>
</details>
</dd>
<dt id="geoengine.tasks.Task.get_status"><code class="name flex">
<span>def <span class="ident">get_status</span></span>(<span>self, timeout: int = 3600) ‑> <a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></span>
</code></dt>
<dd>
<div class="desc"><p>Returns the status of a task in a Geo Engine instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_status(self, timeout: int = 3600) -&gt; TaskStatusInfo:
    &#39;&#39;&#39;
    Returns the status of a task in a Geo Engine instance
    &#39;&#39;&#39;
    session = get_session()

    task_id_str = str(self.__task_id)

    with geoengine_openapi_client.ApiClient(session.configuration) as api_client:
        tasks_api = geoengine_openapi_client.TasksApi(api_client)
        response = tasks_api.status_handler(task_id_str, _request_timeout=timeout)

    return TaskStatusInfo.from_response(response)</code></pre>
</details>
</dd>
<dt id="geoengine.tasks.Task.wait_for_finish"><code class="name flex">
<span>def <span class="ident">wait_for_finish</span></span>(<span>self, check_interval_seconds: float = 5, request_timeout: int = 3600, print_status: bool = True) ‑> <a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></span>
</code></dt>
<dd>
<div class="desc"><p>Wait for the given task in a Geo Engine instance to finish (status either complete, aborted or failed).
The status is printed after each check-in. Check-ins happen in intervals of check_interval_seconds seconds.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for_finish(
        self,
        check_interval_seconds: float = 5,
        request_timeout: int = 3600,
        print_status: bool = True) -&gt; TaskStatusInfo:
    &#39;&#39;&#39;
    Wait for the given task in a Geo Engine instance to finish (status either complete, aborted or failed).
    The status is printed after each check-in. Check-ins happen in intervals of check_interval_seconds seconds.
    &#39;&#39;&#39;
    current_status = self.get_status(request_timeout)

    while current_status.status == TaskStatus.RUNNING:
        current_status = self.get_status(request_timeout)

        if print_status:
            print(current_status)
        if current_status.status == TaskStatus.RUNNING:
            time.sleep(check_interval_seconds)

    return current_status</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.tasks.TaskId"><code class="flex name class">
<span>class <span class="ident">TaskId</span></span>
<span>(</span><span>task_id: UUID)</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper for a task id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TaskId:
    &#39;&#39;&#39;A wrapper for a task id&#39;&#39;&#39;

    def __init__(self, task_id: UUID) -&gt; None:
        self.__task_id = task_id

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.TaskResponse) -&gt; TaskId:
        &#39;&#39;&#39;Parse a http response to an `TaskId`&#39;&#39;&#39;

        return TaskId(UUID(response.task_id))

    def __eq__(self, other) -&gt; bool:
        &#39;&#39;&#39;Checks if two dataset ids are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.__task_id == other.__task_id  # pylint: disable=protected-access

    def __str__(self) -&gt; str:
        return str(self.__task_id)

    def __repr__(self) -&gt; str:
        return repr(self.__task_id)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.tasks.TaskId.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response: geoengine_openapi_client.TaskResponse) ‑> <a title="geoengine.tasks.TaskId" href="#geoengine.tasks.TaskId">TaskId</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a http response to an <code><a title="geoengine.tasks.TaskId" href="#geoengine.tasks.TaskId">TaskId</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response(cls, response: geoengine_openapi_client.TaskResponse) -&gt; TaskId:
    &#39;&#39;&#39;Parse a http response to an `TaskId`&#39;&#39;&#39;

    return TaskId(UUID(response.task_id))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.tasks.TaskStatus"><code class="flex name class">
<span>class <span class="ident">TaskStatus</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enum of task status types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TaskStatus(Enum):
    &#39;&#39;&#39;An enum of task status types&#39;&#39;&#39;

    RUNNING = &#34;running&#34;
    COMPLETED = &#34;completed&#34;
    ABORTED = &#34;aborted&#34;
    FAILED = &#34;failed&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.tasks.TaskStatus.ABORTED"><code class="name">var <span class="ident">ABORTED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.tasks.TaskStatus.COMPLETED"><code class="name">var <span class="ident">COMPLETED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.tasks.TaskStatus.FAILED"><code class="name">var <span class="ident">FAILED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.tasks.TaskStatus.RUNNING"><code class="name">var <span class="ident">RUNNING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="geoengine.tasks.TaskStatusInfo"><code class="flex name class">
<span>class <span class="ident">TaskStatusInfo</span></span>
<span>(</span><span>status, time_started)</span>
</code></dt>
<dd>
<div class="desc"><p>A wrapper for a task status type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TaskStatusInfo:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;A wrapper for a task status type&#39;&#39;&#39;

    status: TaskStatus
    time_started: datetime.datetime

    def __init__(self, status, time_started) -&gt; None:
        self.status = status
        self.time_started = time_started

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.TaskStatus) -&gt; TaskStatusInfo:
        &#39;&#39;&#39;
        Parse a http response to a `TaskStatusInfo`

        The task can be one of:
        RunningTaskStatusInfo, CompletedTaskStatusInfo, AbortedTaskStatusInfo or FailedTaskStatusInfo
        &#39;&#39;&#39;

        inner = response.actual_instance
        if inner is None:
            raise TypeException(&#39;Unknown `TaskStatus` type&#39;)

        status = TaskStatus(inner.status)
        time_started = None
        if isinstance(inner,
                      (geoengine_openapi_client.TaskStatusRunning, geoengine_openapi_client.TaskStatusCompleted)) \
                and inner.time_started is not None:
            time_started = datetime.datetime.strptime(inner.time_started, DEFAULT_ISO_TIME_FORMAT)

        if isinstance(inner, geoengine_openapi_client.TaskStatusRunning):
            return RunningTaskStatusInfo(status, time_started, inner.pct_complete, inner.estimated_time_remaining,
                                         inner.info, inner.task_type, inner.description)
        if isinstance(inner, geoengine_openapi_client.TaskStatusCompleted):
            return CompletedTaskStatusInfo(status, time_started, inner.info, inner.time_total,
                                           inner.task_type, inner.description)
        if isinstance(inner, geoengine_openapi_client.TaskStatusAborted):
            return AbortedTaskStatusInfo(status, time_started, inner.clean_up)
        if isinstance(inner, geoengine_openapi_client.TaskStatusFailed):
            return FailedTaskStatusInfo(status, time_started, inner.error, inner.clean_up)
        raise GeoEngineException(response)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geoengine.tasks.AbortedTaskStatusInfo" href="#geoengine.tasks.AbortedTaskStatusInfo">AbortedTaskStatusInfo</a></li>
<li><a title="geoengine.tasks.CompletedTaskStatusInfo" href="#geoengine.tasks.CompletedTaskStatusInfo">CompletedTaskStatusInfo</a></li>
<li><a title="geoengine.tasks.FailedTaskStatusInfo" href="#geoengine.tasks.FailedTaskStatusInfo">FailedTaskStatusInfo</a></li>
<li><a title="geoengine.tasks.RunningTaskStatusInfo" href="#geoengine.tasks.RunningTaskStatusInfo">RunningTaskStatusInfo</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.tasks.TaskStatusInfo.status"><code class="name">var <span class="ident">status</span> : <a title="geoengine.tasks.TaskStatus" href="#geoengine.tasks.TaskStatus">TaskStatus</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.tasks.TaskStatusInfo.time_started"><code class="name">var <span class="ident">time_started</span> : datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.tasks.TaskStatusInfo.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response: geoengine_openapi_client.TaskStatus) ‑> <a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a http response to a <code><a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></code></p>
<p>The task can be one of:
RunningTaskStatusInfo, CompletedTaskStatusInfo, AbortedTaskStatusInfo or FailedTaskStatusInfo</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response(cls, response: geoengine_openapi_client.TaskStatus) -&gt; TaskStatusInfo:
    &#39;&#39;&#39;
    Parse a http response to a `TaskStatusInfo`

    The task can be one of:
    RunningTaskStatusInfo, CompletedTaskStatusInfo, AbortedTaskStatusInfo or FailedTaskStatusInfo
    &#39;&#39;&#39;

    inner = response.actual_instance
    if inner is None:
        raise TypeException(&#39;Unknown `TaskStatus` type&#39;)

    status = TaskStatus(inner.status)
    time_started = None
    if isinstance(inner,
                  (geoengine_openapi_client.TaskStatusRunning, geoengine_openapi_client.TaskStatusCompleted)) \
            and inner.time_started is not None:
        time_started = datetime.datetime.strptime(inner.time_started, DEFAULT_ISO_TIME_FORMAT)

    if isinstance(inner, geoengine_openapi_client.TaskStatusRunning):
        return RunningTaskStatusInfo(status, time_started, inner.pct_complete, inner.estimated_time_remaining,
                                     inner.info, inner.task_type, inner.description)
    if isinstance(inner, geoengine_openapi_client.TaskStatusCompleted):
        return CompletedTaskStatusInfo(status, time_started, inner.info, inner.time_total,
                                       inner.task_type, inner.description)
    if isinstance(inner, geoengine_openapi_client.TaskStatusAborted):
        return AbortedTaskStatusInfo(status, time_started, inner.clean_up)
    if isinstance(inner, geoengine_openapi_client.TaskStatusFailed):
        return FailedTaskStatusInfo(status, time_started, inner.error, inner.clean_up)
    raise GeoEngineException(response)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geoengine" href="index.html">geoengine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="geoengine.tasks.get_task_list" href="#geoengine.tasks.get_task_list">get_task_list</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="geoengine.tasks.AbortedTaskStatusInfo" href="#geoengine.tasks.AbortedTaskStatusInfo">AbortedTaskStatusInfo</a></code></h4>
<ul class="">
<li><code><a title="geoengine.tasks.AbortedTaskStatusInfo.status" href="#geoengine.tasks.AbortedTaskStatusInfo.status">status</a></code></li>
<li><code><a title="geoengine.tasks.AbortedTaskStatusInfo.time_started" href="#geoengine.tasks.AbortedTaskStatusInfo.time_started">time_started</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.tasks.CompletedTaskStatusInfo" href="#geoengine.tasks.CompletedTaskStatusInfo">CompletedTaskStatusInfo</a></code></h4>
<ul class="">
<li><code><a title="geoengine.tasks.CompletedTaskStatusInfo.status" href="#geoengine.tasks.CompletedTaskStatusInfo.status">status</a></code></li>
<li><code><a title="geoengine.tasks.CompletedTaskStatusInfo.time_started" href="#geoengine.tasks.CompletedTaskStatusInfo.time_started">time_started</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.tasks.FailedTaskStatusInfo" href="#geoengine.tasks.FailedTaskStatusInfo">FailedTaskStatusInfo</a></code></h4>
<ul class="">
<li><code><a title="geoengine.tasks.FailedTaskStatusInfo.status" href="#geoengine.tasks.FailedTaskStatusInfo.status">status</a></code></li>
<li><code><a title="geoengine.tasks.FailedTaskStatusInfo.time_started" href="#geoengine.tasks.FailedTaskStatusInfo.time_started">time_started</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.tasks.RunningTaskStatusInfo" href="#geoengine.tasks.RunningTaskStatusInfo">RunningTaskStatusInfo</a></code></h4>
<ul class="">
<li><code><a title="geoengine.tasks.RunningTaskStatusInfo.status" href="#geoengine.tasks.RunningTaskStatusInfo.status">status</a></code></li>
<li><code><a title="geoengine.tasks.RunningTaskStatusInfo.time_started" href="#geoengine.tasks.RunningTaskStatusInfo.time_started">time_started</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.tasks.Task" href="#geoengine.tasks.Task">Task</a></code></h4>
<ul class="">
<li><code><a title="geoengine.tasks.Task.abort" href="#geoengine.tasks.Task.abort">abort</a></code></li>
<li><code><a title="geoengine.tasks.Task.as_future" href="#geoengine.tasks.Task.as_future">as_future</a></code></li>
<li><code><a title="geoengine.tasks.Task.get_status" href="#geoengine.tasks.Task.get_status">get_status</a></code></li>
<li><code><a title="geoengine.tasks.Task.wait_for_finish" href="#geoengine.tasks.Task.wait_for_finish">wait_for_finish</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.tasks.TaskId" href="#geoengine.tasks.TaskId">TaskId</a></code></h4>
<ul class="">
<li><code><a title="geoengine.tasks.TaskId.from_response" href="#geoengine.tasks.TaskId.from_response">from_response</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.tasks.TaskStatus" href="#geoengine.tasks.TaskStatus">TaskStatus</a></code></h4>
<ul class="">
<li><code><a title="geoengine.tasks.TaskStatus.ABORTED" href="#geoengine.tasks.TaskStatus.ABORTED">ABORTED</a></code></li>
<li><code><a title="geoengine.tasks.TaskStatus.COMPLETED" href="#geoengine.tasks.TaskStatus.COMPLETED">COMPLETED</a></code></li>
<li><code><a title="geoengine.tasks.TaskStatus.FAILED" href="#geoengine.tasks.TaskStatus.FAILED">FAILED</a></code></li>
<li><code><a title="geoengine.tasks.TaskStatus.RUNNING" href="#geoengine.tasks.TaskStatus.RUNNING">RUNNING</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.tasks.TaskStatusInfo" href="#geoengine.tasks.TaskStatusInfo">TaskStatusInfo</a></code></h4>
<ul class="">
<li><code><a title="geoengine.tasks.TaskStatusInfo.from_response" href="#geoengine.tasks.TaskStatusInfo.from_response">from_response</a></code></li>
<li><code><a title="geoengine.tasks.TaskStatusInfo.status" href="#geoengine.tasks.TaskStatusInfo.status">status</a></code></li>
<li><code><a title="geoengine.tasks.TaskStatusInfo.time_started" href="#geoengine.tasks.TaskStatusInfo.time_started">time_started</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>