<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>geoengine.raster API documentation</title>
<meta name="description" content="Raster data types" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geoengine.raster</code></h1>
</header>
<section id="section-intro">
<p>Raster data types</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39;Raster data types&#39;&#39;&#39;
from __future__ import annotations
from typing import AsyncIterator, List, Literal, Optional, Tuple, Union, cast
import numpy as np
import pyarrow as pa
import xarray as xr
import geoengine_openapi_client
import geoengine.types as gety
from geoengine.util import clamp_datetime_ms_ns


# pylint: disable=too-many-return-statements
def ge_type_to_np(res_dt: Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;]):
    &#39;&#39;&#39; Convert a Geo Engine data type to a numpy data type &#39;&#39;&#39;

    if res_dt == &#34;U8&#34;:
        return np.uint8
    if res_dt == &#34;U16&#34;:
        return np.uint16
    if res_dt == &#34;U32&#34;:
        return np.uint32
    if res_dt == &#34;U64&#34;:
        return np.uint64
    if res_dt == &#34;I8&#34;:
        return np.int8
    if res_dt == &#34;I16&#34;:
        return np.int16
    if res_dt == &#34;I32&#34;:
        return np.int32
    if res_dt == &#34;I64&#34;:
        return np.int64
    if res_dt == &#34;F32&#34;:
        return np.float32
    if res_dt == &#34;F64&#34;:
        return np.float64
    raise TypeError(&#34;Unknown type literal&#34;)


class RasterTile2D:
    &#39;&#39;&#39;A 2D raster tile as produced by the Geo Engine&#39;&#39;&#39;
    size_x: int
    size_y: int
    data: pa.Array
    geo_transform: gety.GeoTransform
    crs: str
    time: gety.TimeInterval
    band: int

    # pylint: disable=too-many-arguments,too-many-positional-arguments
    def __init__(
            self,
            shape: Tuple[int, int],
            data: pa.Array,
            geo_transform: gety.GeoTransform,
            crs: str,
            time: gety.TimeInterval,
            band: int,
    ):
        &#39;&#39;&#39;Create a RasterTile2D object&#39;&#39;&#39;
        self.size_y, self.size_x = shape
        self.data = data
        self.geo_transform = geo_transform
        self.crs = crs
        self.time = time
        self.band = band

    @property
    def shape(self) -&gt; Tuple[int, int]:
        &#39;&#39;&#39;Return the shape of the raster tile in numpy order (y_size, x_size)&#39;&#39;&#39;
        return (self.size_y, self.size_x)

    @property
    def data_type(self) -&gt; pa.DataType:
        &#39;&#39;&#39;Return the arrow data type of the raster tile&#39;&#39;&#39;
        return self.data.type

    @property
    def numpy_data_type(self) -&gt; np.dtype:
        &#39;&#39;&#39;Return the numpy dtype of the raster tile&#39;&#39;&#39;
        return self.data_type.to_pandas_dtype()

    @property
    def has_null_values(self) -&gt; bool:
        &#39;&#39;&#39;Return whether the raster tile has null values&#39;&#39;&#39;
        return self.data.null_count &gt; 0

    @property
    def time_start_ms(self) -&gt; np.datetime64:
        return np.datetime64(self.time.start, &#39;ms&#39;)

    @property
    def time_end_ms(self) -&gt; np.datetime64:
        return np.datetime64(self.time.end, &#39;ms&#39;)

    @property
    def pixel_size(self) -&gt; Tuple[float, float]:
        return (self.geo_transform.x_pixel_size, self.geo_transform.y_pixel_size)

    def to_numpy_data_array(self, fill_null_value=0) -&gt; np.ndarray:
        &#39;&#39;&#39;
        Return the raster tile as a numpy array.
        Caution: this will not mask nodata values but replace them with the provided value !
        &#39;&#39;&#39;
        nulled_array = self.data.fill_null(fill_null_value)
        return nulled_array.to_numpy(
            zero_copy_only=True,  # data was already copied when creating the &#34;null filled&#34; array
        ).reshape(self.shape)

    def to_numpy_mask_array(self, nan_is_null=False) -&gt; Optional[np.ndarray]:
        &#39;&#39;&#39;
        Return the raster tiles mask as a numpy array.
        True means no data, False means data.
        If the raster tile has no null values, None is returned.
        It is possible to specify whether NaN values should be considered as no data when creating the mask.
        &#39;&#39;&#39;
        numpy_mask = None
        if self.has_null_values:
            numpy_mask = self.data.is_null(
                nan_is_null=nan_is_null  # nan is not no data
            ).to_numpy(
                zero_copy_only=False  # cannot zero-copy with bools
            ).reshape(self.shape)
        return numpy_mask

    def to_numpy_masked_array(self, nan_is_null=False) -&gt; np.ma.MaskedArray:
        &#39;&#39;&#39;Return the raster tile as a masked numpy array&#39;&#39;&#39;
        numpy_data = self.to_numpy_data_array()
        maybe_numpy_mask = self.to_numpy_mask_array(nan_is_null=nan_is_null)

        assert maybe_numpy_mask is None or maybe_numpy_mask.shape == numpy_data.shape

        numpy_mask: Union[np.ndarray, np.ma.MaskType] = np.ma.nomask if maybe_numpy_mask is None else maybe_numpy_mask

        numpy_masked_data: np.ma.MaskedArray = np.ma.masked_array(numpy_data, mask=numpy_mask)

        return numpy_masked_data

    def coords_x(self, pixel_center=False) -&gt; np.ndarray:
        &#39;&#39;&#39;
        Return the x coordinates of the raster tile
        If pixel_center is True, the coordinates will be the center of the pixels.
        Otherwise they will be the upper left edges.
        &#39;&#39;&#39;
        start = self.geo_transform.x_min

        if pixel_center:
            start += self.geo_transform.x_half_pixel_size

        return np.arange(
            start=start,
            stop=self.geo_transform.x_max(self.size_x),
            step=self.geo_transform.x_pixel_size,
        )

    def coords_y(self, pixel_center=False) -&gt; np.ndarray:
        &#39;&#39;&#39;
        Return the y coordinates of the raster tile
        If pixel_center is True, the coordinates will be the center of the pixels.
        Otherwise they will be the upper left edges.
        &#39;&#39;&#39;
        start = self.geo_transform.y_max

        if pixel_center:
            start += self.geo_transform.y_half_pixel_size

        return np.arange(
            start=start,
            stop=self.geo_transform.y_min(self.size_y),
            step=self.geo_transform.y_pixel_size,
        )

    def to_xarray(self, clip_with_bounds: Optional[gety.SpatialBounds] = None) -&gt; xr.DataArray:
        &#39;&#39;&#39;
        Return the raster tile as an xarray.DataArray.

        Note:
            - Xarray does not support masked arrays.
                - Masked pixels are converted to NaNs and the nodata value is set to NaN as well.
            - Xarray uses numpy&#39;s datetime64[ns] which only covers the years from 1678 to 2262.
                - Date times that are outside of the defined range are clipped to the limits of the range.
        &#39;&#39;&#39;

        # clamp the dates to the min and max range
        clamped_date = clamp_datetime_ms_ns(self.time_start_ms)

        array = xr.DataArray(
            self.to_numpy_masked_array(),
            dims=[&#34;y&#34;, &#34;x&#34;],
            coords={
                &#39;x&#39;: self.coords_x(pixel_center=True),
                &#39;y&#39;: self.coords_y(pixel_center=True),
                &#39;time&#39;: clamped_date,  # TODO: incorporate time end?
                &#39;band&#39;: self.band,
            }
        )
        array.rio.write_crs(self.crs, inplace=True)

        if clip_with_bounds is not None:
            array = array.rio.clip_box(*clip_with_bounds.as_bbox_tuple(), auto_expand=True)
            array = cast(xr.DataArray, array)

        return array

    def spatial_partition(self) -&gt; gety.SpatialPartition2D:
        &#39;&#39;&#39;Return the spatial partition of the raster tile&#39;&#39;&#39;
        return gety.SpatialPartition2D(
            self.geo_transform.x_min,
            self.geo_transform.y_min(self.size_y),
            self.geo_transform.x_max(self.size_x),
            self.geo_transform.y_max,
        )

    def spatial_resolution(self) -&gt; gety.SpatialResolution:
        return self.geo_transform.spatial_resolution()

    @staticmethod
    def from_ge_record_batch(record_batch: pa.RecordBatch) -&gt; RasterTile2D:
        &#39;&#39;&#39;Create a RasterTile2D from an Arrow record batch recieved from the Geo Engine&#39;&#39;&#39;
        metadata = record_batch.schema.metadata
        inner = geoengine_openapi_client.GdalDatasetGeoTransform.from_json(metadata[b&#39;geoTransform&#39;])
        assert inner is not None, &#34;Failed to parse geoTransform&#34;
        geo_transform = gety.GeoTransform.from_response(inner)
        x_size = int(metadata[b&#39;xSize&#39;])
        y_size = int(metadata[b&#39;ySize&#39;])
        spatial_reference = metadata[b&#39;spatialReference&#39;].decode(&#39;utf-8&#39;)
        # We know from the backend that there is only one array a.k.a. one column
        arrow_array = record_batch.column(0)

        inner_time = geoengine_openapi_client.TimeInterval.from_json(metadata[b&#39;time&#39;])
        assert inner_time is not None, &#34;Failed to parse time&#34;
        time = gety.TimeInterval.from_response(inner_time)

        band = int(metadata[b&#39;band&#39;])

        return RasterTile2D(
            (y_size, x_size),
            arrow_array,
            geo_transform,
            spatial_reference,
            time,
            band,
        )


class RasterTileStack2D:
    &#39;&#39;&#39;A stack of all the bands of a raster tile as produced by the Geo Engine&#39;&#39;&#39;
    size_y: int
    size_x: int
    geo_transform: gety.GeoTransform
    crs: str
    time: gety.TimeInterval
    data: List[pa.Array]
    bands: List[int]

    # pylint: disable=too-many-arguments,too-many-positional-arguments
    def __init__(
            self,
            tile_shape: Tuple[int, int],
            data: List[pa.Array],
            geo_transform: gety.GeoTransform,
            crs: str,
            time: gety.TimeInterval,
            bands: List[int],
    ):
        &#39;&#39;&#39;Create a RasterTileStack2D object&#39;&#39;&#39;
        (self.size_y, self.size_x) = tile_shape
        self.data = data
        self.geo_transform = geo_transform
        self.crs = crs
        self.time = time
        self.bands = bands

    def single_band(self, index: int) -&gt; RasterTile2D:
        &#39;&#39;&#39;Return a single band from the stack&#39;&#39;&#39;
        return RasterTile2D(
            (self.size_y, self.size_x),
            self.data[index],
            self.geo_transform,
            self.crs,
            self.time,
            self.bands[index],
        )

    def to_numpy_masked_array_stack(self) -&gt; np.ma.MaskedArray:
        &#39;&#39;&#39;Return the raster stack as a 3D masked numpy array&#39;&#39;&#39;
        arrays = [self.single_band(i).to_numpy_masked_array() for i in range(0, len(self.data))]
        stack = np.stack(arrays, axis=0)
        return stack

    def to_xarray(self, clip_with_bounds: Optional[gety.SpatialBounds] = None) -&gt; xr.DataArray:
        &#39;&#39;&#39;Return the raster stack as an xarray.DataArray&#39;&#39;&#39;
        arrays = [self.single_band(i).to_xarray(clip_with_bounds) for i in range(0, len(self.data))]
        stack = xr.concat(arrays, dim=&#39;band&#39;)
        return stack


async def tile_stream_to_stack_stream(raster_stream: AsyncIterator[RasterTile2D]) -&gt; AsyncIterator[RasterTileStack2D]:
    &#39;&#39;&#39; Convert a stream of raster tiles to stream of stacked tiles &#39;&#39;&#39;
    store: List[RasterTile2D] = []
    first_band: int = -1

    async for tile in raster_stream:
        if len(store) == 0:
            first_band = tile.band
            store.append(tile)

        else:
            # check things that should be the same for all tiles
            assert tile.shape == store[0].shape, &#39;Tile shapes do not match&#39;
            # TODO: geo transform should be the same for all tiles
            #       tiles should have a tile position or global pixel position

            # assert tile.geo_transform == store[0].geo_transform, &#39;Tile geo_transforms do not match&#39;
            assert tile.crs == store[0].crs, &#39;Tile crs do not match&#39;

            if tile.band == first_band:
                assert tile.time.start &gt;= store[0].time.start, &#39;Tile time intervals must be equal or increasing&#39;

                stack = [tile.data for tile in store]
                tile_shape = store[0].shape
                bands = [tile.band for tile in store]
                geo_transforms = store[0].geo_transform
                crs = store[0].crs
                time = store[0].time

                store = [tile]
                yield RasterTileStack2D(tile_shape, stack, geo_transforms, crs, time, bands)

            else:
                assert tile.time == store[0].time, &#39;Time missmatch. &#39; + str(store[0].time) + &#39; != &#39; + str(tile.time)
                store.append(tile)

    if len(store) &gt; 0:
        tile_shape = store[0].shape
        stack = [tile.data for tile in store]
        bands = [tile.band for tile in store]
        geo_transforms = store[0].geo_transform
        crs = store[0].crs
        time = store[0].time

        store = []

        yield RasterTileStack2D(tile_shape, stack, geo_transforms, crs, time, bands)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="geoengine.raster.ge_type_to_np"><code class="name flex">
<span>def <span class="ident">ge_type_to_np</span></span>(<span>res_dt: "Literal['U8', 'U16', 'U32', 'U64', 'I8', 'I16', 'I32', 'I64', 'F32', 'F64']")</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a Geo Engine data type to a numpy data type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ge_type_to_np(res_dt: Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;]):
    &#39;&#39;&#39; Convert a Geo Engine data type to a numpy data type &#39;&#39;&#39;

    if res_dt == &#34;U8&#34;:
        return np.uint8
    if res_dt == &#34;U16&#34;:
        return np.uint16
    if res_dt == &#34;U32&#34;:
        return np.uint32
    if res_dt == &#34;U64&#34;:
        return np.uint64
    if res_dt == &#34;I8&#34;:
        return np.int8
    if res_dt == &#34;I16&#34;:
        return np.int16
    if res_dt == &#34;I32&#34;:
        return np.int32
    if res_dt == &#34;I64&#34;:
        return np.int64
    if res_dt == &#34;F32&#34;:
        return np.float32
    if res_dt == &#34;F64&#34;:
        return np.float64
    raise TypeError(&#34;Unknown type literal&#34;)</code></pre>
</details>
</dd>
<dt id="geoengine.raster.tile_stream_to_stack_stream"><code class="name flex">
<span>async def <span class="ident">tile_stream_to_stack_stream</span></span>(<span>raster_stream: AsyncIterator[<a title="geoengine.raster.RasterTile2D" href="#geoengine.raster.RasterTile2D">RasterTile2D</a>]) ‑> AsyncIterator[<a title="geoengine.raster.RasterTileStack2D" href="#geoengine.raster.RasterTileStack2D">RasterTileStack2D</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a stream of raster tiles to stream of stacked tiles</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def tile_stream_to_stack_stream(raster_stream: AsyncIterator[RasterTile2D]) -&gt; AsyncIterator[RasterTileStack2D]:
    &#39;&#39;&#39; Convert a stream of raster tiles to stream of stacked tiles &#39;&#39;&#39;
    store: List[RasterTile2D] = []
    first_band: int = -1

    async for tile in raster_stream:
        if len(store) == 0:
            first_band = tile.band
            store.append(tile)

        else:
            # check things that should be the same for all tiles
            assert tile.shape == store[0].shape, &#39;Tile shapes do not match&#39;
            # TODO: geo transform should be the same for all tiles
            #       tiles should have a tile position or global pixel position

            # assert tile.geo_transform == store[0].geo_transform, &#39;Tile geo_transforms do not match&#39;
            assert tile.crs == store[0].crs, &#39;Tile crs do not match&#39;

            if tile.band == first_band:
                assert tile.time.start &gt;= store[0].time.start, &#39;Tile time intervals must be equal or increasing&#39;

                stack = [tile.data for tile in store]
                tile_shape = store[0].shape
                bands = [tile.band for tile in store]
                geo_transforms = store[0].geo_transform
                crs = store[0].crs
                time = store[0].time

                store = [tile]
                yield RasterTileStack2D(tile_shape, stack, geo_transforms, crs, time, bands)

            else:
                assert tile.time == store[0].time, &#39;Time missmatch. &#39; + str(store[0].time) + &#39; != &#39; + str(tile.time)
                store.append(tile)

    if len(store) &gt; 0:
        tile_shape = store[0].shape
        stack = [tile.data for tile in store]
        bands = [tile.band for tile in store]
        geo_transforms = store[0].geo_transform
        crs = store[0].crs
        time = store[0].time

        store = []

        yield RasterTileStack2D(tile_shape, stack, geo_transforms, crs, time, bands)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="geoengine.raster.RasterTile2D"><code class="flex name class">
<span>class <span class="ident">RasterTile2D</span></span>
<span>(</span><span>shape: Tuple[int, int], data: pa.Array, geo_transform: gety.GeoTransform, crs: str, time: gety.TimeInterval, band: int)</span>
</code></dt>
<dd>
<div class="desc"><p>A 2D raster tile as produced by the Geo Engine</p>
<p>Create a RasterTile2D object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RasterTile2D:
    &#39;&#39;&#39;A 2D raster tile as produced by the Geo Engine&#39;&#39;&#39;
    size_x: int
    size_y: int
    data: pa.Array
    geo_transform: gety.GeoTransform
    crs: str
    time: gety.TimeInterval
    band: int

    # pylint: disable=too-many-arguments,too-many-positional-arguments
    def __init__(
            self,
            shape: Tuple[int, int],
            data: pa.Array,
            geo_transform: gety.GeoTransform,
            crs: str,
            time: gety.TimeInterval,
            band: int,
    ):
        &#39;&#39;&#39;Create a RasterTile2D object&#39;&#39;&#39;
        self.size_y, self.size_x = shape
        self.data = data
        self.geo_transform = geo_transform
        self.crs = crs
        self.time = time
        self.band = band

    @property
    def shape(self) -&gt; Tuple[int, int]:
        &#39;&#39;&#39;Return the shape of the raster tile in numpy order (y_size, x_size)&#39;&#39;&#39;
        return (self.size_y, self.size_x)

    @property
    def data_type(self) -&gt; pa.DataType:
        &#39;&#39;&#39;Return the arrow data type of the raster tile&#39;&#39;&#39;
        return self.data.type

    @property
    def numpy_data_type(self) -&gt; np.dtype:
        &#39;&#39;&#39;Return the numpy dtype of the raster tile&#39;&#39;&#39;
        return self.data_type.to_pandas_dtype()

    @property
    def has_null_values(self) -&gt; bool:
        &#39;&#39;&#39;Return whether the raster tile has null values&#39;&#39;&#39;
        return self.data.null_count &gt; 0

    @property
    def time_start_ms(self) -&gt; np.datetime64:
        return np.datetime64(self.time.start, &#39;ms&#39;)

    @property
    def time_end_ms(self) -&gt; np.datetime64:
        return np.datetime64(self.time.end, &#39;ms&#39;)

    @property
    def pixel_size(self) -&gt; Tuple[float, float]:
        return (self.geo_transform.x_pixel_size, self.geo_transform.y_pixel_size)

    def to_numpy_data_array(self, fill_null_value=0) -&gt; np.ndarray:
        &#39;&#39;&#39;
        Return the raster tile as a numpy array.
        Caution: this will not mask nodata values but replace them with the provided value !
        &#39;&#39;&#39;
        nulled_array = self.data.fill_null(fill_null_value)
        return nulled_array.to_numpy(
            zero_copy_only=True,  # data was already copied when creating the &#34;null filled&#34; array
        ).reshape(self.shape)

    def to_numpy_mask_array(self, nan_is_null=False) -&gt; Optional[np.ndarray]:
        &#39;&#39;&#39;
        Return the raster tiles mask as a numpy array.
        True means no data, False means data.
        If the raster tile has no null values, None is returned.
        It is possible to specify whether NaN values should be considered as no data when creating the mask.
        &#39;&#39;&#39;
        numpy_mask = None
        if self.has_null_values:
            numpy_mask = self.data.is_null(
                nan_is_null=nan_is_null  # nan is not no data
            ).to_numpy(
                zero_copy_only=False  # cannot zero-copy with bools
            ).reshape(self.shape)
        return numpy_mask

    def to_numpy_masked_array(self, nan_is_null=False) -&gt; np.ma.MaskedArray:
        &#39;&#39;&#39;Return the raster tile as a masked numpy array&#39;&#39;&#39;
        numpy_data = self.to_numpy_data_array()
        maybe_numpy_mask = self.to_numpy_mask_array(nan_is_null=nan_is_null)

        assert maybe_numpy_mask is None or maybe_numpy_mask.shape == numpy_data.shape

        numpy_mask: Union[np.ndarray, np.ma.MaskType] = np.ma.nomask if maybe_numpy_mask is None else maybe_numpy_mask

        numpy_masked_data: np.ma.MaskedArray = np.ma.masked_array(numpy_data, mask=numpy_mask)

        return numpy_masked_data

    def coords_x(self, pixel_center=False) -&gt; np.ndarray:
        &#39;&#39;&#39;
        Return the x coordinates of the raster tile
        If pixel_center is True, the coordinates will be the center of the pixels.
        Otherwise they will be the upper left edges.
        &#39;&#39;&#39;
        start = self.geo_transform.x_min

        if pixel_center:
            start += self.geo_transform.x_half_pixel_size

        return np.arange(
            start=start,
            stop=self.geo_transform.x_max(self.size_x),
            step=self.geo_transform.x_pixel_size,
        )

    def coords_y(self, pixel_center=False) -&gt; np.ndarray:
        &#39;&#39;&#39;
        Return the y coordinates of the raster tile
        If pixel_center is True, the coordinates will be the center of the pixels.
        Otherwise they will be the upper left edges.
        &#39;&#39;&#39;
        start = self.geo_transform.y_max

        if pixel_center:
            start += self.geo_transform.y_half_pixel_size

        return np.arange(
            start=start,
            stop=self.geo_transform.y_min(self.size_y),
            step=self.geo_transform.y_pixel_size,
        )

    def to_xarray(self, clip_with_bounds: Optional[gety.SpatialBounds] = None) -&gt; xr.DataArray:
        &#39;&#39;&#39;
        Return the raster tile as an xarray.DataArray.

        Note:
            - Xarray does not support masked arrays.
                - Masked pixels are converted to NaNs and the nodata value is set to NaN as well.
            - Xarray uses numpy&#39;s datetime64[ns] which only covers the years from 1678 to 2262.
                - Date times that are outside of the defined range are clipped to the limits of the range.
        &#39;&#39;&#39;

        # clamp the dates to the min and max range
        clamped_date = clamp_datetime_ms_ns(self.time_start_ms)

        array = xr.DataArray(
            self.to_numpy_masked_array(),
            dims=[&#34;y&#34;, &#34;x&#34;],
            coords={
                &#39;x&#39;: self.coords_x(pixel_center=True),
                &#39;y&#39;: self.coords_y(pixel_center=True),
                &#39;time&#39;: clamped_date,  # TODO: incorporate time end?
                &#39;band&#39;: self.band,
            }
        )
        array.rio.write_crs(self.crs, inplace=True)

        if clip_with_bounds is not None:
            array = array.rio.clip_box(*clip_with_bounds.as_bbox_tuple(), auto_expand=True)
            array = cast(xr.DataArray, array)

        return array

    def spatial_partition(self) -&gt; gety.SpatialPartition2D:
        &#39;&#39;&#39;Return the spatial partition of the raster tile&#39;&#39;&#39;
        return gety.SpatialPartition2D(
            self.geo_transform.x_min,
            self.geo_transform.y_min(self.size_y),
            self.geo_transform.x_max(self.size_x),
            self.geo_transform.y_max,
        )

    def spatial_resolution(self) -&gt; gety.SpatialResolution:
        return self.geo_transform.spatial_resolution()

    @staticmethod
    def from_ge_record_batch(record_batch: pa.RecordBatch) -&gt; RasterTile2D:
        &#39;&#39;&#39;Create a RasterTile2D from an Arrow record batch recieved from the Geo Engine&#39;&#39;&#39;
        metadata = record_batch.schema.metadata
        inner = geoengine_openapi_client.GdalDatasetGeoTransform.from_json(metadata[b&#39;geoTransform&#39;])
        assert inner is not None, &#34;Failed to parse geoTransform&#34;
        geo_transform = gety.GeoTransform.from_response(inner)
        x_size = int(metadata[b&#39;xSize&#39;])
        y_size = int(metadata[b&#39;ySize&#39;])
        spatial_reference = metadata[b&#39;spatialReference&#39;].decode(&#39;utf-8&#39;)
        # We know from the backend that there is only one array a.k.a. one column
        arrow_array = record_batch.column(0)

        inner_time = geoengine_openapi_client.TimeInterval.from_json(metadata[b&#39;time&#39;])
        assert inner_time is not None, &#34;Failed to parse time&#34;
        time = gety.TimeInterval.from_response(inner_time)

        band = int(metadata[b&#39;band&#39;])

        return RasterTile2D(
            (y_size, x_size),
            arrow_array,
            geo_transform,
            spatial_reference,
            time,
            band,
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.raster.RasterTile2D.band"><code class="name">var <span class="ident">band</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster.RasterTile2D.crs"><code class="name">var <span class="ident">crs</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster.RasterTile2D.data"><code class="name">var <span class="ident">data</span> : pyarrow.lib.Array</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster.RasterTile2D.geo_transform"><code class="name">var <span class="ident">geo_transform</span> : <a title="geoengine.types.GeoTransform" href="types.html#geoengine.types.GeoTransform">GeoTransform</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster.RasterTile2D.size_x"><code class="name">var <span class="ident">size_x</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster.RasterTile2D.size_y"><code class="name">var <span class="ident">size_y</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster.RasterTile2D.time"><code class="name">var <span class="ident">time</span> : <a title="geoengine.types.TimeInterval" href="types.html#geoengine.types.TimeInterval">TimeInterval</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.raster.RasterTile2D.from_ge_record_batch"><code class="name flex">
<span>def <span class="ident">from_ge_record_batch</span></span>(<span>record_batch: pa.RecordBatch) ‑> <a title="geoengine.raster.RasterTile2D" href="#geoengine.raster.RasterTile2D">RasterTile2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a RasterTile2D from an Arrow record batch recieved from the Geo Engine</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_ge_record_batch(record_batch: pa.RecordBatch) -&gt; RasterTile2D:
    &#39;&#39;&#39;Create a RasterTile2D from an Arrow record batch recieved from the Geo Engine&#39;&#39;&#39;
    metadata = record_batch.schema.metadata
    inner = geoengine_openapi_client.GdalDatasetGeoTransform.from_json(metadata[b&#39;geoTransform&#39;])
    assert inner is not None, &#34;Failed to parse geoTransform&#34;
    geo_transform = gety.GeoTransform.from_response(inner)
    x_size = int(metadata[b&#39;xSize&#39;])
    y_size = int(metadata[b&#39;ySize&#39;])
    spatial_reference = metadata[b&#39;spatialReference&#39;].decode(&#39;utf-8&#39;)
    # We know from the backend that there is only one array a.k.a. one column
    arrow_array = record_batch.column(0)

    inner_time = geoengine_openapi_client.TimeInterval.from_json(metadata[b&#39;time&#39;])
    assert inner_time is not None, &#34;Failed to parse time&#34;
    time = gety.TimeInterval.from_response(inner_time)

    band = int(metadata[b&#39;band&#39;])

    return RasterTile2D(
        (y_size, x_size),
        arrow_array,
        geo_transform,
        spatial_reference,
        time,
        band,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.raster.RasterTile2D.data_type"><code class="name">var <span class="ident">data_type</span> : pyarrow.lib.DataType</code></dt>
<dd>
<div class="desc"><p>Return the arrow data type of the raster tile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_type(self) -&gt; pa.DataType:
    &#39;&#39;&#39;Return the arrow data type of the raster tile&#39;&#39;&#39;
    return self.data.type</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTile2D.has_null_values"><code class="name">var <span class="ident">has_null_values</span> : bool</code></dt>
<dd>
<div class="desc"><p>Return whether the raster tile has null values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def has_null_values(self) -&gt; bool:
    &#39;&#39;&#39;Return whether the raster tile has null values&#39;&#39;&#39;
    return self.data.null_count &gt; 0</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTile2D.numpy_data_type"><code class="name">var <span class="ident">numpy_data_type</span> : numpy.dtype</code></dt>
<dd>
<div class="desc"><p>Return the numpy dtype of the raster tile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def numpy_data_type(self) -&gt; np.dtype:
    &#39;&#39;&#39;Return the numpy dtype of the raster tile&#39;&#39;&#39;
    return self.data_type.to_pandas_dtype()</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTile2D.pixel_size"><code class="name">var <span class="ident">pixel_size</span> : Tuple[float, float]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pixel_size(self) -&gt; Tuple[float, float]:
    return (self.geo_transform.x_pixel_size, self.geo_transform.y_pixel_size)</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTile2D.shape"><code class="name">var <span class="ident">shape</span> : Tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Return the shape of the raster tile in numpy order (y_size, x_size)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; Tuple[int, int]:
    &#39;&#39;&#39;Return the shape of the raster tile in numpy order (y_size, x_size)&#39;&#39;&#39;
    return (self.size_y, self.size_x)</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTile2D.time_end_ms"><code class="name">var <span class="ident">time_end_ms</span> : numpy.datetime64</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_end_ms(self) -&gt; np.datetime64:
    return np.datetime64(self.time.end, &#39;ms&#39;)</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTile2D.time_start_ms"><code class="name">var <span class="ident">time_start_ms</span> : numpy.datetime64</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_start_ms(self) -&gt; np.datetime64:
    return np.datetime64(self.time.start, &#39;ms&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.raster.RasterTile2D.coords_x"><code class="name flex">
<span>def <span class="ident">coords_x</span></span>(<span>self, pixel_center=False) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Return the x coordinates of the raster tile
If pixel_center is True, the coordinates will be the center of the pixels.
Otherwise they will be the upper left edges.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coords_x(self, pixel_center=False) -&gt; np.ndarray:
    &#39;&#39;&#39;
    Return the x coordinates of the raster tile
    If pixel_center is True, the coordinates will be the center of the pixels.
    Otherwise they will be the upper left edges.
    &#39;&#39;&#39;
    start = self.geo_transform.x_min

    if pixel_center:
        start += self.geo_transform.x_half_pixel_size

    return np.arange(
        start=start,
        stop=self.geo_transform.x_max(self.size_x),
        step=self.geo_transform.x_pixel_size,
    )</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTile2D.coords_y"><code class="name flex">
<span>def <span class="ident">coords_y</span></span>(<span>self, pixel_center=False) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Return the y coordinates of the raster tile
If pixel_center is True, the coordinates will be the center of the pixels.
Otherwise they will be the upper left edges.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coords_y(self, pixel_center=False) -&gt; np.ndarray:
    &#39;&#39;&#39;
    Return the y coordinates of the raster tile
    If pixel_center is True, the coordinates will be the center of the pixels.
    Otherwise they will be the upper left edges.
    &#39;&#39;&#39;
    start = self.geo_transform.y_max

    if pixel_center:
        start += self.geo_transform.y_half_pixel_size

    return np.arange(
        start=start,
        stop=self.geo_transform.y_min(self.size_y),
        step=self.geo_transform.y_pixel_size,
    )</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTile2D.spatial_partition"><code class="name flex">
<span>def <span class="ident">spatial_partition</span></span>(<span>self) ‑> <a title="geoengine.types.SpatialPartition2D" href="types.html#geoengine.types.SpatialPartition2D">SpatialPartition2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return the spatial partition of the raster tile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spatial_partition(self) -&gt; gety.SpatialPartition2D:
    &#39;&#39;&#39;Return the spatial partition of the raster tile&#39;&#39;&#39;
    return gety.SpatialPartition2D(
        self.geo_transform.x_min,
        self.geo_transform.y_min(self.size_y),
        self.geo_transform.x_max(self.size_x),
        self.geo_transform.y_max,
    )</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTile2D.spatial_resolution"><code class="name flex">
<span>def <span class="ident">spatial_resolution</span></span>(<span>self) ‑> <a title="geoengine.types.SpatialResolution" href="types.html#geoengine.types.SpatialResolution">SpatialResolution</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spatial_resolution(self) -&gt; gety.SpatialResolution:
    return self.geo_transform.spatial_resolution()</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTile2D.to_numpy_data_array"><code class="name flex">
<span>def <span class="ident">to_numpy_data_array</span></span>(<span>self, fill_null_value=0) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Return the raster tile as a numpy array.
Caution: this will not mask nodata values but replace them with the provided value !</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_numpy_data_array(self, fill_null_value=0) -&gt; np.ndarray:
    &#39;&#39;&#39;
    Return the raster tile as a numpy array.
    Caution: this will not mask nodata values but replace them with the provided value !
    &#39;&#39;&#39;
    nulled_array = self.data.fill_null(fill_null_value)
    return nulled_array.to_numpy(
        zero_copy_only=True,  # data was already copied when creating the &#34;null filled&#34; array
    ).reshape(self.shape)</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTile2D.to_numpy_mask_array"><code class="name flex">
<span>def <span class="ident">to_numpy_mask_array</span></span>(<span>self, nan_is_null=False) ‑> Optional[numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the raster tiles mask as a numpy array.
True means no data, False means data.
If the raster tile has no null values, None is returned.
It is possible to specify whether NaN values should be considered as no data when creating the mask.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_numpy_mask_array(self, nan_is_null=False) -&gt; Optional[np.ndarray]:
    &#39;&#39;&#39;
    Return the raster tiles mask as a numpy array.
    True means no data, False means data.
    If the raster tile has no null values, None is returned.
    It is possible to specify whether NaN values should be considered as no data when creating the mask.
    &#39;&#39;&#39;
    numpy_mask = None
    if self.has_null_values:
        numpy_mask = self.data.is_null(
            nan_is_null=nan_is_null  # nan is not no data
        ).to_numpy(
            zero_copy_only=False  # cannot zero-copy with bools
        ).reshape(self.shape)
    return numpy_mask</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTile2D.to_numpy_masked_array"><code class="name flex">
<span>def <span class="ident">to_numpy_masked_array</span></span>(<span>self, nan_is_null=False) ‑> numpy.ma.core.MaskedArray</span>
</code></dt>
<dd>
<div class="desc"><p>Return the raster tile as a masked numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_numpy_masked_array(self, nan_is_null=False) -&gt; np.ma.MaskedArray:
    &#39;&#39;&#39;Return the raster tile as a masked numpy array&#39;&#39;&#39;
    numpy_data = self.to_numpy_data_array()
    maybe_numpy_mask = self.to_numpy_mask_array(nan_is_null=nan_is_null)

    assert maybe_numpy_mask is None or maybe_numpy_mask.shape == numpy_data.shape

    numpy_mask: Union[np.ndarray, np.ma.MaskType] = np.ma.nomask if maybe_numpy_mask is None else maybe_numpy_mask

    numpy_masked_data: np.ma.MaskedArray = np.ma.masked_array(numpy_data, mask=numpy_mask)

    return numpy_masked_data</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTile2D.to_xarray"><code class="name flex">
<span>def <span class="ident">to_xarray</span></span>(<span>self, clip_with_bounds: Optional[gety.SpatialBounds] = None) ‑> xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>Return the raster tile as an xarray.DataArray.</p>
<h2 id="note">Note</h2>
<ul>
<li>Xarray does not support masked arrays.<ul>
<li>Masked pixels are converted to NaNs and the nodata value is set to NaN as well.</li>
</ul>
</li>
<li>Xarray uses numpy's datetime64[ns] which only covers the years from 1678 to 2262.<ul>
<li>Date times that are outside of the defined range are clipped to the limits of the range.</li>
</ul>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xarray(self, clip_with_bounds: Optional[gety.SpatialBounds] = None) -&gt; xr.DataArray:
    &#39;&#39;&#39;
    Return the raster tile as an xarray.DataArray.

    Note:
        - Xarray does not support masked arrays.
            - Masked pixels are converted to NaNs and the nodata value is set to NaN as well.
        - Xarray uses numpy&#39;s datetime64[ns] which only covers the years from 1678 to 2262.
            - Date times that are outside of the defined range are clipped to the limits of the range.
    &#39;&#39;&#39;

    # clamp the dates to the min and max range
    clamped_date = clamp_datetime_ms_ns(self.time_start_ms)

    array = xr.DataArray(
        self.to_numpy_masked_array(),
        dims=[&#34;y&#34;, &#34;x&#34;],
        coords={
            &#39;x&#39;: self.coords_x(pixel_center=True),
            &#39;y&#39;: self.coords_y(pixel_center=True),
            &#39;time&#39;: clamped_date,  # TODO: incorporate time end?
            &#39;band&#39;: self.band,
        }
    )
    array.rio.write_crs(self.crs, inplace=True)

    if clip_with_bounds is not None:
        array = array.rio.clip_box(*clip_with_bounds.as_bbox_tuple(), auto_expand=True)
        array = cast(xr.DataArray, array)

    return array</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.raster.RasterTileStack2D"><code class="flex name class">
<span>class <span class="ident">RasterTileStack2D</span></span>
<span>(</span><span>tile_shape: Tuple[int, int], data: List[pa.Array], geo_transform: gety.GeoTransform, crs: str, time: gety.TimeInterval, bands: List[int])</span>
</code></dt>
<dd>
<div class="desc"><p>A stack of all the bands of a raster tile as produced by the Geo Engine</p>
<p>Create a RasterTileStack2D object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RasterTileStack2D:
    &#39;&#39;&#39;A stack of all the bands of a raster tile as produced by the Geo Engine&#39;&#39;&#39;
    size_y: int
    size_x: int
    geo_transform: gety.GeoTransform
    crs: str
    time: gety.TimeInterval
    data: List[pa.Array]
    bands: List[int]

    # pylint: disable=too-many-arguments,too-many-positional-arguments
    def __init__(
            self,
            tile_shape: Tuple[int, int],
            data: List[pa.Array],
            geo_transform: gety.GeoTransform,
            crs: str,
            time: gety.TimeInterval,
            bands: List[int],
    ):
        &#39;&#39;&#39;Create a RasterTileStack2D object&#39;&#39;&#39;
        (self.size_y, self.size_x) = tile_shape
        self.data = data
        self.geo_transform = geo_transform
        self.crs = crs
        self.time = time
        self.bands = bands

    def single_band(self, index: int) -&gt; RasterTile2D:
        &#39;&#39;&#39;Return a single band from the stack&#39;&#39;&#39;
        return RasterTile2D(
            (self.size_y, self.size_x),
            self.data[index],
            self.geo_transform,
            self.crs,
            self.time,
            self.bands[index],
        )

    def to_numpy_masked_array_stack(self) -&gt; np.ma.MaskedArray:
        &#39;&#39;&#39;Return the raster stack as a 3D masked numpy array&#39;&#39;&#39;
        arrays = [self.single_band(i).to_numpy_masked_array() for i in range(0, len(self.data))]
        stack = np.stack(arrays, axis=0)
        return stack

    def to_xarray(self, clip_with_bounds: Optional[gety.SpatialBounds] = None) -&gt; xr.DataArray:
        &#39;&#39;&#39;Return the raster stack as an xarray.DataArray&#39;&#39;&#39;
        arrays = [self.single_band(i).to_xarray(clip_with_bounds) for i in range(0, len(self.data))]
        stack = xr.concat(arrays, dim=&#39;band&#39;)
        return stack</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.raster.RasterTileStack2D.bands"><code class="name">var <span class="ident">bands</span> : List[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster.RasterTileStack2D.crs"><code class="name">var <span class="ident">crs</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster.RasterTileStack2D.data"><code class="name">var <span class="ident">data</span> : List[pyarrow.lib.Array]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster.RasterTileStack2D.geo_transform"><code class="name">var <span class="ident">geo_transform</span> : <a title="geoengine.types.GeoTransform" href="types.html#geoengine.types.GeoTransform">GeoTransform</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster.RasterTileStack2D.size_x"><code class="name">var <span class="ident">size_x</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster.RasterTileStack2D.size_y"><code class="name">var <span class="ident">size_y</span> : int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster.RasterTileStack2D.time"><code class="name">var <span class="ident">time</span> : <a title="geoengine.types.TimeInterval" href="types.html#geoengine.types.TimeInterval">TimeInterval</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.raster.RasterTileStack2D.single_band"><code class="name flex">
<span>def <span class="ident">single_band</span></span>(<span>self, index: int) ‑> <a title="geoengine.raster.RasterTile2D" href="#geoengine.raster.RasterTile2D">RasterTile2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>Return a single band from the stack</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def single_band(self, index: int) -&gt; RasterTile2D:
    &#39;&#39;&#39;Return a single band from the stack&#39;&#39;&#39;
    return RasterTile2D(
        (self.size_y, self.size_x),
        self.data[index],
        self.geo_transform,
        self.crs,
        self.time,
        self.bands[index],
    )</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTileStack2D.to_numpy_masked_array_stack"><code class="name flex">
<span>def <span class="ident">to_numpy_masked_array_stack</span></span>(<span>self) ‑> numpy.ma.core.MaskedArray</span>
</code></dt>
<dd>
<div class="desc"><p>Return the raster stack as a 3D masked numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_numpy_masked_array_stack(self) -&gt; np.ma.MaskedArray:
    &#39;&#39;&#39;Return the raster stack as a 3D masked numpy array&#39;&#39;&#39;
    arrays = [self.single_band(i).to_numpy_masked_array() for i in range(0, len(self.data))]
    stack = np.stack(arrays, axis=0)
    return stack</code></pre>
</details>
</dd>
<dt id="geoengine.raster.RasterTileStack2D.to_xarray"><code class="name flex">
<span>def <span class="ident">to_xarray</span></span>(<span>self, clip_with_bounds: Optional[gety.SpatialBounds] = None) ‑> xarray.core.dataarray.DataArray</span>
</code></dt>
<dd>
<div class="desc"><p>Return the raster stack as an xarray.DataArray</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xarray(self, clip_with_bounds: Optional[gety.SpatialBounds] = None) -&gt; xr.DataArray:
    &#39;&#39;&#39;Return the raster stack as an xarray.DataArray&#39;&#39;&#39;
    arrays = [self.single_band(i).to_xarray(clip_with_bounds) for i in range(0, len(self.data))]
    stack = xr.concat(arrays, dim=&#39;band&#39;)
    return stack</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geoengine" href="index.html">geoengine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="geoengine.raster.ge_type_to_np" href="#geoengine.raster.ge_type_to_np">ge_type_to_np</a></code></li>
<li><code><a title="geoengine.raster.tile_stream_to_stack_stream" href="#geoengine.raster.tile_stream_to_stack_stream">tile_stream_to_stack_stream</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="geoengine.raster.RasterTile2D" href="#geoengine.raster.RasterTile2D">RasterTile2D</a></code></h4>
<ul class="">
<li><code><a title="geoengine.raster.RasterTile2D.band" href="#geoengine.raster.RasterTile2D.band">band</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.coords_x" href="#geoengine.raster.RasterTile2D.coords_x">coords_x</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.coords_y" href="#geoengine.raster.RasterTile2D.coords_y">coords_y</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.crs" href="#geoengine.raster.RasterTile2D.crs">crs</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.data" href="#geoengine.raster.RasterTile2D.data">data</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.data_type" href="#geoengine.raster.RasterTile2D.data_type">data_type</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.from_ge_record_batch" href="#geoengine.raster.RasterTile2D.from_ge_record_batch">from_ge_record_batch</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.geo_transform" href="#geoengine.raster.RasterTile2D.geo_transform">geo_transform</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.has_null_values" href="#geoengine.raster.RasterTile2D.has_null_values">has_null_values</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.numpy_data_type" href="#geoengine.raster.RasterTile2D.numpy_data_type">numpy_data_type</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.pixel_size" href="#geoengine.raster.RasterTile2D.pixel_size">pixel_size</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.shape" href="#geoengine.raster.RasterTile2D.shape">shape</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.size_x" href="#geoengine.raster.RasterTile2D.size_x">size_x</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.size_y" href="#geoengine.raster.RasterTile2D.size_y">size_y</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.spatial_partition" href="#geoengine.raster.RasterTile2D.spatial_partition">spatial_partition</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.spatial_resolution" href="#geoengine.raster.RasterTile2D.spatial_resolution">spatial_resolution</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.time" href="#geoengine.raster.RasterTile2D.time">time</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.time_end_ms" href="#geoengine.raster.RasterTile2D.time_end_ms">time_end_ms</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.time_start_ms" href="#geoengine.raster.RasterTile2D.time_start_ms">time_start_ms</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.to_numpy_data_array" href="#geoengine.raster.RasterTile2D.to_numpy_data_array">to_numpy_data_array</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.to_numpy_mask_array" href="#geoengine.raster.RasterTile2D.to_numpy_mask_array">to_numpy_mask_array</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.to_numpy_masked_array" href="#geoengine.raster.RasterTile2D.to_numpy_masked_array">to_numpy_masked_array</a></code></li>
<li><code><a title="geoengine.raster.RasterTile2D.to_xarray" href="#geoengine.raster.RasterTile2D.to_xarray">to_xarray</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.raster.RasterTileStack2D" href="#geoengine.raster.RasterTileStack2D">RasterTileStack2D</a></code></h4>
<ul class="">
<li><code><a title="geoengine.raster.RasterTileStack2D.bands" href="#geoengine.raster.RasterTileStack2D.bands">bands</a></code></li>
<li><code><a title="geoengine.raster.RasterTileStack2D.crs" href="#geoengine.raster.RasterTileStack2D.crs">crs</a></code></li>
<li><code><a title="geoengine.raster.RasterTileStack2D.data" href="#geoengine.raster.RasterTileStack2D.data">data</a></code></li>
<li><code><a title="geoengine.raster.RasterTileStack2D.geo_transform" href="#geoengine.raster.RasterTileStack2D.geo_transform">geo_transform</a></code></li>
<li><code><a title="geoengine.raster.RasterTileStack2D.single_band" href="#geoengine.raster.RasterTileStack2D.single_band">single_band</a></code></li>
<li><code><a title="geoengine.raster.RasterTileStack2D.size_x" href="#geoengine.raster.RasterTileStack2D.size_x">size_x</a></code></li>
<li><code><a title="geoengine.raster.RasterTileStack2D.size_y" href="#geoengine.raster.RasterTileStack2D.size_y">size_y</a></code></li>
<li><code><a title="geoengine.raster.RasterTileStack2D.time" href="#geoengine.raster.RasterTileStack2D.time">time</a></code></li>
<li><code><a title="geoengine.raster.RasterTileStack2D.to_numpy_masked_array_stack" href="#geoengine.raster.RasterTileStack2D.to_numpy_masked_array_stack">to_numpy_masked_array_stack</a></code></li>
<li><code><a title="geoengine.raster.RasterTileStack2D.to_xarray" href="#geoengine.raster.RasterTileStack2D.to_xarray">to_xarray</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>