<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>geoengine.raster_workflow_rio_writer API documentation</title>
<meta name="description" content="A module that contains classes to write raster data from a Geo Engine raster workflow." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geoengine.raster_workflow_rio_writer</code></h1>
</header>
<section id="section-intro">
<p>A module that contains classes to write raster data from a Geo Engine raster workflow.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#39;&#39;&#39; A module that contains classes to write raster data from a Geo Engine raster workflow. &#39;&#39;&#39;

from typing import Optional, cast
from datetime import datetime
import rasterio as rio
import numpy as np
from geoengine.workflow import Workflow, QueryRectangle
from geoengine.types import RasterResultDescriptor, TimeInterval
from geoengine.raster import ge_type_to_np


# pylint: disable=too-many-instance-attributes
class RasterWorkflowRioWriter:
    &#39;&#39;&#39;
    A class to write raster data from a Geo Engine raster workflow to a GDAL dataset.
    It creates a new dataset for each time interval and writes the tiles to the dataset.
    Multiple bands are supported and the bands are written to the dataset in the order of the result descriptor.
    &#39;&#39;&#39;
    current_dataset: Optional[rio.io.DatasetWriter] = None
    current_time: Optional[TimeInterval] = None
    dataset_geo_transform = None
    dataset_width = None
    dataset_height = None
    dataset_data_type = np.dtype
    print_info = False

    dataset_prefix = None
    workflow: Optional[Workflow] = None
    bands = None
    no_data_value = 0
    time_format = &#34;%Y-%m-%d_%H-%M-%S&#34;

    gdal_driver = &#34;GTiff&#34;
    rio_kwargs = {&#34;tiled&#34;: True, &#34;compress&#34;: &#34;DEFLATE&#34;, &#34;zlevel&#34;: 6}
    tile_size = 512

    # pylint: disable=too-many-arguments,too-many-positional-arguments
    def __init__(
        self,
        dataset_prefix,
        workflow: Workflow,
        no_data_value=0,
        data_type=None,
        print_info=False,
        rio_kwargs=None
    ):
        &#39;&#39;&#39; Create a new RasterWorkflowGdalWriter instance.&#39;&#39;&#39;
        self.dataset_prefix = dataset_prefix
        self.workflow = workflow
        self.no_data_value = no_data_value
        self.print_info = print_info

        ras_res = cast(RasterResultDescriptor, self.workflow.get_result_descriptor())
        dt = ge_type_to_np(ras_res.data_type)
        self.dataset_data_type = dt if data_type is None else data_type
        self.bands = ras_res.bands
        if rio_kwargs:
            for (key, value) in rio_kwargs.items():
                self.rio_kwargs[key] = value

    def close_current_dataset(self):
        &#39;&#39;&#39; Close the current dataset &#39;&#39;&#39;
        if self.current_dataset:
            del self.current_dataset
            self.current_dataset = None

    # pylint: disable=too-many-locals, too-many-statements
    def create_tiling_geo_transform_width_height(self, query: QueryRectangle):
        &#39;&#39;&#39; Create the tiling geo transform, width and height for the current query.&#39;&#39;&#39;

        ul_x = query.spatial_bounds.xmin
        ul_y = query.spatial_bounds.ymax
        lr_x = query.spatial_bounds.xmax
        lr_y = query.spatial_bounds.ymin
        res_x = query.spatial_resolution.x_resolution
        res_y = query.spatial_resolution.y_resolution * -1  # honor the fact that the y axis is flipped

        assert res_y &lt; 0, &#34;The y resolution must be negative&#34;

        assert ul_x &lt; lr_x, &#34;The upper left x coordinate must be smaller than the lower right x coordinate&#34;
        assert ul_y &gt; lr_y, &#34;The upper left y coordinate must be greater than the lower right y coordinate&#34;

        ul_pixel_x = ul_x / res_x  # we can assume that the global origin is 0,0
        ul_pixel_y = ul_y / res_y
        lr_pixel_x = lr_x / res_x
        lr_pixel_y = lr_y / res_y

        assert ul_pixel_x &lt; lr_pixel_x, &#34;The upper left pixel x must be smaller than the lower right pixel x&#34;
        assert ul_pixel_y &lt; lr_pixel_y, &#34;The upper left pixel y must be smaller than the lower right pixel y&#34;

        tiling_ul_pixel_x = (ul_pixel_x // self.tile_size) * self.tile_size
        if ul_pixel_x % self.tile_size != 0:
            tiling_ul_pixel_x = ((ul_pixel_x // self.tile_size) - 1) * self.tile_size

        tiling_ul_pixel_y = (ul_pixel_y // self.tile_size) * self.tile_size
        if ul_pixel_y % self.tile_size != 0:
            tiling_ul_pixel_y = ((ul_pixel_y // self.tile_size) - 1) * self.tile_size

        assert tiling_ul_pixel_x &lt;= ul_pixel_x, &#34;Tiling upper left x pixel must be smaller than upper left x coordinate&#34;
        assert tiling_ul_pixel_y &lt;= ul_pixel_y, &#34;Tiling upper left y pixel must be smaller than upper left y coordinate&#34;

        width = int((lr_pixel_x - tiling_ul_pixel_x))
        if width % self.tile_size != 0:
            width = int((width // self.tile_size + 1) * self.tile_size)
        assert width &gt; 0, &#34;The width must be greater than 0&#34;

        height = int((lr_pixel_y - tiling_ul_pixel_y))
        if height % self.tile_size != 0:
            height = int((height // self.tile_size + 1) * self.tile_size)
        assert height &gt; 0, &#34;The height must be greater than 0&#34;

        assert width % self.tile_size == 0, &#34;The width must be a multiple of the tile size&#34;
        assert height % self.tile_size == 0, &#34;The height must be a multiple of the tile size&#34;

        tiling_ul_x_coord = tiling_ul_pixel_x * res_x
        tiling_ul_y_coord = tiling_ul_pixel_y * res_y
        assert tiling_ul_x_coord &lt;= ul_x, &#34;Tiling upper left x coordinate must be smaller than upper left x coordinate&#34;
        assert tiling_ul_y_coord &gt;= ul_y, &#34;Tiling upper left y coordinate must be greater than upper left y coordinate&#34;

        geo_transform = [tiling_ul_x_coord, res_x, 0., tiling_ul_y_coord, 0., res_y]

        if self.dataset_geo_transform is None:
            self.dataset_geo_transform = geo_transform
        else:
            assert self.dataset_geo_transform == geo_transform, &#34;Can not change the geo transform of the dataset&#34;

        if self.dataset_width is None:
            self.dataset_width = width
        else:
            assert self.dataset_width == width, &#34;The width of the current dataset does not match the new one&#34;

        if self.dataset_height is None:
            self.dataset_height = height
        else:
            assert self.dataset_height == height, &#34;The height of the current dataset does not match the new one&#34;

    def __create_new_dataset(self, query: QueryRectangle):
        &#39;&#39;&#39; Create a new dataset for the current query.&#39;&#39;&#39;
        assert self.current_time is not None, &#34;The current time must be set&#34;
        time_formated_start = self.current_time.start.astype(datetime).strftime(self.time_format)
        width = self.dataset_width
        height = self.dataset_height
        geo_transform = self.dataset_geo_transform
        assert geo_transform is not None
        affine_transform = rio.Affine.from_gdal(
            geo_transform[0], geo_transform[1], geo_transform[2], geo_transform[3], geo_transform[4], geo_transform[5]
        )
        if self.print_info:
            print(f&#34;Creating dataset {self.dataset_prefix}{time_formated_start}.tif&#34;
                  f&#34; with width {width}, height {height}, geo_transform {geo_transform}&#34;
                  f&#34; rio kwargs: {self.rio_kwargs}&#34;
                  )
        assert self.bands is not None, &#34;The bands must be set&#34;
        number_of_bands = len(self.bands)
        dataset_data_type = self.dataset_data_type
        file_path = f&#34;{self.dataset_prefix}{time_formated_start}.tif&#34;
        rio_dataset = rio.open(
            file_path,
            &#39;w&#39;,
            driver=self.gdal_driver,
            width=width,
            height=height,
            count=number_of_bands,
            crs=query.srs,
            transform=affine_transform,
            dtype=dataset_data_type,
            nodata=self.no_data_value,
            **self.rio_kwargs
        )

        for i, b in enumerate(self.bands, start=1):
            b_n = b.name
            b_m = str(b.measurement)
            rio_dataset.update_tags(i, band_name=b_n, band_measurement=b_m)

        self.current_dataset = rio_dataset

    async def query_and_write(self, query: QueryRectangle, skip_empty_times=True):
        &#39;&#39;&#39;
        Query the raster workflow and write the resulting tiles to a GDAL dataset per timeslice.

        :param query: The QueryRectangle to write to GDAL dataset(s)
        :param skip_empty_times: Skip timeslices where all pixels are empty/nodata
        &#39;&#39;&#39;

        self.create_tiling_geo_transform_width_height(query)

        assert self.bands is not None, &#34;The bands must be set&#34;
        bands = list(range(0, len(self.bands)))

        assert self.workflow is not None, &#34;The workflow must be set&#34;
        try:
            async for tile in self.workflow.raster_stream(query, bands=bands):
                if self.current_time != tile.time:
                    self.close_current_dataset()
                    self.current_time = tile.time

                if tile.is_empty() and skip_empty_times:
                    continue

                if self.current_dataset is None:
                    self.__create_new_dataset(query)

                assert self.current_time == tile.time, &#34;The time of the current dataset does not match the tile&#34;
                assert self.dataset_geo_transform is not None, &#34;The geo transform must be set&#34;

                tile_ul_x = int(
                    (tile.geo_transform.x_min - self.dataset_geo_transform[0]) / self.dataset_geo_transform[1]
                )
                tile_ul_y = int(
                    (tile.geo_transform.y_max - self.dataset_geo_transform[3]) / self.dataset_geo_transform[5]
                )

                band_index = tile.band + 1
                data = tile.to_numpy_data_array(self.no_data_value)

                assert self.tile_size == tile.size_x == tile.size_y, &#34;Tile size does not match the expected size&#34;
                window = rio.windows.Window(tile_ul_x, tile_ul_y, tile.size_x, tile.size_y)
                assert self.current_dataset is not None, &#34;Dataset must be open.&#34;
                self.current_dataset.write(data, window=window, indexes=band_index)
        except Exception as inner_e:
            raise RuntimeError(f&#34;Tile at {tile.spatial_partition().as_bbox_str()} with {tile.time}&#34;) from inner_e

        finally:
            self.close_current_dataset()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter"><code class="flex name class">
<span>class <span class="ident">RasterWorkflowRioWriter</span></span>
<span>(</span><span>dataset_prefix, workflow: <a title="geoengine.workflow.Workflow" href="workflow.html#geoengine.workflow.Workflow">Workflow</a>, no_data_value=0, data_type=None, print_info=False, rio_kwargs=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A class to write raster data from a Geo Engine raster workflow to a GDAL dataset.
It creates a new dataset for each time interval and writes the tiles to the dataset.
Multiple bands are supported and the bands are written to the dataset in the order of the result descriptor.</p>
<p>Create a new RasterWorkflowGdalWriter instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RasterWorkflowRioWriter:
    &#39;&#39;&#39;
    A class to write raster data from a Geo Engine raster workflow to a GDAL dataset.
    It creates a new dataset for each time interval and writes the tiles to the dataset.
    Multiple bands are supported and the bands are written to the dataset in the order of the result descriptor.
    &#39;&#39;&#39;
    current_dataset: Optional[rio.io.DatasetWriter] = None
    current_time: Optional[TimeInterval] = None
    dataset_geo_transform = None
    dataset_width = None
    dataset_height = None
    dataset_data_type = np.dtype
    print_info = False

    dataset_prefix = None
    workflow: Optional[Workflow] = None
    bands = None
    no_data_value = 0
    time_format = &#34;%Y-%m-%d_%H-%M-%S&#34;

    gdal_driver = &#34;GTiff&#34;
    rio_kwargs = {&#34;tiled&#34;: True, &#34;compress&#34;: &#34;DEFLATE&#34;, &#34;zlevel&#34;: 6}
    tile_size = 512

    # pylint: disable=too-many-arguments,too-many-positional-arguments
    def __init__(
        self,
        dataset_prefix,
        workflow: Workflow,
        no_data_value=0,
        data_type=None,
        print_info=False,
        rio_kwargs=None
    ):
        &#39;&#39;&#39; Create a new RasterWorkflowGdalWriter instance.&#39;&#39;&#39;
        self.dataset_prefix = dataset_prefix
        self.workflow = workflow
        self.no_data_value = no_data_value
        self.print_info = print_info

        ras_res = cast(RasterResultDescriptor, self.workflow.get_result_descriptor())
        dt = ge_type_to_np(ras_res.data_type)
        self.dataset_data_type = dt if data_type is None else data_type
        self.bands = ras_res.bands
        if rio_kwargs:
            for (key, value) in rio_kwargs.items():
                self.rio_kwargs[key] = value

    def close_current_dataset(self):
        &#39;&#39;&#39; Close the current dataset &#39;&#39;&#39;
        if self.current_dataset:
            del self.current_dataset
            self.current_dataset = None

    # pylint: disable=too-many-locals, too-many-statements
    def create_tiling_geo_transform_width_height(self, query: QueryRectangle):
        &#39;&#39;&#39; Create the tiling geo transform, width and height for the current query.&#39;&#39;&#39;

        ul_x = query.spatial_bounds.xmin
        ul_y = query.spatial_bounds.ymax
        lr_x = query.spatial_bounds.xmax
        lr_y = query.spatial_bounds.ymin
        res_x = query.spatial_resolution.x_resolution
        res_y = query.spatial_resolution.y_resolution * -1  # honor the fact that the y axis is flipped

        assert res_y &lt; 0, &#34;The y resolution must be negative&#34;

        assert ul_x &lt; lr_x, &#34;The upper left x coordinate must be smaller than the lower right x coordinate&#34;
        assert ul_y &gt; lr_y, &#34;The upper left y coordinate must be greater than the lower right y coordinate&#34;

        ul_pixel_x = ul_x / res_x  # we can assume that the global origin is 0,0
        ul_pixel_y = ul_y / res_y
        lr_pixel_x = lr_x / res_x
        lr_pixel_y = lr_y / res_y

        assert ul_pixel_x &lt; lr_pixel_x, &#34;The upper left pixel x must be smaller than the lower right pixel x&#34;
        assert ul_pixel_y &lt; lr_pixel_y, &#34;The upper left pixel y must be smaller than the lower right pixel y&#34;

        tiling_ul_pixel_x = (ul_pixel_x // self.tile_size) * self.tile_size
        if ul_pixel_x % self.tile_size != 0:
            tiling_ul_pixel_x = ((ul_pixel_x // self.tile_size) - 1) * self.tile_size

        tiling_ul_pixel_y = (ul_pixel_y // self.tile_size) * self.tile_size
        if ul_pixel_y % self.tile_size != 0:
            tiling_ul_pixel_y = ((ul_pixel_y // self.tile_size) - 1) * self.tile_size

        assert tiling_ul_pixel_x &lt;= ul_pixel_x, &#34;Tiling upper left x pixel must be smaller than upper left x coordinate&#34;
        assert tiling_ul_pixel_y &lt;= ul_pixel_y, &#34;Tiling upper left y pixel must be smaller than upper left y coordinate&#34;

        width = int((lr_pixel_x - tiling_ul_pixel_x))
        if width % self.tile_size != 0:
            width = int((width // self.tile_size + 1) * self.tile_size)
        assert width &gt; 0, &#34;The width must be greater than 0&#34;

        height = int((lr_pixel_y - tiling_ul_pixel_y))
        if height % self.tile_size != 0:
            height = int((height // self.tile_size + 1) * self.tile_size)
        assert height &gt; 0, &#34;The height must be greater than 0&#34;

        assert width % self.tile_size == 0, &#34;The width must be a multiple of the tile size&#34;
        assert height % self.tile_size == 0, &#34;The height must be a multiple of the tile size&#34;

        tiling_ul_x_coord = tiling_ul_pixel_x * res_x
        tiling_ul_y_coord = tiling_ul_pixel_y * res_y
        assert tiling_ul_x_coord &lt;= ul_x, &#34;Tiling upper left x coordinate must be smaller than upper left x coordinate&#34;
        assert tiling_ul_y_coord &gt;= ul_y, &#34;Tiling upper left y coordinate must be greater than upper left y coordinate&#34;

        geo_transform = [tiling_ul_x_coord, res_x, 0., tiling_ul_y_coord, 0., res_y]

        if self.dataset_geo_transform is None:
            self.dataset_geo_transform = geo_transform
        else:
            assert self.dataset_geo_transform == geo_transform, &#34;Can not change the geo transform of the dataset&#34;

        if self.dataset_width is None:
            self.dataset_width = width
        else:
            assert self.dataset_width == width, &#34;The width of the current dataset does not match the new one&#34;

        if self.dataset_height is None:
            self.dataset_height = height
        else:
            assert self.dataset_height == height, &#34;The height of the current dataset does not match the new one&#34;

    def __create_new_dataset(self, query: QueryRectangle):
        &#39;&#39;&#39; Create a new dataset for the current query.&#39;&#39;&#39;
        assert self.current_time is not None, &#34;The current time must be set&#34;
        time_formated_start = self.current_time.start.astype(datetime).strftime(self.time_format)
        width = self.dataset_width
        height = self.dataset_height
        geo_transform = self.dataset_geo_transform
        assert geo_transform is not None
        affine_transform = rio.Affine.from_gdal(
            geo_transform[0], geo_transform[1], geo_transform[2], geo_transform[3], geo_transform[4], geo_transform[5]
        )
        if self.print_info:
            print(f&#34;Creating dataset {self.dataset_prefix}{time_formated_start}.tif&#34;
                  f&#34; with width {width}, height {height}, geo_transform {geo_transform}&#34;
                  f&#34; rio kwargs: {self.rio_kwargs}&#34;
                  )
        assert self.bands is not None, &#34;The bands must be set&#34;
        number_of_bands = len(self.bands)
        dataset_data_type = self.dataset_data_type
        file_path = f&#34;{self.dataset_prefix}{time_formated_start}.tif&#34;
        rio_dataset = rio.open(
            file_path,
            &#39;w&#39;,
            driver=self.gdal_driver,
            width=width,
            height=height,
            count=number_of_bands,
            crs=query.srs,
            transform=affine_transform,
            dtype=dataset_data_type,
            nodata=self.no_data_value,
            **self.rio_kwargs
        )

        for i, b in enumerate(self.bands, start=1):
            b_n = b.name
            b_m = str(b.measurement)
            rio_dataset.update_tags(i, band_name=b_n, band_measurement=b_m)

        self.current_dataset = rio_dataset

    async def query_and_write(self, query: QueryRectangle, skip_empty_times=True):
        &#39;&#39;&#39;
        Query the raster workflow and write the resulting tiles to a GDAL dataset per timeslice.

        :param query: The QueryRectangle to write to GDAL dataset(s)
        :param skip_empty_times: Skip timeslices where all pixels are empty/nodata
        &#39;&#39;&#39;

        self.create_tiling_geo_transform_width_height(query)

        assert self.bands is not None, &#34;The bands must be set&#34;
        bands = list(range(0, len(self.bands)))

        assert self.workflow is not None, &#34;The workflow must be set&#34;
        try:
            async for tile in self.workflow.raster_stream(query, bands=bands):
                if self.current_time != tile.time:
                    self.close_current_dataset()
                    self.current_time = tile.time

                if tile.is_empty() and skip_empty_times:
                    continue

                if self.current_dataset is None:
                    self.__create_new_dataset(query)

                assert self.current_time == tile.time, &#34;The time of the current dataset does not match the tile&#34;
                assert self.dataset_geo_transform is not None, &#34;The geo transform must be set&#34;

                tile_ul_x = int(
                    (tile.geo_transform.x_min - self.dataset_geo_transform[0]) / self.dataset_geo_transform[1]
                )
                tile_ul_y = int(
                    (tile.geo_transform.y_max - self.dataset_geo_transform[3]) / self.dataset_geo_transform[5]
                )

                band_index = tile.band + 1
                data = tile.to_numpy_data_array(self.no_data_value)

                assert self.tile_size == tile.size_x == tile.size_y, &#34;Tile size does not match the expected size&#34;
                window = rio.windows.Window(tile_ul_x, tile_ul_y, tile.size_x, tile.size_y)
                assert self.current_dataset is not None, &#34;Dataset must be open.&#34;
                self.current_dataset.write(data, window=window, indexes=band_index)
        except Exception as inner_e:
            raise RuntimeError(f&#34;Tile at {tile.spatial_partition().as_bbox_str()} with {tile.time}&#34;) from inner_e

        finally:
            self.close_current_dataset()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.bands"><code class="name">var <span class="ident">bands</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.current_dataset"><code class="name">var <span class="ident">current_dataset</span> : Optional[rasterio.io.DatasetWriter]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.current_time"><code class="name">var <span class="ident">current_time</span> : Optional[<a title="geoengine.types.TimeInterval" href="types.html#geoengine.types.TimeInterval">TimeInterval</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_data_type"><code class="name">var <span class="ident">dataset_data_type</span></code></dt>
<dd>
<div class="desc"><p>dtype(dtype, align=False, copy=False, [metadata])</p>
<p>Create a data type object.</p>
<p>A numpy array is homogeneous, and contains elements described by a
dtype object. A dtype object can be constructed from different
combinations of fundamental numeric types.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>dtype</code></strong></dt>
<dd>Object to be converted to a data type object.</dd>
<dt><strong><code>align</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Add padding to the fields to match what a C compiler would output
for a similar C-struct. Can be <code>True</code> only if <code>obj</code> is a dictionary
or a comma-separated string. If a struct dtype is being created,
this also sets a sticky alignment flag <code>isalignedstruct</code>.</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Make a new copy of the data-type object. If <code>False</code>, the result
may just be a reference to a built-in data-type object.</dd>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>An optional dictionary with dtype metadata.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<p><code>result_type</code></p>
<h2 id="examples">Examples</h2>
<p>Using array-scalar type:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; np.dtype(np.int16)
dtype('int16')
</code></pre>
<p>Structured type, one field name 'f1', containing int16:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; np.dtype([('f1', np.int16)])
dtype([('f1', '&lt;i2')])
</code></pre>
<p>Structured type, one field named 'f1', in itself containing a structured
type with one field:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; np.dtype([('f1', [('f1', np.int16)])])
dtype([('f1', [('f1', '&lt;i2')])])
</code></pre>
<p>Structured type, two fields: the first field contains an unsigned int, the
second an int32:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; np.dtype([('f1', np.uint64), ('f2', np.int32)])
dtype([('f1', '&lt;u8'), ('f2', '&lt;i4')])
</code></pre>
<p>Using array-protocol type strings:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; np.dtype([('a','f8'),('b','S10')])
dtype([('a', '&lt;f8'), ('b', 'S10')])
</code></pre>
<p>Using comma-separated field formats.
The shape is (2,3):</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; np.dtype(&quot;i4, (2,3)f8&quot;)
dtype([('f0', '&lt;i4'), ('f1', '&lt;f8', (2, 3))])
</code></pre>
<p>Using tuples.
<code>int</code> is a fixed type, 3 the field's shape.
<code>void</code>
is a flexible type, here of size 10:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; np.dtype([('hello',(np.int64,3)),('world',np.void,10)])
dtype([('hello', '&lt;i8', (3,)), ('world', 'V10')])
</code></pre>
<p>Subdivide <code>int16</code> into 2 <code>int8</code>'s, called x and y.
0 and 1 are
the offsets in bytes:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; np.dtype((np.int16, {'x':(np.int8,0), 'y':(np.int8,1)}))
dtype((numpy.int16, [('x', 'i1'), ('y', 'i1')]))
</code></pre>
<p>Using dictionaries.
Two fields named 'gender' and 'age':</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; np.dtype({'names':['gender','age'], 'formats':['S1',np.uint8]})
dtype([('gender', 'S1'), ('age', 'u1')])
</code></pre>
<p>Offsets in bytes, here 0 and 25:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; np.dtype({'surname':('S25',0),'age':(np.uint8,25)})
dtype([('surname', 'S25'), ('age', 'u1')])
</code></pre></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_geo_transform"><code class="name">var <span class="ident">dataset_geo_transform</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_height"><code class="name">var <span class="ident">dataset_height</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_prefix"><code class="name">var <span class="ident">dataset_prefix</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_width"><code class="name">var <span class="ident">dataset_width</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.gdal_driver"><code class="name">var <span class="ident">gdal_driver</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.no_data_value"><code class="name">var <span class="ident">no_data_value</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.print_info"><code class="name">var <span class="ident">print_info</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.rio_kwargs"><code class="name">var <span class="ident">rio_kwargs</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.tile_size"><code class="name">var <span class="ident">tile_size</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.time_format"><code class="name">var <span class="ident">time_format</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.workflow"><code class="name">var <span class="ident">workflow</span> : Optional[<a title="geoengine.workflow.Workflow" href="workflow.html#geoengine.workflow.Workflow">Workflow</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.close_current_dataset"><code class="name flex">
<span>def <span class="ident">close_current_dataset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Close the current dataset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_current_dataset(self):
    &#39;&#39;&#39; Close the current dataset &#39;&#39;&#39;
    if self.current_dataset:
        del self.current_dataset
        self.current_dataset = None</code></pre>
</details>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.create_tiling_geo_transform_width_height"><code class="name flex">
<span>def <span class="ident">create_tiling_geo_transform_width_height</span></span>(<span>self, query: <a title="geoengine.types.QueryRectangle" href="types.html#geoengine.types.QueryRectangle">QueryRectangle</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create the tiling geo transform, width and height for the current query.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_tiling_geo_transform_width_height(self, query: QueryRectangle):
    &#39;&#39;&#39; Create the tiling geo transform, width and height for the current query.&#39;&#39;&#39;

    ul_x = query.spatial_bounds.xmin
    ul_y = query.spatial_bounds.ymax
    lr_x = query.spatial_bounds.xmax
    lr_y = query.spatial_bounds.ymin
    res_x = query.spatial_resolution.x_resolution
    res_y = query.spatial_resolution.y_resolution * -1  # honor the fact that the y axis is flipped

    assert res_y &lt; 0, &#34;The y resolution must be negative&#34;

    assert ul_x &lt; lr_x, &#34;The upper left x coordinate must be smaller than the lower right x coordinate&#34;
    assert ul_y &gt; lr_y, &#34;The upper left y coordinate must be greater than the lower right y coordinate&#34;

    ul_pixel_x = ul_x / res_x  # we can assume that the global origin is 0,0
    ul_pixel_y = ul_y / res_y
    lr_pixel_x = lr_x / res_x
    lr_pixel_y = lr_y / res_y

    assert ul_pixel_x &lt; lr_pixel_x, &#34;The upper left pixel x must be smaller than the lower right pixel x&#34;
    assert ul_pixel_y &lt; lr_pixel_y, &#34;The upper left pixel y must be smaller than the lower right pixel y&#34;

    tiling_ul_pixel_x = (ul_pixel_x // self.tile_size) * self.tile_size
    if ul_pixel_x % self.tile_size != 0:
        tiling_ul_pixel_x = ((ul_pixel_x // self.tile_size) - 1) * self.tile_size

    tiling_ul_pixel_y = (ul_pixel_y // self.tile_size) * self.tile_size
    if ul_pixel_y % self.tile_size != 0:
        tiling_ul_pixel_y = ((ul_pixel_y // self.tile_size) - 1) * self.tile_size

    assert tiling_ul_pixel_x &lt;= ul_pixel_x, &#34;Tiling upper left x pixel must be smaller than upper left x coordinate&#34;
    assert tiling_ul_pixel_y &lt;= ul_pixel_y, &#34;Tiling upper left y pixel must be smaller than upper left y coordinate&#34;

    width = int((lr_pixel_x - tiling_ul_pixel_x))
    if width % self.tile_size != 0:
        width = int((width // self.tile_size + 1) * self.tile_size)
    assert width &gt; 0, &#34;The width must be greater than 0&#34;

    height = int((lr_pixel_y - tiling_ul_pixel_y))
    if height % self.tile_size != 0:
        height = int((height // self.tile_size + 1) * self.tile_size)
    assert height &gt; 0, &#34;The height must be greater than 0&#34;

    assert width % self.tile_size == 0, &#34;The width must be a multiple of the tile size&#34;
    assert height % self.tile_size == 0, &#34;The height must be a multiple of the tile size&#34;

    tiling_ul_x_coord = tiling_ul_pixel_x * res_x
    tiling_ul_y_coord = tiling_ul_pixel_y * res_y
    assert tiling_ul_x_coord &lt;= ul_x, &#34;Tiling upper left x coordinate must be smaller than upper left x coordinate&#34;
    assert tiling_ul_y_coord &gt;= ul_y, &#34;Tiling upper left y coordinate must be greater than upper left y coordinate&#34;

    geo_transform = [tiling_ul_x_coord, res_x, 0., tiling_ul_y_coord, 0., res_y]

    if self.dataset_geo_transform is None:
        self.dataset_geo_transform = geo_transform
    else:
        assert self.dataset_geo_transform == geo_transform, &#34;Can not change the geo transform of the dataset&#34;

    if self.dataset_width is None:
        self.dataset_width = width
    else:
        assert self.dataset_width == width, &#34;The width of the current dataset does not match the new one&#34;

    if self.dataset_height is None:
        self.dataset_height = height
    else:
        assert self.dataset_height == height, &#34;The height of the current dataset does not match the new one&#34;</code></pre>
</details>
</dd>
<dt id="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.query_and_write"><code class="name flex">
<span>async def <span class="ident">query_and_write</span></span>(<span>self, query: <a title="geoengine.types.QueryRectangle" href="types.html#geoengine.types.QueryRectangle">QueryRectangle</a>, skip_empty_times=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Query the raster workflow and write the resulting tiles to a GDAL dataset per timeslice.</p>
<p>:param query: The QueryRectangle to write to GDAL dataset(s)
:param skip_empty_times: Skip timeslices where all pixels are empty/nodata</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def query_and_write(self, query: QueryRectangle, skip_empty_times=True):
    &#39;&#39;&#39;
    Query the raster workflow and write the resulting tiles to a GDAL dataset per timeslice.

    :param query: The QueryRectangle to write to GDAL dataset(s)
    :param skip_empty_times: Skip timeslices where all pixels are empty/nodata
    &#39;&#39;&#39;

    self.create_tiling_geo_transform_width_height(query)

    assert self.bands is not None, &#34;The bands must be set&#34;
    bands = list(range(0, len(self.bands)))

    assert self.workflow is not None, &#34;The workflow must be set&#34;
    try:
        async for tile in self.workflow.raster_stream(query, bands=bands):
            if self.current_time != tile.time:
                self.close_current_dataset()
                self.current_time = tile.time

            if tile.is_empty() and skip_empty_times:
                continue

            if self.current_dataset is None:
                self.__create_new_dataset(query)

            assert self.current_time == tile.time, &#34;The time of the current dataset does not match the tile&#34;
            assert self.dataset_geo_transform is not None, &#34;The geo transform must be set&#34;

            tile_ul_x = int(
                (tile.geo_transform.x_min - self.dataset_geo_transform[0]) / self.dataset_geo_transform[1]
            )
            tile_ul_y = int(
                (tile.geo_transform.y_max - self.dataset_geo_transform[3]) / self.dataset_geo_transform[5]
            )

            band_index = tile.band + 1
            data = tile.to_numpy_data_array(self.no_data_value)

            assert self.tile_size == tile.size_x == tile.size_y, &#34;Tile size does not match the expected size&#34;
            window = rio.windows.Window(tile_ul_x, tile_ul_y, tile.size_x, tile.size_y)
            assert self.current_dataset is not None, &#34;Dataset must be open.&#34;
            self.current_dataset.write(data, window=window, indexes=band_index)
    except Exception as inner_e:
        raise RuntimeError(f&#34;Tile at {tile.spatial_partition().as_bbox_str()} with {tile.time}&#34;) from inner_e

    finally:
        self.close_current_dataset()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geoengine" href="index.html">geoengine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter">RasterWorkflowRioWriter</a></code></h4>
<ul class="">
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.bands" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.bands">bands</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.close_current_dataset" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.close_current_dataset">close_current_dataset</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.create_tiling_geo_transform_width_height" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.create_tiling_geo_transform_width_height">create_tiling_geo_transform_width_height</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.current_dataset" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.current_dataset">current_dataset</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.current_time" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.current_time">current_time</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_data_type" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_data_type">dataset_data_type</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_geo_transform" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_geo_transform">dataset_geo_transform</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_height" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_height">dataset_height</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_prefix" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_prefix">dataset_prefix</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_width" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.dataset_width">dataset_width</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.gdal_driver" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.gdal_driver">gdal_driver</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.no_data_value" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.no_data_value">no_data_value</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.print_info" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.print_info">print_info</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.query_and_write" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.query_and_write">query_and_write</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.rio_kwargs" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.rio_kwargs">rio_kwargs</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.tile_size" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.tile_size">tile_size</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.time_format" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.time_format">time_format</a></code></li>
<li><code><a title="geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.workflow" href="#geoengine.raster_workflow_rio_writer.RasterWorkflowRioWriter.workflow">workflow</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>