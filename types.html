<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>geoengine.types API documentation</title>
<meta name="description" content="Different type mappings of geo engine types" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geoengine.types</code></h1>
</header>
<section id="section-intro">
<p>Different type mappings of geo engine types</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># pylint: disable=too-many-lines

&#39;&#39;&#39;
Different type mappings of geo engine types
&#39;&#39;&#39;

from __future__ import annotations
from abc import abstractmethod
from datetime import datetime, timezone
from uuid import UUID
from enum import Enum
from typing import Dict, Optional, Tuple, Union, cast, List, Literal
from attr import dataclass
from geoengine.colorizer import Colorizer
from geoengine import api
from geoengine.error import GeoEngineException, InputException, TypeException

DEFAULT_ISO_TIME_FORMAT = &#34;%Y-%m-%dT%H:%M:%S.%f%z&#34;


class SpatialBounds:
    &#39;&#39;&#39;A spatial bounds object&#39;&#39;&#39;
    xmin: float
    ymin: float
    xmax: float
    ymax: float

    def __init__(self, xmin: float, ymin: float, xmax: float, ymax: float) -&gt; None:
        &#39;&#39;&#39;Initialize a new `SpatialBounds` object&#39;&#39;&#39;
        if (xmin &gt; xmax) or (ymin &gt; ymax):
            raise InputException(&#34;Bbox: Malformed since min must be &lt;= max&#34;)

        self.xmin = xmin
        self.ymin = ymin
        self.xmax = xmax
        self.ymax = ymax

    def as_bbox_str(self, y_axis_first=False) -&gt; str:
        &#39;&#39;&#39;
        A comma-separated string representation of the spatial bounds with OGC axis ordering
        &#39;&#39;&#39;
        bbox_tuple = self.as_bbox_tuple(y_axis_first=y_axis_first)
        return f&#39;{bbox_tuple[0]},{bbox_tuple[1]},{bbox_tuple[2]},{bbox_tuple[3]}&#39;

    def as_bbox_tuple(self, y_axis_first=False) -&gt; Tuple[float, float, float, float]:
        &#39;&#39;&#39;
        Return the bbox with OGC axis ordering of the srs
        &#39;&#39;&#39;

        if y_axis_first:
            return (self.ymin, self.xmin, self.ymax, self.xmax)

        return (self.xmin, self.ymin, self.xmax, self.ymax)

    def x_axis_size(self) -&gt; float:
        &#39;&#39;&#39;The size of the x axis&#39;&#39;&#39;
        return self.xmax - self.xmin

    def y_axis_size(self) -&gt; float:
        &#39;&#39;&#39;The size of the y axis&#39;&#39;&#39;
        return self.ymax - self.ymin


class BoundingBox2D(SpatialBounds):
    &#39;&#39;&#39;&#39;A 2D bounding box.&#39;&#39;&#39;

    def to_api_dict(self) -&gt; api.BoundingBox2D:
        return api.BoundingBox2D({
            &#39;lowerLeftCoordinate&#39;: api.Coordinate2D({
                &#34;x&#34;: self.xmin,
                &#34;y&#34;: self.ymin,
            }),
            &#39;upperRightCoordinate&#39;: api.Coordinate2D({
                &#34;x&#34;: self.xmax,
                &#34;y&#34;: self.ymax,
            }),
        })

    @staticmethod
    def from_response(response: api.BoundingBox2D) -&gt; BoundingBox2D:
        &#39;&#39;&#39;create a `BoundingBox2D` from an API response&#39;&#39;&#39;
        if &#39;lowerLeftCoordinate&#39; not in response or &#39;upperRightCoordinate&#39; not in response:
            raise TypeException(&#39;BoundingBox2D must have lowerLeftCoordinate and upperRightCoordinate&#39;)

        lower_left = response[&#39;lowerLeftCoordinate&#39;]
        upper_right = response[&#39;upperRightCoordinate&#39;]

        return BoundingBox2D(
            lower_left[&#39;x&#39;],
            lower_left[&#39;y&#39;],
            upper_right[&#39;x&#39;],
            upper_right[&#39;y&#39;],
        )

    def __repr__(self) -&gt; str:
        return f&#39;BoundingBox2D(xmin={self.xmin}, ymin={self.ymin}, xmax={self.xmax}, ymax={self.ymax})&#39;


class SpatialPartition2D(SpatialBounds):
    &#39;&#39;&#39;A 2D spatial partition.&#39;&#39;&#39;

    @staticmethod
    def from_response(response: api.SpatialPartition2D) -&gt; SpatialPartition2D:
        &#39;&#39;&#39;create a `SpatialPartition2D` from an API response&#39;&#39;&#39;
        if &#39;upperLeftCoordinate&#39; not in response or &#39;lowerRightCoordinate&#39; not in response:
            raise TypeException(&#39;SpatialPartition2D must have upperLeftCoordinate and lowerRightCoordinate&#39;)

        upper_left = response[&#39;upperLeftCoordinate&#39;]
        lower_right = response[&#39;lowerRightCoordinate&#39;]

        return SpatialPartition2D(
            upper_left[&#39;x&#39;],
            lower_right[&#39;y&#39;],
            lower_right[&#39;x&#39;],
            upper_left[&#39;y&#39;],

        )

    def to_api_dict(self) -&gt; api.SpatialPartition2D:
        return api.SpatialPartition2D({
            &#39;upperLeftCoordinate&#39;: api.Coordinate2D({
                &#34;x&#34;: self.xmin,
                &#34;y&#34;: self.ymax,
            }),
            &#39;lowerRightCoordinate&#39;: api.Coordinate2D({
                &#34;x&#34;: self.xmax,
                &#34;y&#34;: self.ymin,
            }),
        })

    def to_bounding_box(self) -&gt; BoundingBox2D:
        &#39;&#39;&#39;convert to a `BoundingBox2D`&#39;&#39;&#39;
        return BoundingBox2D(self.xmin, self.ymin, self.xmax, self.ymax)


class TimeInterval:
    &#39;&#39;&#39;&#39;A time interval.&#39;&#39;&#39;
    start: datetime
    end: Optional[datetime]

    def __init__(self, start: datetime, end: Optional[datetime] = None) -&gt; None:
        &#39;&#39;&#39;Initialize a new `TimeInterval` object&#39;&#39;&#39;

        if not isinstance(start, datetime) or not isinstance(end, (datetime, type(None))):
            raise InputException(&#34;`start` and `end` must be of type `datetime.datetime`&#34;)

        # We assume that a datetime without a timezone means UTC
        if start.tzinfo is None:
            start = start.replace(tzinfo=timezone.utc)
        if end is not None and end.tzinfo is None:
            end = end.replace(tzinfo=timezone.utc)

        # Check validity of time interval if an `end` exists
        if end is not None and start &gt; end:
            raise InputException(&#34;Time inverval: Start must be &lt;= End&#34;)

        self.start = start
        self.end = end

    def is_instant(self) -&gt; bool:
        return self.end is None

    def to_api_dict(self, as_millis=False) -&gt; api.TimeInterval:
        &#39;&#39;&#39;convert to a dict that can be used in the API&#39;&#39;&#39;
        if as_millis:
            return api.TimeInterval({
                &#39;start&#39;: int(self.start.timestamp() * 1000),
                &#39;end&#39;: int(self.end.timestamp() * 1000) if self.end is not None else None,
            })

        return api.TimeInterval({
            &#39;start&#39;: self.start.isoformat(timespec=&#39;milliseconds&#39;),
            &#39;end&#39;: self.end.isoformat(timespec=&#39;milliseconds&#39;) if self.end is not None else None,
        })

    @property
    def time_str(self) -&gt; str:
        &#39;&#39;&#39;
        Return the time instance or interval as a string representation
        &#39;&#39;&#39;
        if self.end is None or self.start == self.end:
            return self.start.isoformat(timespec=&#39;milliseconds&#39;)
        return self.start.isoformat(timespec=&#39;milliseconds&#39;) + &#39;/&#39; + self.end.isoformat(timespec=&#39;milliseconds&#39;)

    @staticmethod
    def from_response(response: api.TimeInterval) -&gt; TimeInterval:
        &#39;&#39;&#39;create a `TimeInterval` from an API response&#39;&#39;&#39;

        if &#39;start&#39; not in response:
            raise TypeException(&#39;TimeInterval must have a start&#39;)

        if isinstance(response[&#39;start&#39;], int):
            start = cast(int, response[&#39;start&#39;])
            end = cast(int, response[&#39;end&#39;]) if &#39;end&#39; in response and response[&#39;end&#39;] is not None else None

            return TimeInterval(
                datetime.fromtimestamp(start / 1000),
                datetime.fromtimestamp(end / 1000) if end is not None else None,
            )

        start_str = cast(str, response[&#39;start&#39;])
        end_str = cast(str, response[&#39;end&#39;]) if &#39;end&#39; in response and response[&#39;end&#39;] is not None else None

        return TimeInterval(
            datetime.fromisoformat(start_str),
            datetime.fromisoformat(end_str) if end_str is not None else None,
        )

    def __repr__(self) -&gt; str:
        return f&#34;TimeInterval(start={self.start}, end={self.end})&#34;


class SpatialResolution:
    &#39;&#39;&#39;&#39;A spatial resolution.&#39;&#39;&#39;
    x_resolution: float
    y_resolution: float

    def __init__(self, x_resolution: float, y_resolution: float) -&gt; None:
        &#39;&#39;&#39;Initialize a new `SpatialResolution` object&#39;&#39;&#39;
        if x_resolution &lt;= 0 or y_resolution &lt;= 0:
            raise InputException(&#34;Resolution: Must be positive&#34;)

        self.x_resolution = x_resolution
        self.y_resolution = y_resolution

    def to_api_dict(self) -&gt; api.SpatialResolution:
        return api.SpatialResolution({
            &#39;x&#39;: self.x_resolution,
            &#39;y&#39;: self.y_resolution,
        })

    @staticmethod
    def from_response(response: api.SpatialResolution) -&gt; SpatialResolution:
        &#39;&#39;&#39;create a `SpatialResolution` from an API response&#39;&#39;&#39;
        return SpatialResolution(x_resolution=response[&#39;x&#39;], y_resolution=response[&#39;y&#39;])

    def as_tuple(self) -&gt; Tuple[float, float]:
        return (self.x_resolution, self.y_resolution)

    def __str__(self) -&gt; str:
        return str(f&#39;{self.x_resolution},{self.y_resolution}&#39;)

    def __repr__(self) -&gt; str:
        return str(f&#39;SpatialResolution(x={self.x_resolution}, y={self.y_resolution})&#39;)


class QueryRectangle:
    &#39;&#39;&#39;
    A multi-dimensional query rectangle, consisting of spatial and temporal information.
    &#39;&#39;&#39;

    __spatial_bounds: BoundingBox2D
    __time_interval: TimeInterval
    __resolution: SpatialResolution
    __srs: str

    def __init__(self,
                 spatial_bounds: Union[BoundingBox2D, Tuple[float, float, float, float]],
                 time_interval: Union[TimeInterval, Tuple[datetime, Optional[datetime]]],
                 resolution: Union[SpatialResolution, Tuple[float, float]],
                 srs=&#39;EPSG:4326&#39;) -&gt; None:
        &#34;&#34;&#34;
        Initialize a new `QueryRectangle` object

        Parameters
        ----------
        spatial_bounds
            The spatial bounds of the query rectangle.
            Either a `BoundingBox2D` or a tuple of floats (xmin, ymin, xmax, ymax)
        time_interval
            The time interval of the query rectangle.
            Either a `TimeInterval` or a tuple of `datetime.datetime` objects (start, end)
        resolution
            The spatial resolution of the query rectangle.
            Either a `SpatialResolution` or a tuple of floats (x_resolution, y_resolution)
        &#34;&#34;&#34;

        if not isinstance(spatial_bounds, BoundingBox2D):
            spatial_bounds = BoundingBox2D(*spatial_bounds)
        if not isinstance(time_interval, TimeInterval):
            time_interval = TimeInterval(*time_interval)
        if not isinstance(resolution, SpatialResolution):
            resolution = SpatialResolution(*resolution)

        self.__spatial_bounds = spatial_bounds
        self.__time_interval = time_interval
        self.__resolution = resolution
        self.__srs = srs

    @property
    def bbox_str(self) -&gt; str:
        &#39;&#39;&#39;
        A comma-separated string representation of the spatial bounds
        &#39;&#39;&#39;
        return self.__spatial_bounds.as_bbox_str()

    @property
    def bbox_ogc_str(self) -&gt; str:
        &#39;&#39;&#39;
        A comma-separated string representation of the spatial bounds with OGC axis ordering
        &#39;&#39;&#39;
        y_axis_first = self.__srs == &#34;EPSG:4326&#34;
        return self.__spatial_bounds.as_bbox_str(y_axis_first=y_axis_first)

    @property
    def bbox_ogc(self) -&gt; Tuple[float, float, float, float]:
        &#39;&#39;&#39;
        Return the bbox with OGC axis ordering of the srs
        &#39;&#39;&#39;

        # TODO: properly handle axis order
        y_axis_first = self.__srs == &#34;EPSG:4326&#34;
        return self.__spatial_bounds.as_bbox_tuple(y_axis_first=y_axis_first)

    @property
    def resolution_ogc(self) -&gt; Tuple[float, float]:
        &#39;&#39;&#39;
        Return the resolution in OGC style
        &#39;&#39;&#39;
        # TODO: properly handle axis order
        res = self.__resolution

        # TODO: why is the y resolution in this case negative but not in all other cases?
        if self.__srs == &#34;EPSG:4326&#34;:
            return (-res.y_resolution, res.x_resolution)

        return res.as_tuple()

    @property
    def time(self) -&gt; TimeInterval:
        &#39;&#39;&#39;
        Return the time instance or interval
        &#39;&#39;&#39;
        return self.__time_interval

    @property
    def spatial_bounds(self) -&gt; BoundingBox2D:
        &#39;&#39;&#39;
        Return the spatial bounds
        &#39;&#39;&#39;
        return self.__spatial_bounds

    @property
    def spatial_resolution(self) -&gt; SpatialResolution:
        &#39;&#39;&#39;
        Return the spatial resolution
        &#39;&#39;&#39;
        return self.__resolution

    @property
    def time_str(self) -&gt; str:
        &#39;&#39;&#39;
        Return the time instance or interval as a string representation
        &#39;&#39;&#39;
        return self.time.time_str

    @property
    def srs(self) -&gt; str:
        &#39;&#39;&#39;
        Return the SRS string
        &#39;&#39;&#39;
        return self.__srs

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39; Return a string representation of the query rectangle.&#39;&#39;&#39;
        r = &#39;QueryRectangle( \n&#39;
        r += &#39;    &#39; + repr(self.__spatial_bounds) + &#39;\n&#39;
        r += &#39;    &#39; + repr(self.__time_interval) + &#39;\n&#39;
        r += &#39;    &#39; + repr(self.__resolution) + &#39;\n&#39;
        r += f&#39;    srs={self.__srs} \n&#39;
        r += &#39;)&#39;
        return r


class ResultDescriptor:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;
    Base class for result descriptors
    &#39;&#39;&#39;

    __spatial_reference: str
    __time_bounds: Optional[TimeInterval]
    __spatial_resolution: Optional[SpatialResolution]

    def __init__(
        self,
        spatial_reference: str,
        time_bounds: Optional[TimeInterval] = None,
        spatial_resolution: Optional[SpatialResolution] = None
    ) -&gt; None:
        &#39;&#39;&#39;Initialize a new `ResultDescriptor` object&#39;&#39;&#39;

        self.__spatial_reference = spatial_reference
        self.__time_bounds = time_bounds

        if spatial_resolution is None or isinstance(spatial_resolution, SpatialResolution):
            self.__spatial_resolution = spatial_resolution
        else:
            raise TypeException(&#39;Spatial resolution must be of type `SpatialResolution` or `None`&#39;)

    @staticmethod
    def from_response(response: api.ResultDescriptor) -&gt; ResultDescriptor:
        &#39;&#39;&#39;
        Parse a result descriptor from an http response
        &#39;&#39;&#39;

        if &#39;error&#39; in response:
            raise GeoEngineException(cast(api.GeoEngineExceptionResponse, response))

        if &#39;type&#39; not in response:
            raise TypeException(&#39;Response does not contain a `type` field&#39;)

        result_descriptor_type = response[&#39;type&#39;]

        if result_descriptor_type == &#39;raster&#39;:
            return RasterResultDescriptor.from_response_raster(cast(api.RasterResultDescriptor, response))
        if result_descriptor_type == &#39;vector&#39;:
            return VectorResultDescriptor.from_response_vector(cast(api.VectorResultDescriptor, response))
        if result_descriptor_type == &#39;plot&#39;:
            return PlotResultDescriptor.from_response_plot(cast(api.PlotResultDescriptor, response))

        raise TypeException(
            f&#39;Unknown `ResultDescriptor` type: {result_descriptor_type}&#39;)

    @classmethod
    def is_raster_result(cls) -&gt; bool:
        &#39;&#39;&#39;
        Return true if the result is of type raster
        &#39;&#39;&#39;
        return False

    @classmethod
    def is_vector_result(cls) -&gt; bool:
        &#39;&#39;&#39;
        Return true if the result is of type vector
        &#39;&#39;&#39;
        return False

    @classmethod
    def is_plot_result(cls) -&gt; bool:
        &#39;&#39;&#39;
        Return true if the result is of type plot
        &#39;&#39;&#39;

        return False

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;

        return self.__spatial_reference

    @property
    def time_bounds(self) -&gt; Optional[TimeInterval]:
        &#39;&#39;&#39;Return the time bounds&#39;&#39;&#39;

        return self.__time_bounds

    @property
    def spatial_resolution(self) -&gt; Optional[SpatialResolution]:
        &#39;&#39;&#39;Return the spatial resolution&#39;&#39;&#39;

        return self.__spatial_resolution

    @abstractmethod
    def to_api_dict(self) -&gt; api.ResultDescriptor:
        pass

    def __iter__(self):
        return iter(self.to_api_dict().items())


class VectorResultDescriptor(ResultDescriptor):
    &#39;&#39;&#39;
    A vector result descriptor
    &#39;&#39;&#39;
    __spatial_bounds: Optional[BoundingBox2D]
    __data_type: VectorDataType
    __columns: Dict[str, VectorColumnInfo]

    def __init__(  # pylint: disable=too-many-arguments
        self,
        spatial_reference: str,
        data_type: VectorDataType,
        columns: Dict[str, VectorColumnInfo],
        time_bounds: Optional[TimeInterval] = None,
        spatial_bounds: Optional[BoundingBox2D] = None,
        spatial_resolution: Optional[SpatialResolution] = None
    ) -&gt; None:
        &#39;&#39;&#39; Initialize a vector result descriptor &#39;&#39;&#39;
        super().__init__(spatial_reference, time_bounds, spatial_resolution)
        self.__data_type = data_type
        self.__columns = columns
        self.__spatial_bounds = spatial_bounds

    @staticmethod
    def from_response_vector(response: api.VectorResultDescriptor) -&gt; VectorResultDescriptor:
        &#39;&#39;&#39;Parse a vector result descriptor from an http response&#39;&#39;&#39;
        assert response[&#39;type&#39;] == &#39;vector&#39;  # TODO: throw exception

        sref = response[&#39;spatialReference&#39;]
        data_type = VectorDataType.from_string(response[&#39;dataType&#39;])
        columns = {name: VectorColumnInfo.from_response(info) for name, info in response[&#39;columns&#39;].items()}

        time_bounds = None
        # FIXME: datetime can not represent our min max range
        # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
        #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
        spatial_bounds = None
        if &#39;bbox&#39; in response and response[&#39;bbox&#39;] is not None:
            spatial_bounds = BoundingBox2D.from_response(response[&#39;bbox&#39;])
        spatial_resolution = None
        if &#39;resolution&#39; in response and response[&#39;resolution&#39;] is not None:
            spatial_resolution = SpatialResolution.from_response(response[&#39;resolution&#39;])

        return VectorResultDescriptor(sref, data_type, columns, time_bounds, spatial_bounds, spatial_resolution)

    @classmethod
    def is_vector_result(cls) -&gt; bool:
        return True

    @property
    def data_type(self) -&gt; VectorDataType:
        &#39;&#39;&#39;Return the data type&#39;&#39;&#39;
        return self.__data_type

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;
        return super().spatial_reference

    @property
    def columns(self) -&gt; Dict[str, VectorColumnInfo]:
        &#39;&#39;&#39;Return the columns&#39;&#39;&#39;

        return self.__columns

    @property
    def spatial_bounds(self) -&gt; Optional[BoundingBox2D]:
        &#39;&#39;&#39;Return the spatial bounds&#39;&#39;&#39;
        return self.__spatial_bounds

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of the vector result descriptor&#39;&#39;&#39;
        r = &#39;&#39;
        r += f&#39;Data type:         {self.data_type.value}\n&#39;
        r += f&#39;Spatial Reference: {self.spatial_reference}\n&#39;

        r += &#39;Columns:\n&#39;
        for column_name in self.columns:
            column_info = self.columns[column_name]
            r += f&#39;  {column_name}:\n&#39;
            r += f&#39;    Column Type: {column_info.data_type.value}\n&#39;
            r += f&#39;    Measurement: {column_info.measurement}\n&#39;

        return r

    def to_api_dict(self) -&gt; api.VectorResultDescriptor:
        &#39;&#39;&#39;Convert the vector result descriptor to a dictionary&#39;&#39;&#39;

        return api.VectorResultDescriptor({
            &#39;type&#39;: &#39;raster&#39;,
            &#39;dataType&#39;: self.data_type.to_api_enum(),
            &#39;spatialReference&#39;: self.spatial_reference,
            &#39;columns&#39;:
                {name: column_info.to_api_dict() for name, column_info in self.columns.items()},
            &#39;time&#39;: self.time_bounds.to_api_dict() if self.time_bounds is not None else None,
            &#39;bbox&#39;: self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
            &#39;resolution&#39;: self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None,
        })


class FeatureDataType(str, Enum):
    &#39;&#39;&#39;Vector column data type&#39;&#39;&#39;

    CATEGORY = &#34;category&#34;
    INT = &#34;int&#34;
    FLOAT = &#34;float&#34;
    TEXT = &#34;text&#34;
    BOOL = &#34;bool&#34;
    DATETIME = &#34;dateTime&#34;

    @staticmethod
    def from_string(data_type: str) -&gt; FeatureDataType:
        &#39;&#39;&#39;Create a new `VectorColumnDataType` from a string&#39;&#39;&#39;

        return FeatureDataType(data_type)

    def to_api_enum(self) -&gt; api.FeatureDataType:
        &#39;&#39;&#39;Convert to an API enum&#39;&#39;&#39;

        return api.FeatureDataType(self.value)


@dataclass
class VectorColumnInfo:
    &#39;&#39;&#39;Vector column information&#39;&#39;&#39;

    data_type: FeatureDataType
    measurement: Measurement

    @staticmethod
    def from_response(response: api.VectorColumnInfo) -&gt; VectorColumnInfo:
        &#39;&#39;&#39;Create a new `VectorColumnInfo` from a JSON response&#39;&#39;&#39;

        return VectorColumnInfo(
            FeatureDataType.from_string(response[&#39;dataType&#39;]),
            Measurement.from_response(response[&#39;measurement&#39;])
        )

    def to_api_dict(self) -&gt; api.VectorColumnInfo:
        &#39;&#39;&#39;Convert to a dictionary&#39;&#39;&#39;

        return api.VectorColumnInfo({
            &#39;dataType&#39;: self.data_type.to_api_enum(),
            &#39;measurement&#39;: self.measurement.to_api_dict(),
        })


class RasterResultDescriptor(ResultDescriptor):
    &#39;&#39;&#39;
    A raster result descriptor
    &#39;&#39;&#39;
    __data_type: Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;]
    __measurement: Measurement
    __spatial_bounds: Optional[SpatialPartition2D]

    def __init__(  # pylint: disable=too-many-arguments
        self,
        data_type: Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;],
        measurement: Measurement,
        spatial_reference: str,
        time_bounds: Optional[TimeInterval] = None,
        spatial_bounds: Optional[SpatialPartition2D] = None,
        spatial_resolution: Optional[SpatialResolution] = None
    ) -&gt; None:
        &#39;&#39;&#39;Initialize a new `RasterResultDescriptor`&#39;&#39;&#39;
        super().__init__(spatial_reference, time_bounds, spatial_resolution)
        self.__data_type = data_type
        self.__measurement = measurement
        self.__spatial_bounds = spatial_bounds

    def to_api_dict(self) -&gt; api.RasterResultDescriptor:
        &#39;&#39;&#39;Convert the raster result descriptor to a dictionary&#39;&#39;&#39;

        return {
            &#39;type&#39;: &#39;raster&#39;,
            &#39;dataType&#39;: self.data_type,
            &#39;measurement&#39;: self.measurement.to_api_dict(),
            &#39;spatialReference&#39;: self.spatial_reference,
            &#39;time&#39;: self.time_bounds.to_api_dict() if self.time_bounds is not None else None,
            &#39;bbox&#39;: self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
            &#39;resolution&#39;: self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None
        }

    @staticmethod
    def from_response_raster(response: api.RasterResultDescriptor) -&gt; RasterResultDescriptor:
        &#39;&#39;&#39;Parse a raster result descriptor from an http response&#39;&#39;&#39;
        assert response[&#39;type&#39;] == &#39;raster&#39;  # TODO: throw exception

        spatial_ref = response[&#39;spatialReference&#39;]
        data_type = response[&#39;dataType&#39;]
        measurement = Measurement.from_response(response[&#39;measurement&#39;])

        time_bounds = None
        # FIXME: datetime can not represent our min max range
        # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
        #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
        spatial_bounds = None
        if &#39;bbox&#39; in response and response[&#39;bbox&#39;] is not None:
            spatial_bounds = SpatialPartition2D.from_response(response[&#39;bbox&#39;])
        spatial_resolution = None
        if &#39;resolution&#39; in response and response[&#39;resolution&#39;] is not None:
            spatial_resolution = SpatialResolution.from_response(response[&#39;resolution&#39;])

        return RasterResultDescriptor(
            data_type=data_type,
            measurement=measurement,
            spatial_reference=spatial_ref,
            time_bounds=time_bounds,
            spatial_bounds=spatial_bounds,
            spatial_resolution=spatial_resolution
        )

    @classmethod
    def is_raster_result(cls) -&gt; bool:
        return True

    @property
    def data_type(self) -&gt; Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;]:
        return self.__data_type

    @property
    def measurement(self) -&gt; Measurement:
        return self.__measurement

    @property
    def spatial_bounds(self) -&gt; Optional[SpatialPartition2D]:
        return self.__spatial_bounds

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;

        return super().spatial_reference

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of the raster result descriptor&#39;&#39;&#39;
        r = &#39;&#39;
        r += f&#39;Data type:         {self.data_type}\n&#39;
        r += f&#39;Spatial Reference: {self.spatial_reference}\n&#39;
        r += f&#39;Measurement:       {self.measurement}\n&#39;

        return r

    def to_json(self) -&gt; api.RasterResultDescriptor:
        return self.to_api_dict()


class PlotResultDescriptor(ResultDescriptor):
    &#39;&#39;&#39;
    A plot result descriptor
    &#39;&#39;&#39;

    __spatial_bounds: Optional[BoundingBox2D]

    def __init__(  # pylint: disable=too-many-arguments]
        self,
        spatial_reference: str,
        time_bounds: Optional[TimeInterval] = None,
        spatial_bounds: Optional[BoundingBox2D] = None,
        spatial_resolution: Optional[SpatialResolution] = None
    ) -&gt; None:
        &#39;&#39;&#39;Initialize a new `PlotResultDescriptor`&#39;&#39;&#39;
        super().__init__(spatial_reference, time_bounds, spatial_resolution)
        self.__spatial_bounds = spatial_bounds

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of the plot result descriptor&#39;&#39;&#39;
        r = &#39;Plot Result&#39;

        return r

    @staticmethod
    def from_response_plot(response: api.PlotResultDescriptor) -&gt; PlotResultDescriptor:
        &#39;&#39;&#39;Create a new `PlotResultDescriptor` from a JSON response&#39;&#39;&#39;
        assert response[&#39;type&#39;] == &#39;plot&#39;  # TODO: throw exception

        spatial_ref = response[&#39;spatialReference&#39;]

        time_bounds = None
        # FIXME: datetime can not represent our min max range
        # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
        #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
        spatial_bounds = None
        if &#39;bbox&#39; in response and response[&#39;bbox&#39;] is not None:
            spatial_bounds = BoundingBox2D.from_response(response[&#39;bbox&#39;])
        spatial_resolution = None
        if &#39;resolution&#39; in response and response[&#39;resolution&#39;] is not None:
            spatial_resolution = SpatialResolution.from_response(response[&#39;resolution&#39;])

        return PlotResultDescriptor(
            spatial_reference=spatial_ref,
            time_bounds=time_bounds,
            spatial_bounds=spatial_bounds,
            spatial_resolution=spatial_resolution
        )

    @classmethod
    def is_plot_result(cls) -&gt; bool:
        return True

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;
        return super().spatial_reference

    @property
    def spatial_bounds(self) -&gt; Optional[BoundingBox2D]:
        return self.__spatial_bounds

    def to_api_dict(self) -&gt; api.PlotResultDescriptor:
        &#39;&#39;&#39;Convert the plot result descriptor to a dictionary&#39;&#39;&#39;

        return api.PlotResultDescriptor({
            &#39;type&#39;: &#39;plot&#39;,
            &#39;spatialReference&#39;: self.spatial_reference,
            &#39;dataType&#39;: &#39;Plot&#39;,
            &#39;time&#39;: self.time_bounds.to_api_dict() if self.time_bounds is not None else None,
            &#39;bbox&#39;: self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
            &#39;resolution&#39;: self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None,
        })


class VectorDataType(str, Enum):
    &#39;&#39;&#39;An enum of vector data types&#39;&#39;&#39;

    DATA = &#39;Data&#39;
    MULTI_POINT = &#39;MultiPoint&#39;
    MULTI_LINE_STRING = &#39;MultiLineString&#39;
    MULTI_POLYGON = &#39;MultiPolygon&#39;

    @classmethod
    def from_geopandas_type_name(cls, name: str) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from geopandas geometry type&#39;&#39;&#39;

        name_map = {
            &#34;Point&#34;: VectorDataType.MULTI_POINT,
            &#34;MultiPoint&#34;: VectorDataType.MULTI_POINT,
            &#34;Line&#34;: VectorDataType.MULTI_LINE_STRING,
            &#34;MultiLine&#34;: VectorDataType.MULTI_LINE_STRING,
            &#34;Polygon&#34;: VectorDataType.MULTI_POLYGON,
            &#34;MultiPolygon&#34;: VectorDataType.MULTI_POLYGON,
        }

        if name in name_map:
            return name_map[name]

        raise InputException(&#34;Invalid vector data type&#34;)

    def to_api_enum(self) -&gt; api.VectorDataType:
        return api.VectorDataType(self.value)

    @staticmethod
    def from_literal(literal: Literal[&#39;Data&#39;, &#39;MultiPoint&#39;, &#39;MultiLineString&#39;, &#39;MultiPolygon&#39;]) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from literal&#39;&#39;&#39;
        return VectorDataType(literal)

    @staticmethod
    def from_api_enum(data_type: api.VectorDataType) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from API enum&#39;&#39;&#39;
        return VectorDataType(data_type.value)

    @staticmethod
    def from_string(string: str) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from string&#39;&#39;&#39;
        if string not in VectorDataType.__members__.values():
            raise InputException(&#34;Invalid vector data type: &#34; + string)
        return VectorDataType(string)


class TimeStepGranularity(Enum):
    &#39;&#39;&#39;An enum of time step granularities&#39;&#39;&#39;
    MILLIS = &#39;Millis&#39;
    SECONDS = &#39;Seconds&#39;
    MINUTES = &#39;Minutes&#39;
    HOURS = &#39;Hours&#39;
    DAYS = &#39;Days&#39;
    MONTHS = &#39;Months&#39;
    YEARS = &#39;Years&#39;

    def to_api_enum(self) -&gt; api.TimeStepGranularity:
        return api.TimeStepGranularity(self.value)


@dataclass
class TimeStep:
    &#39;&#39;&#39;A time step that consists of a granularity and a step size&#39;&#39;&#39;
    step: int
    granularity: TimeStepGranularity

    def to_api_dict(self) -&gt; api.TimeStep:
        return api.TimeStep({
            &#39;step&#39;: self.step,
            &#39;granularity&#39;: self.granularity.to_api_enum(),
        })


@dataclass
class Provenance:
    &#39;&#39;&#39;Provenance information as triplet of citation, license and uri&#39;&#39;&#39;

    citation: str
    license: str
    uri: str

    @classmethod
    def from_response(cls, response: api.Provenance) -&gt; Provenance:
        &#39;&#39;&#39;Parse an http response to a `Provenance` object&#39;&#39;&#39;
        return Provenance(response[&#39;citation&#39;], response[&#39;license&#39;], response[&#39;uri&#39;])

    def to_api_dict(self) -&gt; api.Provenance:
        return api.Provenance({
            &#39;citation&#39;: self.citation,
            &#39;license&#39;: self.license,
            &#39;uri&#39;: self.uri,
        })


@dataclass
class ProvenanceEntry:
    &#39;&#39;&#39;Provenance of a dataset&#39;&#39;&#39;

    data: List[DataId]
    provenance: Provenance

    @classmethod
    def from_response(cls, response: api.ProvenanceEntry) -&gt; ProvenanceEntry:
        &#39;&#39;&#39;Parse an http response to a `ProvenanceEntry` object&#39;&#39;&#39;

        dataset = [DataId.from_response(data) for data in response[&#39;data&#39;]]
        provenance = Provenance.from_response(response[&#39;provenance&#39;])

        return ProvenanceEntry(dataset, provenance)


class Symbology:
    &#39;&#39;&#39;Base class for symbology&#39;&#39;&#39;

    @abstractmethod
    def to_api_dict(self) -&gt; api.Symbology:
        pass

    @staticmethod
    def from_response(response: api.Symbology) -&gt; Symbology:
        &#39;&#39;&#39;Parse an http response to a `Symbology` object&#39;&#39;&#39;

        if response[&#39;type&#39;] == &#39;vector&#39;:
            # return VectorSymbology.from_response_vector(response)
            return VectorSymbology()  # TODO: implement
        if response[&#39;type&#39;] == &#39;raster&#39;:
            return RasterSymbology.from_response_raster(cast(api.RasterSymbology, response))

        raise InputException(&#34;Invalid symbology type&#34;)


class VectorSymbology(Symbology):
    &#39;&#39;&#39;A vector symbology&#39;&#39;&#39;

    # TODO: implement

    def to_api_dict(self) -&gt; api.Symbology:
        return api.Symbology({
            &#39;type&#39;: &#39;vector&#39;,
        })


class RasterSymbology(Symbology):
    &#39;&#39;&#39;A raster symbology&#39;&#39;&#39;
    __opacity: float
    __colorizer: Colorizer

    def __init__(self, colorizer: Colorizer, opacity: float = 1.0) -&gt; None:
        &#39;&#39;&#39;Initialize a new `RasterSymbology`&#39;&#39;&#39;

        self.__colorizer = colorizer
        self.__opacity = opacity

    def to_api_dict(self) -&gt; api.RasterSymbology:
        &#39;&#39;&#39;Convert the raster symbology to a dictionary&#39;&#39;&#39;

        return api.RasterSymbology({
            &#39;type&#39;: &#39;raster&#39;,
            &#39;colorizer&#39;: self.__colorizer.to_api_dict(),
            &#39;opacity&#39;: self.__opacity,
        })

    @staticmethod
    def from_response_raster(response: api.RasterSymbology) -&gt; RasterSymbology:
        &#39;&#39;&#39;Parse an http response to a `RasterSymbology` object&#39;&#39;&#39;

        colorizer = Colorizer.from_response(response[&#39;colorizer&#39;])

        return RasterSymbology(colorizer, response[&#39;opacity&#39;])

    def __repr__(self) -&gt; str:
        return super().__repr__() + f&#34;({self.__colorizer}, {self.__opacity})&#34;


class DataId:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;Base class for data ids&#39;&#39;&#39;
    @classmethod
    def from_response(cls, response: api.DataId) -&gt; DataId:
        &#39;&#39;&#39;Parse an http response to a `DataId` object&#39;&#39;&#39;

        if response[&#34;type&#34;] == &#34;internal&#34;:
            return InternalDataId.from_response_internal(cast(api.InternalDataId, response))
        if response[&#34;type&#34;] == &#34;external&#34;:
            return ExternalDataId.from_response_external(cast(api.ExternalDataId, response))

        raise GeoEngineException({&#34;message&#34;: f&#34;Unknown DataId type: {response[&#39;type&#39;]}&#34;})

    @abstractmethod
    def to_api_dict(self) -&gt; api.DataId:
        pass


class InternalDataId(DataId):
    &#39;&#39;&#39;An internal data id&#39;&#39;&#39;

    __dataset_id: UUID

    def __init__(self, dataset_id: UUID):
        self.__dataset_id = dataset_id

    @classmethod
    def from_response_internal(cls, response: api.InternalDataId) -&gt; InternalDataId:
        &#39;&#39;&#39;Parse an http response to a `InternalDataId` object&#39;&#39;&#39;
        return InternalDataId(UUID(response[&#39;datasetId&#39;]))

    def to_api_dict(self) -&gt; api.InternalDataId:
        return api.InternalDataId({
            &#34;type&#34;: &#34;internal&#34;,
            &#34;datasetId&#34;: str(self.__dataset_id)
        })

    def __str__(self) -&gt; str:
        return str(self.__dataset_id)

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of an internal data id&#39;&#39;&#39;
        return str(self)

    def __eq__(self, other) -&gt; bool:
        &#39;&#39;&#39;Check if two internal data ids are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.__dataset_id == other.__dataset_id  # pylint: disable=protected-access


class ExternalDataId(DataId):
    &#39;&#39;&#39;An external data id&#39;&#39;&#39;

    __provider_id: UUID
    __layer_id: str

    def __init__(self, provider_id: UUID, layer_id: str):
        self.__provider_id = provider_id
        self.__layer_id = layer_id

    @classmethod
    def from_response_external(cls, response: api.ExternalDataId) -&gt; ExternalDataId:
        &#39;&#39;&#39;Parse an http response to a `ExternalDataId` object&#39;&#39;&#39;

        return ExternalDataId(UUID(response[&#39;providerId&#39;]), response[&#39;layerId&#39;])

    def to_api_dict(self) -&gt; api.ExternalDataId:
        return api.ExternalDataId({
            &#34;type&#34;: &#34;external&#34;,
            &#34;providerId&#34;: str(self.__provider_id),
            &#34;layerId&#34;: self.__layer_id,
        })

    def __str__(self) -&gt; str:
        return f&#39;{self.__provider_id}:{self.__layer_id}&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of an external data id&#39;&#39;&#39;
        return str(self)

    def __eq__(self, other) -&gt; bool:
        &#39;&#39;&#39;Check if two external data ids are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.__provider_id == other.__provider_id and self.__layer_id == other.__layer_id  # pylint: disable=protected-access


class Measurement:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;
    Base class for measurements
    &#39;&#39;&#39;

    @staticmethod
    def from_response(response: api.Measurement) -&gt; Measurement:
        &#39;&#39;&#39;
        Parse a result descriptor from an http response
        &#39;&#39;&#39;

        if &#39;error&#39; in response:
            raise GeoEngineException(cast(api.GeoEngineExceptionResponse, response))

        measurement_type = response[&#39;type&#39;]

        if measurement_type == &#39;unitless&#39;:
            return UnitlessMeasurement()
        if measurement_type == &#39;continuous&#39;:
            return ContinuousMeasurement.from_response_continuous(cast(api.ContinuousMeasurement, response))
        if measurement_type == &#39;classification&#39;:
            return ClassificationMeasurement.from_response_classification(cast(api.ClassificationMeasurement, response))

        raise TypeException(
            f&#39;Unknown `Measurement` type: {measurement_type}&#39;)

    @abstractmethod
    def to_api_dict(self) -&gt; api.Measurement:
        pass


class UnitlessMeasurement(Measurement):
    &#39;&#39;&#39;A measurement that is unitless&#39;&#39;&#39;

    def __str__(self) -&gt; str:
        &#39;&#39;&#39;String representation of a unitless measurement&#39;&#39;&#39;
        return &#39;unitless&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a unitless measurement&#39;&#39;&#39;
        return str(self)

    def to_api_dict(self) -&gt; api.Measurement:
        return api.Measurement({
            &#39;type&#39;: &#39;unitless&#39;
        })


class ContinuousMeasurement(Measurement):
    &#39;&#39;&#39;A measurement that is continuous&#39;&#39;&#39;

    __measurement: str
    __unit: Optional[str]

    def __init__(self, measurement: str, unit: Optional[str]) -&gt; None:
        &#39;&#39;&#39;Initialize a new `ContiuousMeasurement`&#39;&#39;&#39;

        super().__init__()

        self.__measurement = measurement
        self.__unit = unit

    @staticmethod
    def from_response_continuous(response: api.ContinuousMeasurement) -&gt; ContinuousMeasurement:
        &#39;&#39;&#39;Initialize a new `ContiuousMeasurement from a JSON response&#39;&#39;&#39;

        return ContinuousMeasurement(response[&#39;measurement&#39;], response.get(&#39;unit&#39;, None))

    def __str__(self) -&gt; str:
        &#39;&#39;&#39;String representation of a continuous measurement&#39;&#39;&#39;

        if self.__unit is None:
            return self.__measurement

        return f&#39;{self.__measurement} ({self.__unit})&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a continuous measurement&#39;&#39;&#39;
        return str(self)

    def to_api_dict(self) -&gt; api.ContinuousMeasurement:
        return api.ContinuousMeasurement({
            &#39;type&#39;: &#39;continuous&#39;,
            &#39;measurement&#39;: self.__measurement,
            &#39;unit&#39;: self.__unit
        })

    @property
    def measurement(self) -&gt; str:
        return self.__measurement

    @property
    def unit(self) -&gt; Optional[str]:
        return self.__unit


class ClassificationMeasurement(Measurement):
    &#39;&#39;&#39;A measurement that is a classification&#39;&#39;&#39;

    __measurement: str
    __classes: Dict[int, str]

    def __init__(self, measurement: str, classes: Dict[int, str]) -&gt; None:
        &#39;&#39;&#39;Initialize a new `ClassificationMeasurement`&#39;&#39;&#39;

        super().__init__()

        self.__measurement = measurement
        self.__classes = classes

    @staticmethod
    def from_response_classification(response: api.ClassificationMeasurement) -&gt; ClassificationMeasurement:
        &#39;&#39;&#39;Initialize a new `ClassificationMeasurement from a JSON response&#39;&#39;&#39;

        measurement = response[&#39;measurement&#39;]

        str_classes: Dict[str, str] = response[&#39;classes&#39;]
        classes = {int(k): v for k, v in str_classes.items()}

        return ClassificationMeasurement(measurement, classes)

    def to_api_dict(self) -&gt; api.ClassificationMeasurement:
        str_classes: Dict[str, str] = {str(k): v for k, v in self.__classes.items()}

        return api.ClassificationMeasurement({
            &#39;type&#39;: &#39;classification&#39;,
            &#39;measurement&#39;: self.__measurement,
            &#39;classes&#39;: str_classes
        })

    def __str__(self) -&gt; str:
        &#39;&#39;&#39;String representation of a classification measurement&#39;&#39;&#39;
        classes_str = &#39;, &#39;.join(f&#39;{k}: {v}&#39; for k, v in self.__classes.items())
        return f&#39;{self.__measurement} ({classes_str})&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a classification measurement&#39;&#39;&#39;
        return str(self)

    @property
    def measurement(self) -&gt; str:
        return self.__measurement

    @property
    def classes(self) -&gt; Dict[int, str]:
        return self.__classes


class GeoTransform:
    &#39;&#39;&#39;The `GeoTransform` specifies the relationship between pixel coordinates and geographic coordinates.&#39;&#39;&#39;

    x_min: float
    y_max: float
    &#39;&#39;&#39;In Geo Engine, x_pixel_size is always positive.&#39;&#39;&#39;
    x_pixel_size: float
    &#39;&#39;&#39;In Geo Engine, y_pixel_size is always negative.&#39;&#39;&#39;
    y_pixel_size: float

    def __init__(self, x_min: float, y_max: float, x_pixel_size: float, y_pixel_size: float):
        &#39;&#39;&#39;Initialize a new `GeoTransform`&#39;&#39;&#39;

        assert x_pixel_size &gt; 0, &#39;In Geo Engine, x_pixel_size is always positive.&#39;
        assert y_pixel_size &lt; 0, &#39;In Geo Engine, y_pixel_size is always negative.&#39;

        self.x_min = x_min
        self.y_max = y_max
        self.x_pixel_size = x_pixel_size
        self.y_pixel_size = y_pixel_size

    @classmethod
    def from_response(cls, response: api.GeoTransform) -&gt; GeoTransform:
        &#39;&#39;&#39;Parse a geotransform from an HTTP JSON response&#39;&#39;&#39;

        return GeoTransform(
            x_min=response[&#39;originCoordinate&#39;][&#39;x&#39;],
            y_max=response[&#39;originCoordinate&#39;][&#39;y&#39;],
            x_pixel_size=response[&#39;xPixelSize&#39;],
            y_pixel_size=response[&#39;yPixelSize&#39;],
        )

    def to_api_dict(self) -&gt; api.GeoTransform:
        return api.GeoTransform({
            &#39;originCoordinate&#39;: {
                &#39;x&#39;: self.x_min,
                &#39;y&#39;: self.y_max,
            },
            &#39;xPixelSize&#39;: self.x_pixel_size,
            &#39;yPixelSize&#39;: self.y_pixel_size
        })

    def __str__(self) -&gt; str:
        return f&#39;Origin: ({self.x_min}, {self.y_max}), &#39; \
            f&#39;X Pixel Size: {self.x_pixel_size}, &#39; \
            f&#39;Y Pixel Size: {self.y_pixel_size}&#39;

    def __repr__(self) -&gt; str:
        return str(self)

    @property
    def x_half_pixel_size(self) -&gt; float:
        return self.x_pixel_size / 2.0

    @property
    def y_half_pixel_size(self) -&gt; float:
        return self.y_pixel_size / 2.0

    def x_max(self, number_of_pixels: int) -&gt; float:
        return self.x_min + number_of_pixels * self.x_pixel_size

    def y_min(self, number_of_pixels: int) -&gt; float:
        return self.y_max + number_of_pixels * self.y_pixel_size</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="geoengine.types.BoundingBox2D"><code class="flex name class">
<span>class <span class="ident">BoundingBox2D</span></span>
<span>(</span><span>xmin:float, ymin:float, xmax:float, ymax:float)</span>
</code></dt>
<dd>
<div class="desc"><p>'A 2D bounding box.</p>
<p>Initialize a new <code><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoundingBox2D(SpatialBounds):
    &#39;&#39;&#39;&#39;A 2D bounding box.&#39;&#39;&#39;

    def to_api_dict(self) -&gt; api.BoundingBox2D:
        return api.BoundingBox2D({
            &#39;lowerLeftCoordinate&#39;: api.Coordinate2D({
                &#34;x&#34;: self.xmin,
                &#34;y&#34;: self.ymin,
            }),
            &#39;upperRightCoordinate&#39;: api.Coordinate2D({
                &#34;x&#34;: self.xmax,
                &#34;y&#34;: self.ymax,
            }),
        })

    @staticmethod
    def from_response(response: api.BoundingBox2D) -&gt; BoundingBox2D:
        &#39;&#39;&#39;create a `BoundingBox2D` from an API response&#39;&#39;&#39;
        if &#39;lowerLeftCoordinate&#39; not in response or &#39;upperRightCoordinate&#39; not in response:
            raise TypeException(&#39;BoundingBox2D must have lowerLeftCoordinate and upperRightCoordinate&#39;)

        lower_left = response[&#39;lowerLeftCoordinate&#39;]
        upper_right = response[&#39;upperRightCoordinate&#39;]

        return BoundingBox2D(
            lower_left[&#39;x&#39;],
            lower_left[&#39;y&#39;],
            upper_right[&#39;x&#39;],
            upper_right[&#39;y&#39;],
        )

    def __repr__(self) -&gt; str:
        return f&#39;BoundingBox2D(xmin={self.xmin}, ymin={self.ymin}, xmax={self.xmax}, ymax={self.ymax})&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.BoundingBox2D.xmax"><code class="name">var <span class="ident">xmax</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.BoundingBox2D.xmin"><code class="name">var <span class="ident">xmin</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.BoundingBox2D.ymax"><code class="name">var <span class="ident">ymax</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.BoundingBox2D.ymin"><code class="name">var <span class="ident">ymin</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.BoundingBox2D.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:api.BoundingBox2D) ><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>create a <code><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></code> from an API response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: api.BoundingBox2D) -&gt; BoundingBox2D:
    &#39;&#39;&#39;create a `BoundingBox2D` from an API response&#39;&#39;&#39;
    if &#39;lowerLeftCoordinate&#39; not in response or &#39;upperRightCoordinate&#39; not in response:
        raise TypeException(&#39;BoundingBox2D must have lowerLeftCoordinate and upperRightCoordinate&#39;)

    lower_left = response[&#39;lowerLeftCoordinate&#39;]
    upper_right = response[&#39;upperRightCoordinate&#39;]

    return BoundingBox2D(
        lower_left[&#39;x&#39;],
        lower_left[&#39;y&#39;],
        upper_right[&#39;x&#39;],
        upper_right[&#39;y&#39;],
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.BoundingBox2D.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.BoundingBox2D" href="api.html#geoengine.api.BoundingBox2D">BoundingBox2D</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.BoundingBox2D:
    return api.BoundingBox2D({
        &#39;lowerLeftCoordinate&#39;: api.Coordinate2D({
            &#34;x&#34;: self.xmin,
            &#34;y&#34;: self.ymin,
        }),
        &#39;upperRightCoordinate&#39;: api.Coordinate2D({
            &#34;x&#34;: self.xmax,
            &#34;y&#34;: self.ymax,
        }),
    })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.SpatialBounds.as_bbox_str" href="#geoengine.types.SpatialBounds.as_bbox_str">as_bbox_str</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.as_bbox_tuple" href="#geoengine.types.SpatialBounds.as_bbox_tuple">as_bbox_tuple</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.x_axis_size" href="#geoengine.types.SpatialBounds.x_axis_size">x_axis_size</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.y_axis_size" href="#geoengine.types.SpatialBounds.y_axis_size">y_axis_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.ClassificationMeasurement"><code class="flex name class">
<span>class <span class="ident">ClassificationMeasurement</span></span>
<span>(</span><span>measurement:str, classes:Dict[int,str])</span>
</code></dt>
<dd>
<div class="desc"><p>A measurement that is a classification</p>
<p>Initialize a new <code><a title="geoengine.types.ClassificationMeasurement" href="#geoengine.types.ClassificationMeasurement">ClassificationMeasurement</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClassificationMeasurement(Measurement):
    &#39;&#39;&#39;A measurement that is a classification&#39;&#39;&#39;

    __measurement: str
    __classes: Dict[int, str]

    def __init__(self, measurement: str, classes: Dict[int, str]) -&gt; None:
        &#39;&#39;&#39;Initialize a new `ClassificationMeasurement`&#39;&#39;&#39;

        super().__init__()

        self.__measurement = measurement
        self.__classes = classes

    @staticmethod
    def from_response_classification(response: api.ClassificationMeasurement) -&gt; ClassificationMeasurement:
        &#39;&#39;&#39;Initialize a new `ClassificationMeasurement from a JSON response&#39;&#39;&#39;

        measurement = response[&#39;measurement&#39;]

        str_classes: Dict[str, str] = response[&#39;classes&#39;]
        classes = {int(k): v for k, v in str_classes.items()}

        return ClassificationMeasurement(measurement, classes)

    def to_api_dict(self) -&gt; api.ClassificationMeasurement:
        str_classes: Dict[str, str] = {str(k): v for k, v in self.__classes.items()}

        return api.ClassificationMeasurement({
            &#39;type&#39;: &#39;classification&#39;,
            &#39;measurement&#39;: self.__measurement,
            &#39;classes&#39;: str_classes
        })

    def __str__(self) -&gt; str:
        &#39;&#39;&#39;String representation of a classification measurement&#39;&#39;&#39;
        classes_str = &#39;, &#39;.join(f&#39;{k}: {v}&#39; for k, v in self.__classes.items())
        return f&#39;{self.__measurement} ({classes_str})&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a classification measurement&#39;&#39;&#39;
        return str(self)

    @property
    def measurement(self) -&gt; str:
        return self.__measurement

    @property
    def classes(self) -&gt; Dict[int, str]:
        return self.__classes</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.ClassificationMeasurement.from_response_classification"><code class="name flex">
<span>def <span class="ident">from_response_classification</span></span>(<span>response:api.ClassificationMeasurement) ><a title="geoengine.types.ClassificationMeasurement" href="#geoengine.types.ClassificationMeasurement">ClassificationMeasurement</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a new `ClassificationMeasurement from a JSON response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_classification(response: api.ClassificationMeasurement) -&gt; ClassificationMeasurement:
    &#39;&#39;&#39;Initialize a new `ClassificationMeasurement from a JSON response&#39;&#39;&#39;

    measurement = response[&#39;measurement&#39;]

    str_classes: Dict[str, str] = response[&#39;classes&#39;]
    classes = {int(k): v for k, v in str_classes.items()}

    return ClassificationMeasurement(measurement, classes)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.ClassificationMeasurement.classes"><code class="name">var <span class="ident">classes</span> :Dict[int,str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def classes(self) -&gt; Dict[int, str]:
    return self.__classes</code></pre>
</details>
</dd>
<dt id="geoengine.types.ClassificationMeasurement.measurement"><code class="name">var <span class="ident">measurement</span> :str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def measurement(self) -&gt; str:
    return self.__measurement</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.ClassificationMeasurement.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.ClassificationMeasurement" href="api.html#geoengine.api.ClassificationMeasurement">ClassificationMeasurement</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.ClassificationMeasurement:
    str_classes: Dict[str, str] = {str(k): v for k, v in self.__classes.items()}

    return api.ClassificationMeasurement({
        &#39;type&#39;: &#39;classification&#39;,
        &#39;measurement&#39;: self.__measurement,
        &#39;classes&#39;: str_classes
    })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.Measurement.from_response" href="#geoengine.types.Measurement.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.ContinuousMeasurement"><code class="flex name class">
<span>class <span class="ident">ContinuousMeasurement</span></span>
<span>(</span><span>measurement:str, unit:Optional[str])</span>
</code></dt>
<dd>
<div class="desc"><p>A measurement that is continuous</p>
<p>Initialize a new <code>ContiuousMeasurement</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContinuousMeasurement(Measurement):
    &#39;&#39;&#39;A measurement that is continuous&#39;&#39;&#39;

    __measurement: str
    __unit: Optional[str]

    def __init__(self, measurement: str, unit: Optional[str]) -&gt; None:
        &#39;&#39;&#39;Initialize a new `ContiuousMeasurement`&#39;&#39;&#39;

        super().__init__()

        self.__measurement = measurement
        self.__unit = unit

    @staticmethod
    def from_response_continuous(response: api.ContinuousMeasurement) -&gt; ContinuousMeasurement:
        &#39;&#39;&#39;Initialize a new `ContiuousMeasurement from a JSON response&#39;&#39;&#39;

        return ContinuousMeasurement(response[&#39;measurement&#39;], response.get(&#39;unit&#39;, None))

    def __str__(self) -&gt; str:
        &#39;&#39;&#39;String representation of a continuous measurement&#39;&#39;&#39;

        if self.__unit is None:
            return self.__measurement

        return f&#39;{self.__measurement} ({self.__unit})&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a continuous measurement&#39;&#39;&#39;
        return str(self)

    def to_api_dict(self) -&gt; api.ContinuousMeasurement:
        return api.ContinuousMeasurement({
            &#39;type&#39;: &#39;continuous&#39;,
            &#39;measurement&#39;: self.__measurement,
            &#39;unit&#39;: self.__unit
        })

    @property
    def measurement(self) -&gt; str:
        return self.__measurement

    @property
    def unit(self) -&gt; Optional[str]:
        return self.__unit</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.ContinuousMeasurement.from_response_continuous"><code class="name flex">
<span>def <span class="ident">from_response_continuous</span></span>(<span>response:api.ContinuousMeasurement) ><a title="geoengine.types.ContinuousMeasurement" href="#geoengine.types.ContinuousMeasurement">ContinuousMeasurement</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a new `ContiuousMeasurement from a JSON response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_continuous(response: api.ContinuousMeasurement) -&gt; ContinuousMeasurement:
    &#39;&#39;&#39;Initialize a new `ContiuousMeasurement from a JSON response&#39;&#39;&#39;

    return ContinuousMeasurement(response[&#39;measurement&#39;], response.get(&#39;unit&#39;, None))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.ContinuousMeasurement.measurement"><code class="name">var <span class="ident">measurement</span> :str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def measurement(self) -&gt; str:
    return self.__measurement</code></pre>
</details>
</dd>
<dt id="geoengine.types.ContinuousMeasurement.unit"><code class="name">var <span class="ident">unit</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unit(self) -&gt; Optional[str]:
    return self.__unit</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.ContinuousMeasurement.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.ContinuousMeasurement" href="api.html#geoengine.api.ContinuousMeasurement">ContinuousMeasurement</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.ContinuousMeasurement:
    return api.ContinuousMeasurement({
        &#39;type&#39;: &#39;continuous&#39;,
        &#39;measurement&#39;: self.__measurement,
        &#39;unit&#39;: self.__unit
    })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.Measurement.from_response" href="#geoengine.types.Measurement.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.DataId"><code class="flex name class">
<span>class <span class="ident">DataId</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for data ids</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataId:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;Base class for data ids&#39;&#39;&#39;
    @classmethod
    def from_response(cls, response: api.DataId) -&gt; DataId:
        &#39;&#39;&#39;Parse an http response to a `DataId` object&#39;&#39;&#39;

        if response[&#34;type&#34;] == &#34;internal&#34;:
            return InternalDataId.from_response_internal(cast(api.InternalDataId, response))
        if response[&#34;type&#34;] == &#34;external&#34;:
            return ExternalDataId.from_response_external(cast(api.ExternalDataId, response))

        raise GeoEngineException({&#34;message&#34;: f&#34;Unknown DataId type: {response[&#39;type&#39;]}&#34;})

    @abstractmethod
    def to_api_dict(self) -&gt; api.DataId:
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geoengine.types.ExternalDataId" href="#geoengine.types.ExternalDataId">ExternalDataId</a></li>
<li><a title="geoengine.types.InternalDataId" href="#geoengine.types.InternalDataId">InternalDataId</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.DataId.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:api.DataId) ><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response(cls, response: api.DataId) -&gt; DataId:
    &#39;&#39;&#39;Parse an http response to a `DataId` object&#39;&#39;&#39;

    if response[&#34;type&#34;] == &#34;internal&#34;:
        return InternalDataId.from_response_internal(cast(api.InternalDataId, response))
    if response[&#34;type&#34;] == &#34;external&#34;:
        return ExternalDataId.from_response_external(cast(api.ExternalDataId, response))

    raise GeoEngineException({&#34;message&#34;: f&#34;Unknown DataId type: {response[&#39;type&#39;]}&#34;})</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.DataId.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.DataId" href="api.html#geoengine.api.DataId">DataId</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_api_dict(self) -&gt; api.DataId:
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.ExternalDataId"><code class="flex name class">
<span>class <span class="ident">ExternalDataId</span></span>
<span>(</span><span>provider_id:UUID, layer_id:str)</span>
</code></dt>
<dd>
<div class="desc"><p>An external data id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExternalDataId(DataId):
    &#39;&#39;&#39;An external data id&#39;&#39;&#39;

    __provider_id: UUID
    __layer_id: str

    def __init__(self, provider_id: UUID, layer_id: str):
        self.__provider_id = provider_id
        self.__layer_id = layer_id

    @classmethod
    def from_response_external(cls, response: api.ExternalDataId) -&gt; ExternalDataId:
        &#39;&#39;&#39;Parse an http response to a `ExternalDataId` object&#39;&#39;&#39;

        return ExternalDataId(UUID(response[&#39;providerId&#39;]), response[&#39;layerId&#39;])

    def to_api_dict(self) -&gt; api.ExternalDataId:
        return api.ExternalDataId({
            &#34;type&#34;: &#34;external&#34;,
            &#34;providerId&#34;: str(self.__provider_id),
            &#34;layerId&#34;: self.__layer_id,
        })

    def __str__(self) -&gt; str:
        return f&#39;{self.__provider_id}:{self.__layer_id}&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of an external data id&#39;&#39;&#39;
        return str(self)

    def __eq__(self, other) -&gt; bool:
        &#39;&#39;&#39;Check if two external data ids are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.__provider_id == other.__provider_id and self.__layer_id == other.__layer_id  # pylint: disable=protected-access</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.ExternalDataId.from_response_external"><code class="name flex">
<span>def <span class="ident">from_response_external</span></span>(<span>response:api.ExternalDataId) ><a title="geoengine.types.ExternalDataId" href="#geoengine.types.ExternalDataId">ExternalDataId</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.ExternalDataId" href="#geoengine.types.ExternalDataId">ExternalDataId</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response_external(cls, response: api.ExternalDataId) -&gt; ExternalDataId:
    &#39;&#39;&#39;Parse an http response to a `ExternalDataId` object&#39;&#39;&#39;

    return ExternalDataId(UUID(response[&#39;providerId&#39;]), response[&#39;layerId&#39;])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.ExternalDataId.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.ExternalDataId" href="api.html#geoengine.api.ExternalDataId">ExternalDataId</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.ExternalDataId:
    return api.ExternalDataId({
        &#34;type&#34;: &#34;external&#34;,
        &#34;providerId&#34;: str(self.__provider_id),
        &#34;layerId&#34;: self.__layer_id,
    })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.DataId.from_response" href="#geoengine.types.DataId.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.FeatureDataType"><code class="flex name class">
<span>class <span class="ident">FeatureDataType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Vector column data type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureDataType(str, Enum):
    &#39;&#39;&#39;Vector column data type&#39;&#39;&#39;

    CATEGORY = &#34;category&#34;
    INT = &#34;int&#34;
    FLOAT = &#34;float&#34;
    TEXT = &#34;text&#34;
    BOOL = &#34;bool&#34;
    DATETIME = &#34;dateTime&#34;

    @staticmethod
    def from_string(data_type: str) -&gt; FeatureDataType:
        &#39;&#39;&#39;Create a new `VectorColumnDataType` from a string&#39;&#39;&#39;

        return FeatureDataType(data_type)

    def to_api_enum(self) -&gt; api.FeatureDataType:
        &#39;&#39;&#39;Convert to an API enum&#39;&#39;&#39;

        return api.FeatureDataType(self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.FeatureDataType.BOOL"><code class="name">var <span class="ident">BOOL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.FeatureDataType.CATEGORY"><code class="name">var <span class="ident">CATEGORY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.FeatureDataType.DATETIME"><code class="name">var <span class="ident">DATETIME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.FeatureDataType.FLOAT"><code class="name">var <span class="ident">FLOAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.FeatureDataType.INT"><code class="name">var <span class="ident">INT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.FeatureDataType.TEXT"><code class="name">var <span class="ident">TEXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.FeatureDataType.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>data_type:str) ><a title="geoengine.types.FeatureDataType" href="#geoengine.types.FeatureDataType">FeatureDataType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code>VectorColumnDataType</code> from a string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_string(data_type: str) -&gt; FeatureDataType:
    &#39;&#39;&#39;Create a new `VectorColumnDataType` from a string&#39;&#39;&#39;

    return FeatureDataType(data_type)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.FeatureDataType.to_api_enum"><code class="name flex">
<span>def <span class="ident">to_api_enum</span></span>(<span>self) ><a title="geoengine.api.FeatureDataType" href="api.html#geoengine.api.FeatureDataType">FeatureDataType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert to an API enum</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_enum(self) -&gt; api.FeatureDataType:
    &#39;&#39;&#39;Convert to an API enum&#39;&#39;&#39;

    return api.FeatureDataType(self.value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.GeoTransform"><code class="flex name class">
<span>class <span class="ident">GeoTransform</span></span>
<span>(</span><span>x_min:float, y_max:float, x_pixel_size:float, y_pixel_size:float)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="geoengine.types.GeoTransform" href="#geoengine.types.GeoTransform">GeoTransform</a></code> specifies the relationship between pixel coordinates and geographic coordinates.</p>
<p>Initialize a new <code><a title="geoengine.types.GeoTransform" href="#geoengine.types.GeoTransform">GeoTransform</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeoTransform:
    &#39;&#39;&#39;The `GeoTransform` specifies the relationship between pixel coordinates and geographic coordinates.&#39;&#39;&#39;

    x_min: float
    y_max: float
    &#39;&#39;&#39;In Geo Engine, x_pixel_size is always positive.&#39;&#39;&#39;
    x_pixel_size: float
    &#39;&#39;&#39;In Geo Engine, y_pixel_size is always negative.&#39;&#39;&#39;
    y_pixel_size: float

    def __init__(self, x_min: float, y_max: float, x_pixel_size: float, y_pixel_size: float):
        &#39;&#39;&#39;Initialize a new `GeoTransform`&#39;&#39;&#39;

        assert x_pixel_size &gt; 0, &#39;In Geo Engine, x_pixel_size is always positive.&#39;
        assert y_pixel_size &lt; 0, &#39;In Geo Engine, y_pixel_size is always negative.&#39;

        self.x_min = x_min
        self.y_max = y_max
        self.x_pixel_size = x_pixel_size
        self.y_pixel_size = y_pixel_size

    @classmethod
    def from_response(cls, response: api.GeoTransform) -&gt; GeoTransform:
        &#39;&#39;&#39;Parse a geotransform from an HTTP JSON response&#39;&#39;&#39;

        return GeoTransform(
            x_min=response[&#39;originCoordinate&#39;][&#39;x&#39;],
            y_max=response[&#39;originCoordinate&#39;][&#39;y&#39;],
            x_pixel_size=response[&#39;xPixelSize&#39;],
            y_pixel_size=response[&#39;yPixelSize&#39;],
        )

    def to_api_dict(self) -&gt; api.GeoTransform:
        return api.GeoTransform({
            &#39;originCoordinate&#39;: {
                &#39;x&#39;: self.x_min,
                &#39;y&#39;: self.y_max,
            },
            &#39;xPixelSize&#39;: self.x_pixel_size,
            &#39;yPixelSize&#39;: self.y_pixel_size
        })

    def __str__(self) -&gt; str:
        return f&#39;Origin: ({self.x_min}, {self.y_max}), &#39; \
            f&#39;X Pixel Size: {self.x_pixel_size}, &#39; \
            f&#39;Y Pixel Size: {self.y_pixel_size}&#39;

    def __repr__(self) -&gt; str:
        return str(self)

    @property
    def x_half_pixel_size(self) -&gt; float:
        return self.x_pixel_size / 2.0

    @property
    def y_half_pixel_size(self) -&gt; float:
        return self.y_pixel_size / 2.0

    def x_max(self, number_of_pixels: int) -&gt; float:
        return self.x_min + number_of_pixels * self.x_pixel_size

    def y_min(self, number_of_pixels: int) -&gt; float:
        return self.y_max + number_of_pixels * self.y_pixel_size</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.GeoTransform.x_min"><code class="name">var <span class="ident">x_min</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.GeoTransform.x_pixel_size"><code class="name">var <span class="ident">x_pixel_size</span> :float</code></dt>
<dd>
<div class="desc"><p>In Geo Engine, y_pixel_size is always negative.</p></div>
</dd>
<dt id="geoengine.types.GeoTransform.y_max"><code class="name">var <span class="ident">y_max</span> :float</code></dt>
<dd>
<div class="desc"><p>In Geo Engine, x_pixel_size is always positive.</p></div>
</dd>
<dt id="geoengine.types.GeoTransform.y_pixel_size"><code class="name">var <span class="ident">y_pixel_size</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.GeoTransform.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:api.GeoTransform) ><a title="geoengine.types.GeoTransform" href="#geoengine.types.GeoTransform">GeoTransform</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a geotransform from an HTTP JSON response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response(cls, response: api.GeoTransform) -&gt; GeoTransform:
    &#39;&#39;&#39;Parse a geotransform from an HTTP JSON response&#39;&#39;&#39;

    return GeoTransform(
        x_min=response[&#39;originCoordinate&#39;][&#39;x&#39;],
        y_max=response[&#39;originCoordinate&#39;][&#39;y&#39;],
        x_pixel_size=response[&#39;xPixelSize&#39;],
        y_pixel_size=response[&#39;yPixelSize&#39;],
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.GeoTransform.x_half_pixel_size"><code class="name">var <span class="ident">x_half_pixel_size</span> :float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x_half_pixel_size(self) -&gt; float:
    return self.x_pixel_size / 2.0</code></pre>
</details>
</dd>
<dt id="geoengine.types.GeoTransform.y_half_pixel_size"><code class="name">var <span class="ident">y_half_pixel_size</span> :float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y_half_pixel_size(self) -&gt; float:
    return self.y_pixel_size / 2.0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.GeoTransform.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.GeoTransform" href="api.html#geoengine.api.GeoTransform">GeoTransform</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.GeoTransform:
    return api.GeoTransform({
        &#39;originCoordinate&#39;: {
            &#39;x&#39;: self.x_min,
            &#39;y&#39;: self.y_max,
        },
        &#39;xPixelSize&#39;: self.x_pixel_size,
        &#39;yPixelSize&#39;: self.y_pixel_size
    })</code></pre>
</details>
</dd>
<dt id="geoengine.types.GeoTransform.x_max"><code class="name flex">
<span>def <span class="ident">x_max</span></span>(<span>self, number_of_pixels:int) >float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x_max(self, number_of_pixels: int) -&gt; float:
    return self.x_min + number_of_pixels * self.x_pixel_size</code></pre>
</details>
</dd>
<dt id="geoengine.types.GeoTransform.y_min"><code class="name flex">
<span>def <span class="ident">y_min</span></span>(<span>self, number_of_pixels:int) >float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def y_min(self, number_of_pixels: int) -&gt; float:
    return self.y_max + number_of_pixels * self.y_pixel_size</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.InternalDataId"><code class="flex name class">
<span>class <span class="ident">InternalDataId</span></span>
<span>(</span><span>dataset_id:UUID)</span>
</code></dt>
<dd>
<div class="desc"><p>An internal data id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InternalDataId(DataId):
    &#39;&#39;&#39;An internal data id&#39;&#39;&#39;

    __dataset_id: UUID

    def __init__(self, dataset_id: UUID):
        self.__dataset_id = dataset_id

    @classmethod
    def from_response_internal(cls, response: api.InternalDataId) -&gt; InternalDataId:
        &#39;&#39;&#39;Parse an http response to a `InternalDataId` object&#39;&#39;&#39;
        return InternalDataId(UUID(response[&#39;datasetId&#39;]))

    def to_api_dict(self) -&gt; api.InternalDataId:
        return api.InternalDataId({
            &#34;type&#34;: &#34;internal&#34;,
            &#34;datasetId&#34;: str(self.__dataset_id)
        })

    def __str__(self) -&gt; str:
        return str(self.__dataset_id)

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of an internal data id&#39;&#39;&#39;
        return str(self)

    def __eq__(self, other) -&gt; bool:
        &#39;&#39;&#39;Check if two internal data ids are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.__dataset_id == other.__dataset_id  # pylint: disable=protected-access</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.InternalDataId.from_response_internal"><code class="name flex">
<span>def <span class="ident">from_response_internal</span></span>(<span>response:api.InternalDataId) ><a title="geoengine.types.InternalDataId" href="#geoengine.types.InternalDataId">InternalDataId</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.InternalDataId" href="#geoengine.types.InternalDataId">InternalDataId</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response_internal(cls, response: api.InternalDataId) -&gt; InternalDataId:
    &#39;&#39;&#39;Parse an http response to a `InternalDataId` object&#39;&#39;&#39;
    return InternalDataId(UUID(response[&#39;datasetId&#39;]))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.InternalDataId.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.InternalDataId" href="api.html#geoengine.api.InternalDataId">InternalDataId</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.InternalDataId:
    return api.InternalDataId({
        &#34;type&#34;: &#34;internal&#34;,
        &#34;datasetId&#34;: str(self.__dataset_id)
    })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.DataId.from_response" href="#geoengine.types.DataId.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.Measurement"><code class="flex name class">
<span>class <span class="ident">Measurement</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for measurements</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Measurement:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;
    Base class for measurements
    &#39;&#39;&#39;

    @staticmethod
    def from_response(response: api.Measurement) -&gt; Measurement:
        &#39;&#39;&#39;
        Parse a result descriptor from an http response
        &#39;&#39;&#39;

        if &#39;error&#39; in response:
            raise GeoEngineException(cast(api.GeoEngineExceptionResponse, response))

        measurement_type = response[&#39;type&#39;]

        if measurement_type == &#39;unitless&#39;:
            return UnitlessMeasurement()
        if measurement_type == &#39;continuous&#39;:
            return ContinuousMeasurement.from_response_continuous(cast(api.ContinuousMeasurement, response))
        if measurement_type == &#39;classification&#39;:
            return ClassificationMeasurement.from_response_classification(cast(api.ClassificationMeasurement, response))

        raise TypeException(
            f&#39;Unknown `Measurement` type: {measurement_type}&#39;)

    @abstractmethod
    def to_api_dict(self) -&gt; api.Measurement:
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geoengine.types.ClassificationMeasurement" href="#geoengine.types.ClassificationMeasurement">ClassificationMeasurement</a></li>
<li><a title="geoengine.types.ContinuousMeasurement" href="#geoengine.types.ContinuousMeasurement">ContinuousMeasurement</a></li>
<li><a title="geoengine.types.UnitlessMeasurement" href="#geoengine.types.UnitlessMeasurement">UnitlessMeasurement</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.Measurement.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:api.Measurement) ><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a result descriptor from an http response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: api.Measurement) -&gt; Measurement:
    &#39;&#39;&#39;
    Parse a result descriptor from an http response
    &#39;&#39;&#39;

    if &#39;error&#39; in response:
        raise GeoEngineException(cast(api.GeoEngineExceptionResponse, response))

    measurement_type = response[&#39;type&#39;]

    if measurement_type == &#39;unitless&#39;:
        return UnitlessMeasurement()
    if measurement_type == &#39;continuous&#39;:
        return ContinuousMeasurement.from_response_continuous(cast(api.ContinuousMeasurement, response))
    if measurement_type == &#39;classification&#39;:
        return ClassificationMeasurement.from_response_classification(cast(api.ClassificationMeasurement, response))

    raise TypeException(
        f&#39;Unknown `Measurement` type: {measurement_type}&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.Measurement.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.Measurement" href="api.html#geoengine.api.Measurement">Measurement</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_api_dict(self) -&gt; api.Measurement:
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.PlotResultDescriptor"><code class="flex name class">
<span>class <span class="ident">PlotResultDescriptor</span></span>
<span>(</span><span>spatial_reference:str, time_bounds:Optional[<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a>]=None, spatial_bounds:Optional[<a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a>]=None, spatial_resolution:Optional[<a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A plot result descriptor</p>
<p>Initialize a new <code><a title="geoengine.types.PlotResultDescriptor" href="#geoengine.types.PlotResultDescriptor">PlotResultDescriptor</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlotResultDescriptor(ResultDescriptor):
    &#39;&#39;&#39;
    A plot result descriptor
    &#39;&#39;&#39;

    __spatial_bounds: Optional[BoundingBox2D]

    def __init__(  # pylint: disable=too-many-arguments]
        self,
        spatial_reference: str,
        time_bounds: Optional[TimeInterval] = None,
        spatial_bounds: Optional[BoundingBox2D] = None,
        spatial_resolution: Optional[SpatialResolution] = None
    ) -&gt; None:
        &#39;&#39;&#39;Initialize a new `PlotResultDescriptor`&#39;&#39;&#39;
        super().__init__(spatial_reference, time_bounds, spatial_resolution)
        self.__spatial_bounds = spatial_bounds

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of the plot result descriptor&#39;&#39;&#39;
        r = &#39;Plot Result&#39;

        return r

    @staticmethod
    def from_response_plot(response: api.PlotResultDescriptor) -&gt; PlotResultDescriptor:
        &#39;&#39;&#39;Create a new `PlotResultDescriptor` from a JSON response&#39;&#39;&#39;
        assert response[&#39;type&#39;] == &#39;plot&#39;  # TODO: throw exception

        spatial_ref = response[&#39;spatialReference&#39;]

        time_bounds = None
        # FIXME: datetime can not represent our min max range
        # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
        #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
        spatial_bounds = None
        if &#39;bbox&#39; in response and response[&#39;bbox&#39;] is not None:
            spatial_bounds = BoundingBox2D.from_response(response[&#39;bbox&#39;])
        spatial_resolution = None
        if &#39;resolution&#39; in response and response[&#39;resolution&#39;] is not None:
            spatial_resolution = SpatialResolution.from_response(response[&#39;resolution&#39;])

        return PlotResultDescriptor(
            spatial_reference=spatial_ref,
            time_bounds=time_bounds,
            spatial_bounds=spatial_bounds,
            spatial_resolution=spatial_resolution
        )

    @classmethod
    def is_plot_result(cls) -&gt; bool:
        return True

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;
        return super().spatial_reference

    @property
    def spatial_bounds(self) -&gt; Optional[BoundingBox2D]:
        return self.__spatial_bounds

    def to_api_dict(self) -&gt; api.PlotResultDescriptor:
        &#39;&#39;&#39;Convert the plot result descriptor to a dictionary&#39;&#39;&#39;

        return api.PlotResultDescriptor({
            &#39;type&#39;: &#39;plot&#39;,
            &#39;spatialReference&#39;: self.spatial_reference,
            &#39;dataType&#39;: &#39;Plot&#39;,
            &#39;time&#39;: self.time_bounds.to_api_dict() if self.time_bounds is not None else None,
            &#39;bbox&#39;: self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
            &#39;resolution&#39;: self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None,
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.PlotResultDescriptor.from_response_plot"><code class="name flex">
<span>def <span class="ident">from_response_plot</span></span>(<span>response:api.PlotResultDescriptor) ><a title="geoengine.types.PlotResultDescriptor" href="#geoengine.types.PlotResultDescriptor">PlotResultDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="geoengine.types.PlotResultDescriptor" href="#geoengine.types.PlotResultDescriptor">PlotResultDescriptor</a></code> from a JSON response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_plot(response: api.PlotResultDescriptor) -&gt; PlotResultDescriptor:
    &#39;&#39;&#39;Create a new `PlotResultDescriptor` from a JSON response&#39;&#39;&#39;
    assert response[&#39;type&#39;] == &#39;plot&#39;  # TODO: throw exception

    spatial_ref = response[&#39;spatialReference&#39;]

    time_bounds = None
    # FIXME: datetime can not represent our min max range
    # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
    #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
    spatial_bounds = None
    if &#39;bbox&#39; in response and response[&#39;bbox&#39;] is not None:
        spatial_bounds = BoundingBox2D.from_response(response[&#39;bbox&#39;])
    spatial_resolution = None
    if &#39;resolution&#39; in response and response[&#39;resolution&#39;] is not None:
        spatial_resolution = SpatialResolution.from_response(response[&#39;resolution&#39;])

    return PlotResultDescriptor(
        spatial_reference=spatial_ref,
        time_bounds=time_bounds,
        spatial_bounds=spatial_bounds,
        spatial_resolution=spatial_resolution
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.PlotResultDescriptor.spatial_bounds"><code class="name">var <span class="ident">spatial_bounds</span> :Optional[<a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_bounds(self) -&gt; Optional[BoundingBox2D]:
    return self.__spatial_bounds</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.PlotResultDescriptor.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.PlotResultDescriptor" href="api.html#geoengine.api.PlotResultDescriptor">PlotResultDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert the plot result descriptor to a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.PlotResultDescriptor:
    &#39;&#39;&#39;Convert the plot result descriptor to a dictionary&#39;&#39;&#39;

    return api.PlotResultDescriptor({
        &#39;type&#39;: &#39;plot&#39;,
        &#39;spatialReference&#39;: self.spatial_reference,
        &#39;dataType&#39;: &#39;Plot&#39;,
        &#39;time&#39;: self.time_bounds.to_api_dict() if self.time_bounds is not None else None,
        &#39;bbox&#39;: self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
        &#39;resolution&#39;: self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None,
    })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.ResultDescriptor.from_response" href="#geoengine.types.ResultDescriptor.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_plot_result" href="#geoengine.types.ResultDescriptor.is_plot_result">is_plot_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_raster_result" href="#geoengine.types.ResultDescriptor.is_raster_result">is_raster_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_vector_result" href="#geoengine.types.ResultDescriptor.is_vector_result">is_vector_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_reference" href="#geoengine.types.ResultDescriptor.spatial_reference">spatial_reference</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_resolution" href="#geoengine.types.ResultDescriptor.spatial_resolution">spatial_resolution</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.time_bounds" href="#geoengine.types.ResultDescriptor.time_bounds">time_bounds</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.Provenance"><code class="flex name class">
<span>class <span class="ident">Provenance</span></span>
<span>(</span><span>citation:str, license:str, uri:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Provenance information as triplet of citation, license and uri</p>
<p>Method generated by attrs for class Provenance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Provenance:
    &#39;&#39;&#39;Provenance information as triplet of citation, license and uri&#39;&#39;&#39;

    citation: str
    license: str
    uri: str

    @classmethod
    def from_response(cls, response: api.Provenance) -&gt; Provenance:
        &#39;&#39;&#39;Parse an http response to a `Provenance` object&#39;&#39;&#39;
        return Provenance(response[&#39;citation&#39;], response[&#39;license&#39;], response[&#39;uri&#39;])

    def to_api_dict(self) -&gt; api.Provenance:
        return api.Provenance({
            &#39;citation&#39;: self.citation,
            &#39;license&#39;: self.license,
            &#39;uri&#39;: self.uri,
        })</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.Provenance.citation"><code class="name">var <span class="ident">citation</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.Provenance.license"><code class="name">var <span class="ident">license</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.Provenance.uri"><code class="name">var <span class="ident">uri</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.Provenance.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:api.Provenance) ><a title="geoengine.types.Provenance" href="#geoengine.types.Provenance">Provenance</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.Provenance" href="#geoengine.types.Provenance">Provenance</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response(cls, response: api.Provenance) -&gt; Provenance:
    &#39;&#39;&#39;Parse an http response to a `Provenance` object&#39;&#39;&#39;
    return Provenance(response[&#39;citation&#39;], response[&#39;license&#39;], response[&#39;uri&#39;])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.Provenance.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.Provenance" href="api.html#geoengine.api.Provenance">Provenance</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.Provenance:
    return api.Provenance({
        &#39;citation&#39;: self.citation,
        &#39;license&#39;: self.license,
        &#39;uri&#39;: self.uri,
    })</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.ProvenanceEntry"><code class="flex name class">
<span>class <span class="ident">ProvenanceEntry</span></span>
<span>(</span><span>data:List[<a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a>], provenance:<a title="geoengine.types.Provenance" href="#geoengine.types.Provenance">Provenance</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Provenance of a dataset</p>
<p>Method generated by attrs for class ProvenanceEntry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ProvenanceEntry:
    &#39;&#39;&#39;Provenance of a dataset&#39;&#39;&#39;

    data: List[DataId]
    provenance: Provenance

    @classmethod
    def from_response(cls, response: api.ProvenanceEntry) -&gt; ProvenanceEntry:
        &#39;&#39;&#39;Parse an http response to a `ProvenanceEntry` object&#39;&#39;&#39;

        dataset = [DataId.from_response(data) for data in response[&#39;data&#39;]]
        provenance = Provenance.from_response(response[&#39;provenance&#39;])

        return ProvenanceEntry(dataset, provenance)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.ProvenanceEntry.data"><code class="name">var <span class="ident">data</span> :List[<a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.ProvenanceEntry.provenance"><code class="name">var <span class="ident">provenance</span> :<a title="geoengine.types.Provenance" href="#geoengine.types.Provenance">Provenance</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.ProvenanceEntry.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:api.ProvenanceEntry) ><a title="geoengine.types.ProvenanceEntry" href="#geoengine.types.ProvenanceEntry">ProvenanceEntry</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.ProvenanceEntry" href="#geoengine.types.ProvenanceEntry">ProvenanceEntry</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response(cls, response: api.ProvenanceEntry) -&gt; ProvenanceEntry:
    &#39;&#39;&#39;Parse an http response to a `ProvenanceEntry` object&#39;&#39;&#39;

    dataset = [DataId.from_response(data) for data in response[&#39;data&#39;]]
    provenance = Provenance.from_response(response[&#39;provenance&#39;])

    return ProvenanceEntry(dataset, provenance)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.QueryRectangle"><code class="flex name class">
<span>class <span class="ident">QueryRectangle</span></span>
<span>(</span><span>spatial_bounds:Union[<a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a>,Tuple[float,float,float,float]], time_interval:Union[<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a>,Tuple[datetime,Optional[datetime]]], resolution:Union[<a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a>,Tuple[float,float]], srs='EPSG:4326')</span>
</code></dt>
<dd>
<div class="desc"><p>A multi-dimensional query rectangle, consisting of spatial and temporal information.</p>
<p>Initialize a new <code><a title="geoengine.types.QueryRectangle" href="#geoengine.types.QueryRectangle">QueryRectangle</a></code> object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spatial_bounds</code></strong></dt>
<dd>The spatial bounds of the query rectangle.
Either a <code><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></code> or a tuple of floats (xmin, ymin, xmax, ymax)</dd>
<dt><strong><code>time_interval</code></strong></dt>
<dd>The time interval of the query rectangle.
Either a <code><a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a></code> or a tuple of <code>datetime.datetime</code> objects (start, end)</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>The spatial resolution of the query rectangle.
Either a <code><a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a></code> or a tuple of floats (x_resolution, y_resolution)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QueryRectangle:
    &#39;&#39;&#39;
    A multi-dimensional query rectangle, consisting of spatial and temporal information.
    &#39;&#39;&#39;

    __spatial_bounds: BoundingBox2D
    __time_interval: TimeInterval
    __resolution: SpatialResolution
    __srs: str

    def __init__(self,
                 spatial_bounds: Union[BoundingBox2D, Tuple[float, float, float, float]],
                 time_interval: Union[TimeInterval, Tuple[datetime, Optional[datetime]]],
                 resolution: Union[SpatialResolution, Tuple[float, float]],
                 srs=&#39;EPSG:4326&#39;) -&gt; None:
        &#34;&#34;&#34;
        Initialize a new `QueryRectangle` object

        Parameters
        ----------
        spatial_bounds
            The spatial bounds of the query rectangle.
            Either a `BoundingBox2D` or a tuple of floats (xmin, ymin, xmax, ymax)
        time_interval
            The time interval of the query rectangle.
            Either a `TimeInterval` or a tuple of `datetime.datetime` objects (start, end)
        resolution
            The spatial resolution of the query rectangle.
            Either a `SpatialResolution` or a tuple of floats (x_resolution, y_resolution)
        &#34;&#34;&#34;

        if not isinstance(spatial_bounds, BoundingBox2D):
            spatial_bounds = BoundingBox2D(*spatial_bounds)
        if not isinstance(time_interval, TimeInterval):
            time_interval = TimeInterval(*time_interval)
        if not isinstance(resolution, SpatialResolution):
            resolution = SpatialResolution(*resolution)

        self.__spatial_bounds = spatial_bounds
        self.__time_interval = time_interval
        self.__resolution = resolution
        self.__srs = srs

    @property
    def bbox_str(self) -&gt; str:
        &#39;&#39;&#39;
        A comma-separated string representation of the spatial bounds
        &#39;&#39;&#39;
        return self.__spatial_bounds.as_bbox_str()

    @property
    def bbox_ogc_str(self) -&gt; str:
        &#39;&#39;&#39;
        A comma-separated string representation of the spatial bounds with OGC axis ordering
        &#39;&#39;&#39;
        y_axis_first = self.__srs == &#34;EPSG:4326&#34;
        return self.__spatial_bounds.as_bbox_str(y_axis_first=y_axis_first)

    @property
    def bbox_ogc(self) -&gt; Tuple[float, float, float, float]:
        &#39;&#39;&#39;
        Return the bbox with OGC axis ordering of the srs
        &#39;&#39;&#39;

        # TODO: properly handle axis order
        y_axis_first = self.__srs == &#34;EPSG:4326&#34;
        return self.__spatial_bounds.as_bbox_tuple(y_axis_first=y_axis_first)

    @property
    def resolution_ogc(self) -&gt; Tuple[float, float]:
        &#39;&#39;&#39;
        Return the resolution in OGC style
        &#39;&#39;&#39;
        # TODO: properly handle axis order
        res = self.__resolution

        # TODO: why is the y resolution in this case negative but not in all other cases?
        if self.__srs == &#34;EPSG:4326&#34;:
            return (-res.y_resolution, res.x_resolution)

        return res.as_tuple()

    @property
    def time(self) -&gt; TimeInterval:
        &#39;&#39;&#39;
        Return the time instance or interval
        &#39;&#39;&#39;
        return self.__time_interval

    @property
    def spatial_bounds(self) -&gt; BoundingBox2D:
        &#39;&#39;&#39;
        Return the spatial bounds
        &#39;&#39;&#39;
        return self.__spatial_bounds

    @property
    def spatial_resolution(self) -&gt; SpatialResolution:
        &#39;&#39;&#39;
        Return the spatial resolution
        &#39;&#39;&#39;
        return self.__resolution

    @property
    def time_str(self) -&gt; str:
        &#39;&#39;&#39;
        Return the time instance or interval as a string representation
        &#39;&#39;&#39;
        return self.time.time_str

    @property
    def srs(self) -&gt; str:
        &#39;&#39;&#39;
        Return the SRS string
        &#39;&#39;&#39;
        return self.__srs

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39; Return a string representation of the query rectangle.&#39;&#39;&#39;
        r = &#39;QueryRectangle( \n&#39;
        r += &#39;    &#39; + repr(self.__spatial_bounds) + &#39;\n&#39;
        r += &#39;    &#39; + repr(self.__time_interval) + &#39;\n&#39;
        r += &#39;    &#39; + repr(self.__resolution) + &#39;\n&#39;
        r += f&#39;    srs={self.__srs} \n&#39;
        r += &#39;)&#39;
        return r</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.QueryRectangle.bbox_ogc"><code class="name">var <span class="ident">bbox_ogc</span> :Tuple[float,float,float,float]</code></dt>
<dd>
<div class="desc"><p>Return the bbox with OGC axis ordering of the srs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bbox_ogc(self) -&gt; Tuple[float, float, float, float]:
    &#39;&#39;&#39;
    Return the bbox with OGC axis ordering of the srs
    &#39;&#39;&#39;

    # TODO: properly handle axis order
    y_axis_first = self.__srs == &#34;EPSG:4326&#34;
    return self.__spatial_bounds.as_bbox_tuple(y_axis_first=y_axis_first)</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.bbox_ogc_str"><code class="name">var <span class="ident">bbox_ogc_str</span> :str</code></dt>
<dd>
<div class="desc"><p>A comma-separated string representation of the spatial bounds with OGC axis ordering</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bbox_ogc_str(self) -&gt; str:
    &#39;&#39;&#39;
    A comma-separated string representation of the spatial bounds with OGC axis ordering
    &#39;&#39;&#39;
    y_axis_first = self.__srs == &#34;EPSG:4326&#34;
    return self.__spatial_bounds.as_bbox_str(y_axis_first=y_axis_first)</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.bbox_str"><code class="name">var <span class="ident">bbox_str</span> :str</code></dt>
<dd>
<div class="desc"><p>A comma-separated string representation of the spatial bounds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bbox_str(self) -&gt; str:
    &#39;&#39;&#39;
    A comma-separated string representation of the spatial bounds
    &#39;&#39;&#39;
    return self.__spatial_bounds.as_bbox_str()</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.resolution_ogc"><code class="name">var <span class="ident">resolution_ogc</span> :Tuple[float,float]</code></dt>
<dd>
<div class="desc"><p>Return the resolution in OGC style</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution_ogc(self) -&gt; Tuple[float, float]:
    &#39;&#39;&#39;
    Return the resolution in OGC style
    &#39;&#39;&#39;
    # TODO: properly handle axis order
    res = self.__resolution

    # TODO: why is the y resolution in this case negative but not in all other cases?
    if self.__srs == &#34;EPSG:4326&#34;:
        return (-res.y_resolution, res.x_resolution)

    return res.as_tuple()</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.spatial_bounds"><code class="name">var <span class="ident">spatial_bounds</span> :<a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></code></dt>
<dd>
<div class="desc"><p>Return the spatial bounds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_bounds(self) -&gt; BoundingBox2D:
    &#39;&#39;&#39;
    Return the spatial bounds
    &#39;&#39;&#39;
    return self.__spatial_bounds</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.spatial_resolution"><code class="name">var <span class="ident">spatial_resolution</span> :<a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a></code></dt>
<dd>
<div class="desc"><p>Return the spatial resolution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_resolution(self) -&gt; SpatialResolution:
    &#39;&#39;&#39;
    Return the spatial resolution
    &#39;&#39;&#39;
    return self.__resolution</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.srs"><code class="name">var <span class="ident">srs</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the SRS string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def srs(self) -&gt; str:
    &#39;&#39;&#39;
    Return the SRS string
    &#39;&#39;&#39;
    return self.__srs</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.time"><code class="name">var <span class="ident">time</span> :<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a></code></dt>
<dd>
<div class="desc"><p>Return the time instance or interval</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time(self) -&gt; TimeInterval:
    &#39;&#39;&#39;
    Return the time instance or interval
    &#39;&#39;&#39;
    return self.__time_interval</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.time_str"><code class="name">var <span class="ident">time_str</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the time instance or interval as a string representation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_str(self) -&gt; str:
    &#39;&#39;&#39;
    Return the time instance or interval as a string representation
    &#39;&#39;&#39;
    return self.time.time_str</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.RasterResultDescriptor"><code class="flex name class">
<span>class <span class="ident">RasterResultDescriptor</span></span>
<span>(</span><span>data_type:"Literal['U8','U16','U32','U64','I8','I16','I32','I64','F32','F64']", measurement:<a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a>, spatial_reference:str, time_bounds:Optional[<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a>]=None, spatial_bounds:Optional[<a title="geoengine.types.SpatialPartition2D" href="#geoengine.types.SpatialPartition2D">SpatialPartition2D</a>]=None, spatial_resolution:Optional[<a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A raster result descriptor</p>
<p>Initialize a new <code><a title="geoengine.types.RasterResultDescriptor" href="#geoengine.types.RasterResultDescriptor">RasterResultDescriptor</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RasterResultDescriptor(ResultDescriptor):
    &#39;&#39;&#39;
    A raster result descriptor
    &#39;&#39;&#39;
    __data_type: Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;]
    __measurement: Measurement
    __spatial_bounds: Optional[SpatialPartition2D]

    def __init__(  # pylint: disable=too-many-arguments
        self,
        data_type: Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;],
        measurement: Measurement,
        spatial_reference: str,
        time_bounds: Optional[TimeInterval] = None,
        spatial_bounds: Optional[SpatialPartition2D] = None,
        spatial_resolution: Optional[SpatialResolution] = None
    ) -&gt; None:
        &#39;&#39;&#39;Initialize a new `RasterResultDescriptor`&#39;&#39;&#39;
        super().__init__(spatial_reference, time_bounds, spatial_resolution)
        self.__data_type = data_type
        self.__measurement = measurement
        self.__spatial_bounds = spatial_bounds

    def to_api_dict(self) -&gt; api.RasterResultDescriptor:
        &#39;&#39;&#39;Convert the raster result descriptor to a dictionary&#39;&#39;&#39;

        return {
            &#39;type&#39;: &#39;raster&#39;,
            &#39;dataType&#39;: self.data_type,
            &#39;measurement&#39;: self.measurement.to_api_dict(),
            &#39;spatialReference&#39;: self.spatial_reference,
            &#39;time&#39;: self.time_bounds.to_api_dict() if self.time_bounds is not None else None,
            &#39;bbox&#39;: self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
            &#39;resolution&#39;: self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None
        }

    @staticmethod
    def from_response_raster(response: api.RasterResultDescriptor) -&gt; RasterResultDescriptor:
        &#39;&#39;&#39;Parse a raster result descriptor from an http response&#39;&#39;&#39;
        assert response[&#39;type&#39;] == &#39;raster&#39;  # TODO: throw exception

        spatial_ref = response[&#39;spatialReference&#39;]
        data_type = response[&#39;dataType&#39;]
        measurement = Measurement.from_response(response[&#39;measurement&#39;])

        time_bounds = None
        # FIXME: datetime can not represent our min max range
        # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
        #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
        spatial_bounds = None
        if &#39;bbox&#39; in response and response[&#39;bbox&#39;] is not None:
            spatial_bounds = SpatialPartition2D.from_response(response[&#39;bbox&#39;])
        spatial_resolution = None
        if &#39;resolution&#39; in response and response[&#39;resolution&#39;] is not None:
            spatial_resolution = SpatialResolution.from_response(response[&#39;resolution&#39;])

        return RasterResultDescriptor(
            data_type=data_type,
            measurement=measurement,
            spatial_reference=spatial_ref,
            time_bounds=time_bounds,
            spatial_bounds=spatial_bounds,
            spatial_resolution=spatial_resolution
        )

    @classmethod
    def is_raster_result(cls) -&gt; bool:
        return True

    @property
    def data_type(self) -&gt; Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;]:
        return self.__data_type

    @property
    def measurement(self) -&gt; Measurement:
        return self.__measurement

    @property
    def spatial_bounds(self) -&gt; Optional[SpatialPartition2D]:
        return self.__spatial_bounds

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;

        return super().spatial_reference

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of the raster result descriptor&#39;&#39;&#39;
        r = &#39;&#39;
        r += f&#39;Data type:         {self.data_type}\n&#39;
        r += f&#39;Spatial Reference: {self.spatial_reference}\n&#39;
        r += f&#39;Measurement:       {self.measurement}\n&#39;

        return r

    def to_json(self) -&gt; api.RasterResultDescriptor:
        return self.to_api_dict()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.RasterResultDescriptor.from_response_raster"><code class="name flex">
<span>def <span class="ident">from_response_raster</span></span>(<span>response:api.RasterResultDescriptor) ><a title="geoengine.types.RasterResultDescriptor" href="#geoengine.types.RasterResultDescriptor">RasterResultDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a raster result descriptor from an http response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_raster(response: api.RasterResultDescriptor) -&gt; RasterResultDescriptor:
    &#39;&#39;&#39;Parse a raster result descriptor from an http response&#39;&#39;&#39;
    assert response[&#39;type&#39;] == &#39;raster&#39;  # TODO: throw exception

    spatial_ref = response[&#39;spatialReference&#39;]
    data_type = response[&#39;dataType&#39;]
    measurement = Measurement.from_response(response[&#39;measurement&#39;])

    time_bounds = None
    # FIXME: datetime can not represent our min max range
    # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
    #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
    spatial_bounds = None
    if &#39;bbox&#39; in response and response[&#39;bbox&#39;] is not None:
        spatial_bounds = SpatialPartition2D.from_response(response[&#39;bbox&#39;])
    spatial_resolution = None
    if &#39;resolution&#39; in response and response[&#39;resolution&#39;] is not None:
        spatial_resolution = SpatialResolution.from_response(response[&#39;resolution&#39;])

    return RasterResultDescriptor(
        data_type=data_type,
        measurement=measurement,
        spatial_reference=spatial_ref,
        time_bounds=time_bounds,
        spatial_bounds=spatial_bounds,
        spatial_resolution=spatial_resolution
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.RasterResultDescriptor.data_type"><code class="name">var <span class="ident">data_type</span> :Literal['U8','U16','U32','U64','I8','I16','I32','I64','F32','F64']</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_type(self) -&gt; Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;]:
    return self.__data_type</code></pre>
</details>
</dd>
<dt id="geoengine.types.RasterResultDescriptor.measurement"><code class="name">var <span class="ident">measurement</span> :<a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def measurement(self) -&gt; Measurement:
    return self.__measurement</code></pre>
</details>
</dd>
<dt id="geoengine.types.RasterResultDescriptor.spatial_bounds"><code class="name">var <span class="ident">spatial_bounds</span> :Optional[<a title="geoengine.types.SpatialPartition2D" href="#geoengine.types.SpatialPartition2D">SpatialPartition2D</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_bounds(self) -&gt; Optional[SpatialPartition2D]:
    return self.__spatial_bounds</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.RasterResultDescriptor.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.RasterResultDescriptor" href="api.html#geoengine.api.RasterResultDescriptor">RasterResultDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert the raster result descriptor to a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.RasterResultDescriptor:
    &#39;&#39;&#39;Convert the raster result descriptor to a dictionary&#39;&#39;&#39;

    return {
        &#39;type&#39;: &#39;raster&#39;,
        &#39;dataType&#39;: self.data_type,
        &#39;measurement&#39;: self.measurement.to_api_dict(),
        &#39;spatialReference&#39;: self.spatial_reference,
        &#39;time&#39;: self.time_bounds.to_api_dict() if self.time_bounds is not None else None,
        &#39;bbox&#39;: self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
        &#39;resolution&#39;: self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None
    }</code></pre>
</details>
</dd>
<dt id="geoengine.types.RasterResultDescriptor.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ><a title="geoengine.api.RasterResultDescriptor" href="api.html#geoengine.api.RasterResultDescriptor">RasterResultDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; api.RasterResultDescriptor:
    return self.to_api_dict()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.ResultDescriptor.from_response" href="#geoengine.types.ResultDescriptor.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_plot_result" href="#geoengine.types.ResultDescriptor.is_plot_result">is_plot_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_raster_result" href="#geoengine.types.ResultDescriptor.is_raster_result">is_raster_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_vector_result" href="#geoengine.types.ResultDescriptor.is_vector_result">is_vector_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_reference" href="#geoengine.types.ResultDescriptor.spatial_reference">spatial_reference</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_resolution" href="#geoengine.types.ResultDescriptor.spatial_resolution">spatial_resolution</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.time_bounds" href="#geoengine.types.ResultDescriptor.time_bounds">time_bounds</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.RasterSymbology"><code class="flex name class">
<span>class <span class="ident">RasterSymbology</span></span>
<span>(</span><span>colorizer:Colorizer, opacity:float=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>A raster symbology</p>
<p>Initialize a new <code><a title="geoengine.types.RasterSymbology" href="#geoengine.types.RasterSymbology">RasterSymbology</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RasterSymbology(Symbology):
    &#39;&#39;&#39;A raster symbology&#39;&#39;&#39;
    __opacity: float
    __colorizer: Colorizer

    def __init__(self, colorizer: Colorizer, opacity: float = 1.0) -&gt; None:
        &#39;&#39;&#39;Initialize a new `RasterSymbology`&#39;&#39;&#39;

        self.__colorizer = colorizer
        self.__opacity = opacity

    def to_api_dict(self) -&gt; api.RasterSymbology:
        &#39;&#39;&#39;Convert the raster symbology to a dictionary&#39;&#39;&#39;

        return api.RasterSymbology({
            &#39;type&#39;: &#39;raster&#39;,
            &#39;colorizer&#39;: self.__colorizer.to_api_dict(),
            &#39;opacity&#39;: self.__opacity,
        })

    @staticmethod
    def from_response_raster(response: api.RasterSymbology) -&gt; RasterSymbology:
        &#39;&#39;&#39;Parse an http response to a `RasterSymbology` object&#39;&#39;&#39;

        colorizer = Colorizer.from_response(response[&#39;colorizer&#39;])

        return RasterSymbology(colorizer, response[&#39;opacity&#39;])

    def __repr__(self) -&gt; str:
        return super().__repr__() + f&#34;({self.__colorizer}, {self.__opacity})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.RasterSymbology.from_response_raster"><code class="name flex">
<span>def <span class="ident">from_response_raster</span></span>(<span>response:api.RasterSymbology) ><a title="geoengine.types.RasterSymbology" href="#geoengine.types.RasterSymbology">RasterSymbology</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.RasterSymbology" href="#geoengine.types.RasterSymbology">RasterSymbology</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_raster(response: api.RasterSymbology) -&gt; RasterSymbology:
    &#39;&#39;&#39;Parse an http response to a `RasterSymbology` object&#39;&#39;&#39;

    colorizer = Colorizer.from_response(response[&#39;colorizer&#39;])

    return RasterSymbology(colorizer, response[&#39;opacity&#39;])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.RasterSymbology.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.RasterSymbology" href="api.html#geoengine.api.RasterSymbology">RasterSymbology</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert the raster symbology to a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.RasterSymbology:
    &#39;&#39;&#39;Convert the raster symbology to a dictionary&#39;&#39;&#39;

    return api.RasterSymbology({
        &#39;type&#39;: &#39;raster&#39;,
        &#39;colorizer&#39;: self.__colorizer.to_api_dict(),
        &#39;opacity&#39;: self.__opacity,
    })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.Symbology.from_response" href="#geoengine.types.Symbology.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.ResultDescriptor"><code class="flex name class">
<span>class <span class="ident">ResultDescriptor</span></span>
<span>(</span><span>spatial_reference:str, time_bounds:Optional[<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a>]=None, spatial_resolution:Optional[<a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for result descriptors</p>
<p>Initialize a new <code><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResultDescriptor:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;
    Base class for result descriptors
    &#39;&#39;&#39;

    __spatial_reference: str
    __time_bounds: Optional[TimeInterval]
    __spatial_resolution: Optional[SpatialResolution]

    def __init__(
        self,
        spatial_reference: str,
        time_bounds: Optional[TimeInterval] = None,
        spatial_resolution: Optional[SpatialResolution] = None
    ) -&gt; None:
        &#39;&#39;&#39;Initialize a new `ResultDescriptor` object&#39;&#39;&#39;

        self.__spatial_reference = spatial_reference
        self.__time_bounds = time_bounds

        if spatial_resolution is None or isinstance(spatial_resolution, SpatialResolution):
            self.__spatial_resolution = spatial_resolution
        else:
            raise TypeException(&#39;Spatial resolution must be of type `SpatialResolution` or `None`&#39;)

    @staticmethod
    def from_response(response: api.ResultDescriptor) -&gt; ResultDescriptor:
        &#39;&#39;&#39;
        Parse a result descriptor from an http response
        &#39;&#39;&#39;

        if &#39;error&#39; in response:
            raise GeoEngineException(cast(api.GeoEngineExceptionResponse, response))

        if &#39;type&#39; not in response:
            raise TypeException(&#39;Response does not contain a `type` field&#39;)

        result_descriptor_type = response[&#39;type&#39;]

        if result_descriptor_type == &#39;raster&#39;:
            return RasterResultDescriptor.from_response_raster(cast(api.RasterResultDescriptor, response))
        if result_descriptor_type == &#39;vector&#39;:
            return VectorResultDescriptor.from_response_vector(cast(api.VectorResultDescriptor, response))
        if result_descriptor_type == &#39;plot&#39;:
            return PlotResultDescriptor.from_response_plot(cast(api.PlotResultDescriptor, response))

        raise TypeException(
            f&#39;Unknown `ResultDescriptor` type: {result_descriptor_type}&#39;)

    @classmethod
    def is_raster_result(cls) -&gt; bool:
        &#39;&#39;&#39;
        Return true if the result is of type raster
        &#39;&#39;&#39;
        return False

    @classmethod
    def is_vector_result(cls) -&gt; bool:
        &#39;&#39;&#39;
        Return true if the result is of type vector
        &#39;&#39;&#39;
        return False

    @classmethod
    def is_plot_result(cls) -&gt; bool:
        &#39;&#39;&#39;
        Return true if the result is of type plot
        &#39;&#39;&#39;

        return False

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;

        return self.__spatial_reference

    @property
    def time_bounds(self) -&gt; Optional[TimeInterval]:
        &#39;&#39;&#39;Return the time bounds&#39;&#39;&#39;

        return self.__time_bounds

    @property
    def spatial_resolution(self) -&gt; Optional[SpatialResolution]:
        &#39;&#39;&#39;Return the spatial resolution&#39;&#39;&#39;

        return self.__spatial_resolution

    @abstractmethod
    def to_api_dict(self) -&gt; api.ResultDescriptor:
        pass

    def __iter__(self):
        return iter(self.to_api_dict().items())</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geoengine.types.PlotResultDescriptor" href="#geoengine.types.PlotResultDescriptor">PlotResultDescriptor</a></li>
<li><a title="geoengine.types.RasterResultDescriptor" href="#geoengine.types.RasterResultDescriptor">RasterResultDescriptor</a></li>
<li><a title="geoengine.types.VectorResultDescriptor" href="#geoengine.types.VectorResultDescriptor">VectorResultDescriptor</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.ResultDescriptor.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:api.ResultDescriptor) ><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a result descriptor from an http response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: api.ResultDescriptor) -&gt; ResultDescriptor:
    &#39;&#39;&#39;
    Parse a result descriptor from an http response
    &#39;&#39;&#39;

    if &#39;error&#39; in response:
        raise GeoEngineException(cast(api.GeoEngineExceptionResponse, response))

    if &#39;type&#39; not in response:
        raise TypeException(&#39;Response does not contain a `type` field&#39;)

    result_descriptor_type = response[&#39;type&#39;]

    if result_descriptor_type == &#39;raster&#39;:
        return RasterResultDescriptor.from_response_raster(cast(api.RasterResultDescriptor, response))
    if result_descriptor_type == &#39;vector&#39;:
        return VectorResultDescriptor.from_response_vector(cast(api.VectorResultDescriptor, response))
    if result_descriptor_type == &#39;plot&#39;:
        return PlotResultDescriptor.from_response_plot(cast(api.PlotResultDescriptor, response))

    raise TypeException(
        f&#39;Unknown `ResultDescriptor` type: {result_descriptor_type}&#39;)</code></pre>
</details>
</dd>
<dt id="geoengine.types.ResultDescriptor.is_plot_result"><code class="name flex">
<span>def <span class="ident">is_plot_result</span></span>(<span>) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the result is of type plot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_plot_result(cls) -&gt; bool:
    &#39;&#39;&#39;
    Return true if the result is of type plot
    &#39;&#39;&#39;

    return False</code></pre>
</details>
</dd>
<dt id="geoengine.types.ResultDescriptor.is_raster_result"><code class="name flex">
<span>def <span class="ident">is_raster_result</span></span>(<span>) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the result is of type raster</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_raster_result(cls) -&gt; bool:
    &#39;&#39;&#39;
    Return true if the result is of type raster
    &#39;&#39;&#39;
    return False</code></pre>
</details>
</dd>
<dt id="geoengine.types.ResultDescriptor.is_vector_result"><code class="name flex">
<span>def <span class="ident">is_vector_result</span></span>(<span>) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the result is of type vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_vector_result(cls) -&gt; bool:
    &#39;&#39;&#39;
    Return true if the result is of type vector
    &#39;&#39;&#39;
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.ResultDescriptor.spatial_reference"><code class="name">var <span class="ident">spatial_reference</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the spatial reference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_reference(self) -&gt; str:
    &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;

    return self.__spatial_reference</code></pre>
</details>
</dd>
<dt id="geoengine.types.ResultDescriptor.spatial_resolution"><code class="name">var <span class="ident">spatial_resolution</span> :Optional[<a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a>]</code></dt>
<dd>
<div class="desc"><p>Return the spatial resolution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_resolution(self) -&gt; Optional[SpatialResolution]:
    &#39;&#39;&#39;Return the spatial resolution&#39;&#39;&#39;

    return self.__spatial_resolution</code></pre>
</details>
</dd>
<dt id="geoengine.types.ResultDescriptor.time_bounds"><code class="name">var <span class="ident">time_bounds</span> :Optional[<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a>]</code></dt>
<dd>
<div class="desc"><p>Return the time bounds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_bounds(self) -&gt; Optional[TimeInterval]:
    &#39;&#39;&#39;Return the time bounds&#39;&#39;&#39;

    return self.__time_bounds</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.ResultDescriptor.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.ResultDescriptor" href="api.html#geoengine.api.ResultDescriptor">ResultDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_api_dict(self) -&gt; api.ResultDescriptor:
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.SpatialBounds"><code class="flex name class">
<span>class <span class="ident">SpatialBounds</span></span>
<span>(</span><span>xmin:float, ymin:float, xmax:float, ymax:float)</span>
</code></dt>
<dd>
<div class="desc"><p>A spatial bounds object</p>
<p>Initialize a new <code><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpatialBounds:
    &#39;&#39;&#39;A spatial bounds object&#39;&#39;&#39;
    xmin: float
    ymin: float
    xmax: float
    ymax: float

    def __init__(self, xmin: float, ymin: float, xmax: float, ymax: float) -&gt; None:
        &#39;&#39;&#39;Initialize a new `SpatialBounds` object&#39;&#39;&#39;
        if (xmin &gt; xmax) or (ymin &gt; ymax):
            raise InputException(&#34;Bbox: Malformed since min must be &lt;= max&#34;)

        self.xmin = xmin
        self.ymin = ymin
        self.xmax = xmax
        self.ymax = ymax

    def as_bbox_str(self, y_axis_first=False) -&gt; str:
        &#39;&#39;&#39;
        A comma-separated string representation of the spatial bounds with OGC axis ordering
        &#39;&#39;&#39;
        bbox_tuple = self.as_bbox_tuple(y_axis_first=y_axis_first)
        return f&#39;{bbox_tuple[0]},{bbox_tuple[1]},{bbox_tuple[2]},{bbox_tuple[3]}&#39;

    def as_bbox_tuple(self, y_axis_first=False) -&gt; Tuple[float, float, float, float]:
        &#39;&#39;&#39;
        Return the bbox with OGC axis ordering of the srs
        &#39;&#39;&#39;

        if y_axis_first:
            return (self.ymin, self.xmin, self.ymax, self.xmax)

        return (self.xmin, self.ymin, self.xmax, self.ymax)

    def x_axis_size(self) -&gt; float:
        &#39;&#39;&#39;The size of the x axis&#39;&#39;&#39;
        return self.xmax - self.xmin

    def y_axis_size(self) -&gt; float:
        &#39;&#39;&#39;The size of the y axis&#39;&#39;&#39;
        return self.ymax - self.ymin</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></li>
<li><a title="geoengine.types.SpatialPartition2D" href="#geoengine.types.SpatialPartition2D">SpatialPartition2D</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.SpatialBounds.xmax"><code class="name">var <span class="ident">xmax</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialBounds.xmin"><code class="name">var <span class="ident">xmin</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialBounds.ymax"><code class="name">var <span class="ident">ymax</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialBounds.ymin"><code class="name">var <span class="ident">ymin</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.SpatialBounds.as_bbox_str"><code class="name flex">
<span>def <span class="ident">as_bbox_str</span></span>(<span>self, y_axis_first=False) >str</span>
</code></dt>
<dd>
<div class="desc"><p>A comma-separated string representation of the spatial bounds with OGC axis ordering</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_bbox_str(self, y_axis_first=False) -&gt; str:
    &#39;&#39;&#39;
    A comma-separated string representation of the spatial bounds with OGC axis ordering
    &#39;&#39;&#39;
    bbox_tuple = self.as_bbox_tuple(y_axis_first=y_axis_first)
    return f&#39;{bbox_tuple[0]},{bbox_tuple[1]},{bbox_tuple[2]},{bbox_tuple[3]}&#39;</code></pre>
</details>
</dd>
<dt id="geoengine.types.SpatialBounds.as_bbox_tuple"><code class="name flex">
<span>def <span class="ident">as_bbox_tuple</span></span>(<span>self, y_axis_first=False) >Tuple[float,float,float,float]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the bbox with OGC axis ordering of the srs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_bbox_tuple(self, y_axis_first=False) -&gt; Tuple[float, float, float, float]:
    &#39;&#39;&#39;
    Return the bbox with OGC axis ordering of the srs
    &#39;&#39;&#39;

    if y_axis_first:
        return (self.ymin, self.xmin, self.ymax, self.xmax)

    return (self.xmin, self.ymin, self.xmax, self.ymax)</code></pre>
</details>
</dd>
<dt id="geoengine.types.SpatialBounds.x_axis_size"><code class="name flex">
<span>def <span class="ident">x_axis_size</span></span>(<span>self) >float</span>
</code></dt>
<dd>
<div class="desc"><p>The size of the x axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x_axis_size(self) -&gt; float:
    &#39;&#39;&#39;The size of the x axis&#39;&#39;&#39;
    return self.xmax - self.xmin</code></pre>
</details>
</dd>
<dt id="geoengine.types.SpatialBounds.y_axis_size"><code class="name flex">
<span>def <span class="ident">y_axis_size</span></span>(<span>self) >float</span>
</code></dt>
<dd>
<div class="desc"><p>The size of the y axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def y_axis_size(self) -&gt; float:
    &#39;&#39;&#39;The size of the y axis&#39;&#39;&#39;
    return self.ymax - self.ymin</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.SpatialPartition2D"><code class="flex name class">
<span>class <span class="ident">SpatialPartition2D</span></span>
<span>(</span><span>xmin:float, ymin:float, xmax:float, ymax:float)</span>
</code></dt>
<dd>
<div class="desc"><p>A 2D spatial partition.</p>
<p>Initialize a new <code><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpatialPartition2D(SpatialBounds):
    &#39;&#39;&#39;A 2D spatial partition.&#39;&#39;&#39;

    @staticmethod
    def from_response(response: api.SpatialPartition2D) -&gt; SpatialPartition2D:
        &#39;&#39;&#39;create a `SpatialPartition2D` from an API response&#39;&#39;&#39;
        if &#39;upperLeftCoordinate&#39; not in response or &#39;lowerRightCoordinate&#39; not in response:
            raise TypeException(&#39;SpatialPartition2D must have upperLeftCoordinate and lowerRightCoordinate&#39;)

        upper_left = response[&#39;upperLeftCoordinate&#39;]
        lower_right = response[&#39;lowerRightCoordinate&#39;]

        return SpatialPartition2D(
            upper_left[&#39;x&#39;],
            lower_right[&#39;y&#39;],
            lower_right[&#39;x&#39;],
            upper_left[&#39;y&#39;],

        )

    def to_api_dict(self) -&gt; api.SpatialPartition2D:
        return api.SpatialPartition2D({
            &#39;upperLeftCoordinate&#39;: api.Coordinate2D({
                &#34;x&#34;: self.xmin,
                &#34;y&#34;: self.ymax,
            }),
            &#39;lowerRightCoordinate&#39;: api.Coordinate2D({
                &#34;x&#34;: self.xmax,
                &#34;y&#34;: self.ymin,
            }),
        })

    def to_bounding_box(self) -&gt; BoundingBox2D:
        &#39;&#39;&#39;convert to a `BoundingBox2D`&#39;&#39;&#39;
        return BoundingBox2D(self.xmin, self.ymin, self.xmax, self.ymax)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.SpatialPartition2D.xmax"><code class="name">var <span class="ident">xmax</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialPartition2D.xmin"><code class="name">var <span class="ident">xmin</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialPartition2D.ymax"><code class="name">var <span class="ident">ymax</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialPartition2D.ymin"><code class="name">var <span class="ident">ymin</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.SpatialPartition2D.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:api.SpatialPartition2D) ><a title="geoengine.types.SpatialPartition2D" href="#geoengine.types.SpatialPartition2D">SpatialPartition2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>create a <code><a title="geoengine.types.SpatialPartition2D" href="#geoengine.types.SpatialPartition2D">SpatialPartition2D</a></code> from an API response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: api.SpatialPartition2D) -&gt; SpatialPartition2D:
    &#39;&#39;&#39;create a `SpatialPartition2D` from an API response&#39;&#39;&#39;
    if &#39;upperLeftCoordinate&#39; not in response or &#39;lowerRightCoordinate&#39; not in response:
        raise TypeException(&#39;SpatialPartition2D must have upperLeftCoordinate and lowerRightCoordinate&#39;)

    upper_left = response[&#39;upperLeftCoordinate&#39;]
    lower_right = response[&#39;lowerRightCoordinate&#39;]

    return SpatialPartition2D(
        upper_left[&#39;x&#39;],
        lower_right[&#39;y&#39;],
        lower_right[&#39;x&#39;],
        upper_left[&#39;y&#39;],

    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.SpatialPartition2D.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.SpatialPartition2D" href="api.html#geoengine.api.SpatialPartition2D">SpatialPartition2D</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.SpatialPartition2D:
    return api.SpatialPartition2D({
        &#39;upperLeftCoordinate&#39;: api.Coordinate2D({
            &#34;x&#34;: self.xmin,
            &#34;y&#34;: self.ymax,
        }),
        &#39;lowerRightCoordinate&#39;: api.Coordinate2D({
            &#34;x&#34;: self.xmax,
            &#34;y&#34;: self.ymin,
        }),
    })</code></pre>
</details>
</dd>
<dt id="geoengine.types.SpatialPartition2D.to_bounding_box"><code class="name flex">
<span>def <span class="ident">to_bounding_box</span></span>(<span>self) ><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>convert to a <code><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_bounding_box(self) -&gt; BoundingBox2D:
    &#39;&#39;&#39;convert to a `BoundingBox2D`&#39;&#39;&#39;
    return BoundingBox2D(self.xmin, self.ymin, self.xmax, self.ymax)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.SpatialBounds.as_bbox_str" href="#geoengine.types.SpatialBounds.as_bbox_str">as_bbox_str</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.as_bbox_tuple" href="#geoengine.types.SpatialBounds.as_bbox_tuple">as_bbox_tuple</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.x_axis_size" href="#geoengine.types.SpatialBounds.x_axis_size">x_axis_size</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.y_axis_size" href="#geoengine.types.SpatialBounds.y_axis_size">y_axis_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.SpatialResolution"><code class="flex name class">
<span>class <span class="ident">SpatialResolution</span></span>
<span>(</span><span>x_resolution:float, y_resolution:float)</span>
</code></dt>
<dd>
<div class="desc"><p>'A spatial resolution.</p>
<p>Initialize a new <code><a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpatialResolution:
    &#39;&#39;&#39;&#39;A spatial resolution.&#39;&#39;&#39;
    x_resolution: float
    y_resolution: float

    def __init__(self, x_resolution: float, y_resolution: float) -&gt; None:
        &#39;&#39;&#39;Initialize a new `SpatialResolution` object&#39;&#39;&#39;
        if x_resolution &lt;= 0 or y_resolution &lt;= 0:
            raise InputException(&#34;Resolution: Must be positive&#34;)

        self.x_resolution = x_resolution
        self.y_resolution = y_resolution

    def to_api_dict(self) -&gt; api.SpatialResolution:
        return api.SpatialResolution({
            &#39;x&#39;: self.x_resolution,
            &#39;y&#39;: self.y_resolution,
        })

    @staticmethod
    def from_response(response: api.SpatialResolution) -&gt; SpatialResolution:
        &#39;&#39;&#39;create a `SpatialResolution` from an API response&#39;&#39;&#39;
        return SpatialResolution(x_resolution=response[&#39;x&#39;], y_resolution=response[&#39;y&#39;])

    def as_tuple(self) -&gt; Tuple[float, float]:
        return (self.x_resolution, self.y_resolution)

    def __str__(self) -&gt; str:
        return str(f&#39;{self.x_resolution},{self.y_resolution}&#39;)

    def __repr__(self) -&gt; str:
        return str(f&#39;SpatialResolution(x={self.x_resolution}, y={self.y_resolution})&#39;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.SpatialResolution.x_resolution"><code class="name">var <span class="ident">x_resolution</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialResolution.y_resolution"><code class="name">var <span class="ident">y_resolution</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.SpatialResolution.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:api.SpatialResolution) ><a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a></span>
</code></dt>
<dd>
<div class="desc"><p>create a <code><a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a></code> from an API response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: api.SpatialResolution) -&gt; SpatialResolution:
    &#39;&#39;&#39;create a `SpatialResolution` from an API response&#39;&#39;&#39;
    return SpatialResolution(x_resolution=response[&#39;x&#39;], y_resolution=response[&#39;y&#39;])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.SpatialResolution.as_tuple"><code class="name flex">
<span>def <span class="ident">as_tuple</span></span>(<span>self) >Tuple[float,float]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_tuple(self) -&gt; Tuple[float, float]:
    return (self.x_resolution, self.y_resolution)</code></pre>
</details>
</dd>
<dt id="geoengine.types.SpatialResolution.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.SpatialResolution" href="api.html#geoengine.api.SpatialResolution">SpatialResolution</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.SpatialResolution:
    return api.SpatialResolution({
        &#39;x&#39;: self.x_resolution,
        &#39;y&#39;: self.y_resolution,
    })</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.Symbology"><code class="flex name class">
<span>class <span class="ident">Symbology</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for symbology</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Symbology:
    &#39;&#39;&#39;Base class for symbology&#39;&#39;&#39;

    @abstractmethod
    def to_api_dict(self) -&gt; api.Symbology:
        pass

    @staticmethod
    def from_response(response: api.Symbology) -&gt; Symbology:
        &#39;&#39;&#39;Parse an http response to a `Symbology` object&#39;&#39;&#39;

        if response[&#39;type&#39;] == &#39;vector&#39;:
            # return VectorSymbology.from_response_vector(response)
            return VectorSymbology()  # TODO: implement
        if response[&#39;type&#39;] == &#39;raster&#39;:
            return RasterSymbology.from_response_raster(cast(api.RasterSymbology, response))

        raise InputException(&#34;Invalid symbology type&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geoengine.types.RasterSymbology" href="#geoengine.types.RasterSymbology">RasterSymbology</a></li>
<li><a title="geoengine.types.VectorSymbology" href="#geoengine.types.VectorSymbology">VectorSymbology</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.Symbology.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:api.Symbology) ><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: api.Symbology) -&gt; Symbology:
    &#39;&#39;&#39;Parse an http response to a `Symbology` object&#39;&#39;&#39;

    if response[&#39;type&#39;] == &#39;vector&#39;:
        # return VectorSymbology.from_response_vector(response)
        return VectorSymbology()  # TODO: implement
    if response[&#39;type&#39;] == &#39;raster&#39;:
        return RasterSymbology.from_response_raster(cast(api.RasterSymbology, response))

    raise InputException(&#34;Invalid symbology type&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.Symbology.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.Symbology" href="api.html#geoengine.api.Symbology">Symbology</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_api_dict(self) -&gt; api.Symbology:
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.TimeInterval"><code class="flex name class">
<span>class <span class="ident">TimeInterval</span></span>
<span>(</span><span>start:datetime, end:Optional[datetime]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>'A time interval.</p>
<p>Initialize a new <code><a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeInterval:
    &#39;&#39;&#39;&#39;A time interval.&#39;&#39;&#39;
    start: datetime
    end: Optional[datetime]

    def __init__(self, start: datetime, end: Optional[datetime] = None) -&gt; None:
        &#39;&#39;&#39;Initialize a new `TimeInterval` object&#39;&#39;&#39;

        if not isinstance(start, datetime) or not isinstance(end, (datetime, type(None))):
            raise InputException(&#34;`start` and `end` must be of type `datetime.datetime`&#34;)

        # We assume that a datetime without a timezone means UTC
        if start.tzinfo is None:
            start = start.replace(tzinfo=timezone.utc)
        if end is not None and end.tzinfo is None:
            end = end.replace(tzinfo=timezone.utc)

        # Check validity of time interval if an `end` exists
        if end is not None and start &gt; end:
            raise InputException(&#34;Time inverval: Start must be &lt;= End&#34;)

        self.start = start
        self.end = end

    def is_instant(self) -&gt; bool:
        return self.end is None

    def to_api_dict(self, as_millis=False) -&gt; api.TimeInterval:
        &#39;&#39;&#39;convert to a dict that can be used in the API&#39;&#39;&#39;
        if as_millis:
            return api.TimeInterval({
                &#39;start&#39;: int(self.start.timestamp() * 1000),
                &#39;end&#39;: int(self.end.timestamp() * 1000) if self.end is not None else None,
            })

        return api.TimeInterval({
            &#39;start&#39;: self.start.isoformat(timespec=&#39;milliseconds&#39;),
            &#39;end&#39;: self.end.isoformat(timespec=&#39;milliseconds&#39;) if self.end is not None else None,
        })

    @property
    def time_str(self) -&gt; str:
        &#39;&#39;&#39;
        Return the time instance or interval as a string representation
        &#39;&#39;&#39;
        if self.end is None or self.start == self.end:
            return self.start.isoformat(timespec=&#39;milliseconds&#39;)
        return self.start.isoformat(timespec=&#39;milliseconds&#39;) + &#39;/&#39; + self.end.isoformat(timespec=&#39;milliseconds&#39;)

    @staticmethod
    def from_response(response: api.TimeInterval) -&gt; TimeInterval:
        &#39;&#39;&#39;create a `TimeInterval` from an API response&#39;&#39;&#39;

        if &#39;start&#39; not in response:
            raise TypeException(&#39;TimeInterval must have a start&#39;)

        if isinstance(response[&#39;start&#39;], int):
            start = cast(int, response[&#39;start&#39;])
            end = cast(int, response[&#39;end&#39;]) if &#39;end&#39; in response and response[&#39;end&#39;] is not None else None

            return TimeInterval(
                datetime.fromtimestamp(start / 1000),
                datetime.fromtimestamp(end / 1000) if end is not None else None,
            )

        start_str = cast(str, response[&#39;start&#39;])
        end_str = cast(str, response[&#39;end&#39;]) if &#39;end&#39; in response and response[&#39;end&#39;] is not None else None

        return TimeInterval(
            datetime.fromisoformat(start_str),
            datetime.fromisoformat(end_str) if end_str is not None else None,
        )

    def __repr__(self) -&gt; str:
        return f&#34;TimeInterval(start={self.start}, end={self.end})&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.TimeInterval.end"><code class="name">var <span class="ident">end</span> :Optional[datetime.datetime]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeInterval.start"><code class="name">var <span class="ident">start</span> :datetime.datetime</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.TimeInterval.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:api.TimeInterval) ><a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a></span>
</code></dt>
<dd>
<div class="desc"><p>create a <code><a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a></code> from an API response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: api.TimeInterval) -&gt; TimeInterval:
    &#39;&#39;&#39;create a `TimeInterval` from an API response&#39;&#39;&#39;

    if &#39;start&#39; not in response:
        raise TypeException(&#39;TimeInterval must have a start&#39;)

    if isinstance(response[&#39;start&#39;], int):
        start = cast(int, response[&#39;start&#39;])
        end = cast(int, response[&#39;end&#39;]) if &#39;end&#39; in response and response[&#39;end&#39;] is not None else None

        return TimeInterval(
            datetime.fromtimestamp(start / 1000),
            datetime.fromtimestamp(end / 1000) if end is not None else None,
        )

    start_str = cast(str, response[&#39;start&#39;])
    end_str = cast(str, response[&#39;end&#39;]) if &#39;end&#39; in response and response[&#39;end&#39;] is not None else None

    return TimeInterval(
        datetime.fromisoformat(start_str),
        datetime.fromisoformat(end_str) if end_str is not None else None,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.TimeInterval.time_str"><code class="name">var <span class="ident">time_str</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the time instance or interval as a string representation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_str(self) -&gt; str:
    &#39;&#39;&#39;
    Return the time instance or interval as a string representation
    &#39;&#39;&#39;
    if self.end is None or self.start == self.end:
        return self.start.isoformat(timespec=&#39;milliseconds&#39;)
    return self.start.isoformat(timespec=&#39;milliseconds&#39;) + &#39;/&#39; + self.end.isoformat(timespec=&#39;milliseconds&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.TimeInterval.is_instant"><code class="name flex">
<span>def <span class="ident">is_instant</span></span>(<span>self) >bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_instant(self) -&gt; bool:
    return self.end is None</code></pre>
</details>
</dd>
<dt id="geoengine.types.TimeInterval.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self, as_millis=False) ><a title="geoengine.api.TimeInterval" href="api.html#geoengine.api.TimeInterval">TimeInterval</a></span>
</code></dt>
<dd>
<div class="desc"><p>convert to a dict that can be used in the API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self, as_millis=False) -&gt; api.TimeInterval:
    &#39;&#39;&#39;convert to a dict that can be used in the API&#39;&#39;&#39;
    if as_millis:
        return api.TimeInterval({
            &#39;start&#39;: int(self.start.timestamp() * 1000),
            &#39;end&#39;: int(self.end.timestamp() * 1000) if self.end is not None else None,
        })

    return api.TimeInterval({
        &#39;start&#39;: self.start.isoformat(timespec=&#39;milliseconds&#39;),
        &#39;end&#39;: self.end.isoformat(timespec=&#39;milliseconds&#39;) if self.end is not None else None,
    })</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.TimeStep"><code class="flex name class">
<span>class <span class="ident">TimeStep</span></span>
<span>(</span><span>step:int, granularity:<a title="geoengine.types.TimeStepGranularity" href="#geoengine.types.TimeStepGranularity">TimeStepGranularity</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A time step that consists of a granularity and a step size</p>
<p>Method generated by attrs for class TimeStep.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class TimeStep:
    &#39;&#39;&#39;A time step that consists of a granularity and a step size&#39;&#39;&#39;
    step: int
    granularity: TimeStepGranularity

    def to_api_dict(self) -&gt; api.TimeStep:
        return api.TimeStep({
            &#39;step&#39;: self.step,
            &#39;granularity&#39;: self.granularity.to_api_enum(),
        })</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.TimeStep.granularity"><code class="name">var <span class="ident">granularity</span> :<a title="geoengine.types.TimeStepGranularity" href="#geoengine.types.TimeStepGranularity">TimeStepGranularity</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStep.step"><code class="name">var <span class="ident">step</span> :int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.TimeStep.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.TimeStep" href="api.html#geoengine.api.TimeStep">TimeStep</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.TimeStep:
    return api.TimeStep({
        &#39;step&#39;: self.step,
        &#39;granularity&#39;: self.granularity.to_api_enum(),
    })</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.TimeStepGranularity"><code class="flex name class">
<span>class <span class="ident">TimeStepGranularity</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enum of time step granularities</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeStepGranularity(Enum):
    &#39;&#39;&#39;An enum of time step granularities&#39;&#39;&#39;
    MILLIS = &#39;Millis&#39;
    SECONDS = &#39;Seconds&#39;
    MINUTES = &#39;Minutes&#39;
    HOURS = &#39;Hours&#39;
    DAYS = &#39;Days&#39;
    MONTHS = &#39;Months&#39;
    YEARS = &#39;Years&#39;

    def to_api_enum(self) -&gt; api.TimeStepGranularity:
        return api.TimeStepGranularity(self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.TimeStepGranularity.DAYS"><code class="name">var <span class="ident">DAYS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStepGranularity.HOURS"><code class="name">var <span class="ident">HOURS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStepGranularity.MILLIS"><code class="name">var <span class="ident">MILLIS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStepGranularity.MINUTES"><code class="name">var <span class="ident">MINUTES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStepGranularity.MONTHS"><code class="name">var <span class="ident">MONTHS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStepGranularity.SECONDS"><code class="name">var <span class="ident">SECONDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStepGranularity.YEARS"><code class="name">var <span class="ident">YEARS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.TimeStepGranularity.to_api_enum"><code class="name flex">
<span>def <span class="ident">to_api_enum</span></span>(<span>self) ><a title="geoengine.api.TimeStepGranularity" href="api.html#geoengine.api.TimeStepGranularity">TimeStepGranularity</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_enum(self) -&gt; api.TimeStepGranularity:
    return api.TimeStepGranularity(self.value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.UnitlessMeasurement"><code class="flex name class">
<span>class <span class="ident">UnitlessMeasurement</span></span>
</code></dt>
<dd>
<div class="desc"><p>A measurement that is unitless</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnitlessMeasurement(Measurement):
    &#39;&#39;&#39;A measurement that is unitless&#39;&#39;&#39;

    def __str__(self) -&gt; str:
        &#39;&#39;&#39;String representation of a unitless measurement&#39;&#39;&#39;
        return &#39;unitless&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a unitless measurement&#39;&#39;&#39;
        return str(self)

    def to_api_dict(self) -&gt; api.Measurement:
        return api.Measurement({
            &#39;type&#39;: &#39;unitless&#39;
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.UnitlessMeasurement.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.Measurement" href="api.html#geoengine.api.Measurement">Measurement</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.Measurement:
    return api.Measurement({
        &#39;type&#39;: &#39;unitless&#39;
    })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.Measurement.from_response" href="#geoengine.types.Measurement.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.VectorColumnInfo"><code class="flex name class">
<span>class <span class="ident">VectorColumnInfo</span></span>
<span>(</span><span>data_type:<a title="geoengine.types.FeatureDataType" href="#geoengine.types.FeatureDataType">FeatureDataType</a>, measurement:<a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Vector column information</p>
<p>Method generated by attrs for class VectorColumnInfo.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class VectorColumnInfo:
    &#39;&#39;&#39;Vector column information&#39;&#39;&#39;

    data_type: FeatureDataType
    measurement: Measurement

    @staticmethod
    def from_response(response: api.VectorColumnInfo) -&gt; VectorColumnInfo:
        &#39;&#39;&#39;Create a new `VectorColumnInfo` from a JSON response&#39;&#39;&#39;

        return VectorColumnInfo(
            FeatureDataType.from_string(response[&#39;dataType&#39;]),
            Measurement.from_response(response[&#39;measurement&#39;])
        )

    def to_api_dict(self) -&gt; api.VectorColumnInfo:
        &#39;&#39;&#39;Convert to a dictionary&#39;&#39;&#39;

        return api.VectorColumnInfo({
            &#39;dataType&#39;: self.data_type.to_api_enum(),
            &#39;measurement&#39;: self.measurement.to_api_dict(),
        })</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.VectorColumnInfo.data_type"><code class="name">var <span class="ident">data_type</span> :<a title="geoengine.types.FeatureDataType" href="#geoengine.types.FeatureDataType">FeatureDataType</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.VectorColumnInfo.measurement"><code class="name">var <span class="ident">measurement</span> :<a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.VectorColumnInfo.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:api.VectorColumnInfo) ><a title="geoengine.types.VectorColumnInfo" href="#geoengine.types.VectorColumnInfo">VectorColumnInfo</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="geoengine.types.VectorColumnInfo" href="#geoengine.types.VectorColumnInfo">VectorColumnInfo</a></code> from a JSON response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: api.VectorColumnInfo) -&gt; VectorColumnInfo:
    &#39;&#39;&#39;Create a new `VectorColumnInfo` from a JSON response&#39;&#39;&#39;

    return VectorColumnInfo(
        FeatureDataType.from_string(response[&#39;dataType&#39;]),
        Measurement.from_response(response[&#39;measurement&#39;])
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.VectorColumnInfo.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.VectorColumnInfo" href="api.html#geoengine.api.VectorColumnInfo">VectorColumnInfo</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert to a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.VectorColumnInfo:
    &#39;&#39;&#39;Convert to a dictionary&#39;&#39;&#39;

    return api.VectorColumnInfo({
        &#39;dataType&#39;: self.data_type.to_api_enum(),
        &#39;measurement&#39;: self.measurement.to_api_dict(),
    })</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.VectorDataType"><code class="flex name class">
<span>class <span class="ident">VectorDataType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enum of vector data types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VectorDataType(str, Enum):
    &#39;&#39;&#39;An enum of vector data types&#39;&#39;&#39;

    DATA = &#39;Data&#39;
    MULTI_POINT = &#39;MultiPoint&#39;
    MULTI_LINE_STRING = &#39;MultiLineString&#39;
    MULTI_POLYGON = &#39;MultiPolygon&#39;

    @classmethod
    def from_geopandas_type_name(cls, name: str) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from geopandas geometry type&#39;&#39;&#39;

        name_map = {
            &#34;Point&#34;: VectorDataType.MULTI_POINT,
            &#34;MultiPoint&#34;: VectorDataType.MULTI_POINT,
            &#34;Line&#34;: VectorDataType.MULTI_LINE_STRING,
            &#34;MultiLine&#34;: VectorDataType.MULTI_LINE_STRING,
            &#34;Polygon&#34;: VectorDataType.MULTI_POLYGON,
            &#34;MultiPolygon&#34;: VectorDataType.MULTI_POLYGON,
        }

        if name in name_map:
            return name_map[name]

        raise InputException(&#34;Invalid vector data type&#34;)

    def to_api_enum(self) -&gt; api.VectorDataType:
        return api.VectorDataType(self.value)

    @staticmethod
    def from_literal(literal: Literal[&#39;Data&#39;, &#39;MultiPoint&#39;, &#39;MultiLineString&#39;, &#39;MultiPolygon&#39;]) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from literal&#39;&#39;&#39;
        return VectorDataType(literal)

    @staticmethod
    def from_api_enum(data_type: api.VectorDataType) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from API enum&#39;&#39;&#39;
        return VectorDataType(data_type.value)

    @staticmethod
    def from_string(string: str) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from string&#39;&#39;&#39;
        if string not in VectorDataType.__members__.values():
            raise InputException(&#34;Invalid vector data type: &#34; + string)
        return VectorDataType(string)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.VectorDataType.DATA"><code class="name">var <span class="ident">DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.VectorDataType.MULTI_LINE_STRING"><code class="name">var <span class="ident">MULTI_LINE_STRING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.VectorDataType.MULTI_POINT"><code class="name">var <span class="ident">MULTI_POINT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.VectorDataType.MULTI_POLYGON"><code class="name">var <span class="ident">MULTI_POLYGON</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.VectorDataType.from_api_enum"><code class="name flex">
<span>def <span class="ident">from_api_enum</span></span>(<span>data_type:api.VectorDataType) ><a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve vector data type from API enum</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_api_enum(data_type: api.VectorDataType) -&gt; VectorDataType:
    &#39;&#39;&#39;Resolve vector data type from API enum&#39;&#39;&#39;
    return VectorDataType(data_type.value)</code></pre>
</details>
</dd>
<dt id="geoengine.types.VectorDataType.from_geopandas_type_name"><code class="name flex">
<span>def <span class="ident">from_geopandas_type_name</span></span>(<span>name:str) ><a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve vector data type from geopandas geometry type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_geopandas_type_name(cls, name: str) -&gt; VectorDataType:
    &#39;&#39;&#39;Resolve vector data type from geopandas geometry type&#39;&#39;&#39;

    name_map = {
        &#34;Point&#34;: VectorDataType.MULTI_POINT,
        &#34;MultiPoint&#34;: VectorDataType.MULTI_POINT,
        &#34;Line&#34;: VectorDataType.MULTI_LINE_STRING,
        &#34;MultiLine&#34;: VectorDataType.MULTI_LINE_STRING,
        &#34;Polygon&#34;: VectorDataType.MULTI_POLYGON,
        &#34;MultiPolygon&#34;: VectorDataType.MULTI_POLYGON,
    }

    if name in name_map:
        return name_map[name]

    raise InputException(&#34;Invalid vector data type&#34;)</code></pre>
</details>
</dd>
<dt id="geoengine.types.VectorDataType.from_literal"><code class="name flex">
<span>def <span class="ident">from_literal</span></span>(<span>literal:"Literal['Data','MultiPoint','MultiLineString','MultiPolygon']") ><a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve vector data type from literal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_literal(literal: Literal[&#39;Data&#39;, &#39;MultiPoint&#39;, &#39;MultiLineString&#39;, &#39;MultiPolygon&#39;]) -&gt; VectorDataType:
    &#39;&#39;&#39;Resolve vector data type from literal&#39;&#39;&#39;
    return VectorDataType(literal)</code></pre>
</details>
</dd>
<dt id="geoengine.types.VectorDataType.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>string:str) ><a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve vector data type from string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_string(string: str) -&gt; VectorDataType:
    &#39;&#39;&#39;Resolve vector data type from string&#39;&#39;&#39;
    if string not in VectorDataType.__members__.values():
        raise InputException(&#34;Invalid vector data type: &#34; + string)
    return VectorDataType(string)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.VectorDataType.to_api_enum"><code class="name flex">
<span>def <span class="ident">to_api_enum</span></span>(<span>self) ><a title="geoengine.api.VectorDataType" href="api.html#geoengine.api.VectorDataType">VectorDataType</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_enum(self) -&gt; api.VectorDataType:
    return api.VectorDataType(self.value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.VectorResultDescriptor"><code class="flex name class">
<span>class <span class="ident">VectorResultDescriptor</span></span>
<span>(</span><span>spatial_reference:str, data_type:<a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a>, columns:Dict[str,<a title="geoengine.types.VectorColumnInfo" href="#geoengine.types.VectorColumnInfo">VectorColumnInfo</a>], time_bounds:Optional[<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a>]=None, spatial_bounds:Optional[<a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a>]=None, spatial_resolution:Optional[<a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A vector result descriptor</p>
<p>Initialize a vector result descriptor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VectorResultDescriptor(ResultDescriptor):
    &#39;&#39;&#39;
    A vector result descriptor
    &#39;&#39;&#39;
    __spatial_bounds: Optional[BoundingBox2D]
    __data_type: VectorDataType
    __columns: Dict[str, VectorColumnInfo]

    def __init__(  # pylint: disable=too-many-arguments
        self,
        spatial_reference: str,
        data_type: VectorDataType,
        columns: Dict[str, VectorColumnInfo],
        time_bounds: Optional[TimeInterval] = None,
        spatial_bounds: Optional[BoundingBox2D] = None,
        spatial_resolution: Optional[SpatialResolution] = None
    ) -&gt; None:
        &#39;&#39;&#39; Initialize a vector result descriptor &#39;&#39;&#39;
        super().__init__(spatial_reference, time_bounds, spatial_resolution)
        self.__data_type = data_type
        self.__columns = columns
        self.__spatial_bounds = spatial_bounds

    @staticmethod
    def from_response_vector(response: api.VectorResultDescriptor) -&gt; VectorResultDescriptor:
        &#39;&#39;&#39;Parse a vector result descriptor from an http response&#39;&#39;&#39;
        assert response[&#39;type&#39;] == &#39;vector&#39;  # TODO: throw exception

        sref = response[&#39;spatialReference&#39;]
        data_type = VectorDataType.from_string(response[&#39;dataType&#39;])
        columns = {name: VectorColumnInfo.from_response(info) for name, info in response[&#39;columns&#39;].items()}

        time_bounds = None
        # FIXME: datetime can not represent our min max range
        # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
        #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
        spatial_bounds = None
        if &#39;bbox&#39; in response and response[&#39;bbox&#39;] is not None:
            spatial_bounds = BoundingBox2D.from_response(response[&#39;bbox&#39;])
        spatial_resolution = None
        if &#39;resolution&#39; in response and response[&#39;resolution&#39;] is not None:
            spatial_resolution = SpatialResolution.from_response(response[&#39;resolution&#39;])

        return VectorResultDescriptor(sref, data_type, columns, time_bounds, spatial_bounds, spatial_resolution)

    @classmethod
    def is_vector_result(cls) -&gt; bool:
        return True

    @property
    def data_type(self) -&gt; VectorDataType:
        &#39;&#39;&#39;Return the data type&#39;&#39;&#39;
        return self.__data_type

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;
        return super().spatial_reference

    @property
    def columns(self) -&gt; Dict[str, VectorColumnInfo]:
        &#39;&#39;&#39;Return the columns&#39;&#39;&#39;

        return self.__columns

    @property
    def spatial_bounds(self) -&gt; Optional[BoundingBox2D]:
        &#39;&#39;&#39;Return the spatial bounds&#39;&#39;&#39;
        return self.__spatial_bounds

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of the vector result descriptor&#39;&#39;&#39;
        r = &#39;&#39;
        r += f&#39;Data type:         {self.data_type.value}\n&#39;
        r += f&#39;Spatial Reference: {self.spatial_reference}\n&#39;

        r += &#39;Columns:\n&#39;
        for column_name in self.columns:
            column_info = self.columns[column_name]
            r += f&#39;  {column_name}:\n&#39;
            r += f&#39;    Column Type: {column_info.data_type.value}\n&#39;
            r += f&#39;    Measurement: {column_info.measurement}\n&#39;

        return r

    def to_api_dict(self) -&gt; api.VectorResultDescriptor:
        &#39;&#39;&#39;Convert the vector result descriptor to a dictionary&#39;&#39;&#39;

        return api.VectorResultDescriptor({
            &#39;type&#39;: &#39;raster&#39;,
            &#39;dataType&#39;: self.data_type.to_api_enum(),
            &#39;spatialReference&#39;: self.spatial_reference,
            &#39;columns&#39;:
                {name: column_info.to_api_dict() for name, column_info in self.columns.items()},
            &#39;time&#39;: self.time_bounds.to_api_dict() if self.time_bounds is not None else None,
            &#39;bbox&#39;: self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
            &#39;resolution&#39;: self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None,
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.VectorResultDescriptor.from_response_vector"><code class="name flex">
<span>def <span class="ident">from_response_vector</span></span>(<span>response:api.VectorResultDescriptor) ><a title="geoengine.types.VectorResultDescriptor" href="#geoengine.types.VectorResultDescriptor">VectorResultDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a vector result descriptor from an http response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_vector(response: api.VectorResultDescriptor) -&gt; VectorResultDescriptor:
    &#39;&#39;&#39;Parse a vector result descriptor from an http response&#39;&#39;&#39;
    assert response[&#39;type&#39;] == &#39;vector&#39;  # TODO: throw exception

    sref = response[&#39;spatialReference&#39;]
    data_type = VectorDataType.from_string(response[&#39;dataType&#39;])
    columns = {name: VectorColumnInfo.from_response(info) for name, info in response[&#39;columns&#39;].items()}

    time_bounds = None
    # FIXME: datetime can not represent our min max range
    # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
    #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
    spatial_bounds = None
    if &#39;bbox&#39; in response and response[&#39;bbox&#39;] is not None:
        spatial_bounds = BoundingBox2D.from_response(response[&#39;bbox&#39;])
    spatial_resolution = None
    if &#39;resolution&#39; in response and response[&#39;resolution&#39;] is not None:
        spatial_resolution = SpatialResolution.from_response(response[&#39;resolution&#39;])

    return VectorResultDescriptor(sref, data_type, columns, time_bounds, spatial_bounds, spatial_resolution)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.VectorResultDescriptor.columns"><code class="name">var <span class="ident">columns</span> :Dict[str,<a title="geoengine.types.VectorColumnInfo" href="#geoengine.types.VectorColumnInfo">VectorColumnInfo</a>]</code></dt>
<dd>
<div class="desc"><p>Return the columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def columns(self) -&gt; Dict[str, VectorColumnInfo]:
    &#39;&#39;&#39;Return the columns&#39;&#39;&#39;

    return self.__columns</code></pre>
</details>
</dd>
<dt id="geoengine.types.VectorResultDescriptor.data_type"><code class="name">var <span class="ident">data_type</span> :<a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a></code></dt>
<dd>
<div class="desc"><p>Return the data type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_type(self) -&gt; VectorDataType:
    &#39;&#39;&#39;Return the data type&#39;&#39;&#39;
    return self.__data_type</code></pre>
</details>
</dd>
<dt id="geoengine.types.VectorResultDescriptor.spatial_bounds"><code class="name">var <span class="ident">spatial_bounds</span> :Optional[<a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a>]</code></dt>
<dd>
<div class="desc"><p>Return the spatial bounds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_bounds(self) -&gt; Optional[BoundingBox2D]:
    &#39;&#39;&#39;Return the spatial bounds&#39;&#39;&#39;
    return self.__spatial_bounds</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.VectorResultDescriptor.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.VectorResultDescriptor" href="api.html#geoengine.api.VectorResultDescriptor">VectorResultDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Convert the vector result descriptor to a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.VectorResultDescriptor:
    &#39;&#39;&#39;Convert the vector result descriptor to a dictionary&#39;&#39;&#39;

    return api.VectorResultDescriptor({
        &#39;type&#39;: &#39;raster&#39;,
        &#39;dataType&#39;: self.data_type.to_api_enum(),
        &#39;spatialReference&#39;: self.spatial_reference,
        &#39;columns&#39;:
            {name: column_info.to_api_dict() for name, column_info in self.columns.items()},
        &#39;time&#39;: self.time_bounds.to_api_dict() if self.time_bounds is not None else None,
        &#39;bbox&#39;: self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
        &#39;resolution&#39;: self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None,
    })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.ResultDescriptor.from_response" href="#geoengine.types.ResultDescriptor.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_plot_result" href="#geoengine.types.ResultDescriptor.is_plot_result">is_plot_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_raster_result" href="#geoengine.types.ResultDescriptor.is_raster_result">is_raster_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_vector_result" href="#geoengine.types.ResultDescriptor.is_vector_result">is_vector_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_reference" href="#geoengine.types.ResultDescriptor.spatial_reference">spatial_reference</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_resolution" href="#geoengine.types.ResultDescriptor.spatial_resolution">spatial_resolution</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.time_bounds" href="#geoengine.types.ResultDescriptor.time_bounds">time_bounds</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.VectorSymbology"><code class="flex name class">
<span>class <span class="ident">VectorSymbology</span></span>
</code></dt>
<dd>
<div class="desc"><p>A vector symbology</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VectorSymbology(Symbology):
    &#39;&#39;&#39;A vector symbology&#39;&#39;&#39;

    # TODO: implement

    def to_api_dict(self) -&gt; api.Symbology:
        return api.Symbology({
            &#39;type&#39;: &#39;vector&#39;,
        })</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.VectorSymbology.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ><a title="geoengine.api.Symbology" href="api.html#geoengine.api.Symbology">Symbology</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; api.Symbology:
    return api.Symbology({
        &#39;type&#39;: &#39;vector&#39;,
    })</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.Symbology.from_response" href="#geoengine.types.Symbology.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geoengine" href="index.html">geoengine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.BoundingBox2D.from_response" href="#geoengine.types.BoundingBox2D.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.BoundingBox2D.to_api_dict" href="#geoengine.types.BoundingBox2D.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.types.BoundingBox2D.xmax" href="#geoengine.types.BoundingBox2D.xmax">xmax</a></code></li>
<li><code><a title="geoengine.types.BoundingBox2D.xmin" href="#geoengine.types.BoundingBox2D.xmin">xmin</a></code></li>
<li><code><a title="geoengine.types.BoundingBox2D.ymax" href="#geoengine.types.BoundingBox2D.ymax">ymax</a></code></li>
<li><code><a title="geoengine.types.BoundingBox2D.ymin" href="#geoengine.types.BoundingBox2D.ymin">ymin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.ClassificationMeasurement" href="#geoengine.types.ClassificationMeasurement">ClassificationMeasurement</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.ClassificationMeasurement.classes" href="#geoengine.types.ClassificationMeasurement.classes">classes</a></code></li>
<li><code><a title="geoengine.types.ClassificationMeasurement.from_response_classification" href="#geoengine.types.ClassificationMeasurement.from_response_classification">from_response_classification</a></code></li>
<li><code><a title="geoengine.types.ClassificationMeasurement.measurement" href="#geoengine.types.ClassificationMeasurement.measurement">measurement</a></code></li>
<li><code><a title="geoengine.types.ClassificationMeasurement.to_api_dict" href="#geoengine.types.ClassificationMeasurement.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.ContinuousMeasurement" href="#geoengine.types.ContinuousMeasurement">ContinuousMeasurement</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.ContinuousMeasurement.from_response_continuous" href="#geoengine.types.ContinuousMeasurement.from_response_continuous">from_response_continuous</a></code></li>
<li><code><a title="geoengine.types.ContinuousMeasurement.measurement" href="#geoengine.types.ContinuousMeasurement.measurement">measurement</a></code></li>
<li><code><a title="geoengine.types.ContinuousMeasurement.to_api_dict" href="#geoengine.types.ContinuousMeasurement.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.types.ContinuousMeasurement.unit" href="#geoengine.types.ContinuousMeasurement.unit">unit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.DataId.from_response" href="#geoengine.types.DataId.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.DataId.to_api_dict" href="#geoengine.types.DataId.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.ExternalDataId" href="#geoengine.types.ExternalDataId">ExternalDataId</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.ExternalDataId.from_response_external" href="#geoengine.types.ExternalDataId.from_response_external">from_response_external</a></code></li>
<li><code><a title="geoengine.types.ExternalDataId.to_api_dict" href="#geoengine.types.ExternalDataId.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.FeatureDataType" href="#geoengine.types.FeatureDataType">FeatureDataType</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.FeatureDataType.BOOL" href="#geoengine.types.FeatureDataType.BOOL">BOOL</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.CATEGORY" href="#geoengine.types.FeatureDataType.CATEGORY">CATEGORY</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.DATETIME" href="#geoengine.types.FeatureDataType.DATETIME">DATETIME</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.FLOAT" href="#geoengine.types.FeatureDataType.FLOAT">FLOAT</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.INT" href="#geoengine.types.FeatureDataType.INT">INT</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.TEXT" href="#geoengine.types.FeatureDataType.TEXT">TEXT</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.from_string" href="#geoengine.types.FeatureDataType.from_string">from_string</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.to_api_enum" href="#geoengine.types.FeatureDataType.to_api_enum">to_api_enum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.GeoTransform" href="#geoengine.types.GeoTransform">GeoTransform</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.GeoTransform.from_response" href="#geoengine.types.GeoTransform.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.to_api_dict" href="#geoengine.types.GeoTransform.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.x_half_pixel_size" href="#geoengine.types.GeoTransform.x_half_pixel_size">x_half_pixel_size</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.x_max" href="#geoengine.types.GeoTransform.x_max">x_max</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.x_min" href="#geoengine.types.GeoTransform.x_min">x_min</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.x_pixel_size" href="#geoengine.types.GeoTransform.x_pixel_size">x_pixel_size</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.y_half_pixel_size" href="#geoengine.types.GeoTransform.y_half_pixel_size">y_half_pixel_size</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.y_max" href="#geoengine.types.GeoTransform.y_max">y_max</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.y_min" href="#geoengine.types.GeoTransform.y_min">y_min</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.y_pixel_size" href="#geoengine.types.GeoTransform.y_pixel_size">y_pixel_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.InternalDataId" href="#geoengine.types.InternalDataId">InternalDataId</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.InternalDataId.from_response_internal" href="#geoengine.types.InternalDataId.from_response_internal">from_response_internal</a></code></li>
<li><code><a title="geoengine.types.InternalDataId.to_api_dict" href="#geoengine.types.InternalDataId.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.Measurement.from_response" href="#geoengine.types.Measurement.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.Measurement.to_api_dict" href="#geoengine.types.Measurement.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.PlotResultDescriptor" href="#geoengine.types.PlotResultDescriptor">PlotResultDescriptor</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.PlotResultDescriptor.from_response_plot" href="#geoengine.types.PlotResultDescriptor.from_response_plot">from_response_plot</a></code></li>
<li><code><a title="geoengine.types.PlotResultDescriptor.spatial_bounds" href="#geoengine.types.PlotResultDescriptor.spatial_bounds">spatial_bounds</a></code></li>
<li><code><a title="geoengine.types.PlotResultDescriptor.to_api_dict" href="#geoengine.types.PlotResultDescriptor.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.Provenance" href="#geoengine.types.Provenance">Provenance</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.Provenance.citation" href="#geoengine.types.Provenance.citation">citation</a></code></li>
<li><code><a title="geoengine.types.Provenance.from_response" href="#geoengine.types.Provenance.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.Provenance.license" href="#geoengine.types.Provenance.license">license</a></code></li>
<li><code><a title="geoengine.types.Provenance.to_api_dict" href="#geoengine.types.Provenance.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.types.Provenance.uri" href="#geoengine.types.Provenance.uri">uri</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.ProvenanceEntry" href="#geoengine.types.ProvenanceEntry">ProvenanceEntry</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.ProvenanceEntry.data" href="#geoengine.types.ProvenanceEntry.data">data</a></code></li>
<li><code><a title="geoengine.types.ProvenanceEntry.from_response" href="#geoengine.types.ProvenanceEntry.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.ProvenanceEntry.provenance" href="#geoengine.types.ProvenanceEntry.provenance">provenance</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.QueryRectangle" href="#geoengine.types.QueryRectangle">QueryRectangle</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.QueryRectangle.bbox_ogc" href="#geoengine.types.QueryRectangle.bbox_ogc">bbox_ogc</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.bbox_ogc_str" href="#geoengine.types.QueryRectangle.bbox_ogc_str">bbox_ogc_str</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.bbox_str" href="#geoengine.types.QueryRectangle.bbox_str">bbox_str</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.resolution_ogc" href="#geoengine.types.QueryRectangle.resolution_ogc">resolution_ogc</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.spatial_bounds" href="#geoengine.types.QueryRectangle.spatial_bounds">spatial_bounds</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.spatial_resolution" href="#geoengine.types.QueryRectangle.spatial_resolution">spatial_resolution</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.srs" href="#geoengine.types.QueryRectangle.srs">srs</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.time" href="#geoengine.types.QueryRectangle.time">time</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.time_str" href="#geoengine.types.QueryRectangle.time_str">time_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.RasterResultDescriptor" href="#geoengine.types.RasterResultDescriptor">RasterResultDescriptor</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.RasterResultDescriptor.data_type" href="#geoengine.types.RasterResultDescriptor.data_type">data_type</a></code></li>
<li><code><a title="geoengine.types.RasterResultDescriptor.from_response_raster" href="#geoengine.types.RasterResultDescriptor.from_response_raster">from_response_raster</a></code></li>
<li><code><a title="geoengine.types.RasterResultDescriptor.measurement" href="#geoengine.types.RasterResultDescriptor.measurement">measurement</a></code></li>
<li><code><a title="geoengine.types.RasterResultDescriptor.spatial_bounds" href="#geoengine.types.RasterResultDescriptor.spatial_bounds">spatial_bounds</a></code></li>
<li><code><a title="geoengine.types.RasterResultDescriptor.to_api_dict" href="#geoengine.types.RasterResultDescriptor.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.types.RasterResultDescriptor.to_json" href="#geoengine.types.RasterResultDescriptor.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.RasterSymbology" href="#geoengine.types.RasterSymbology">RasterSymbology</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.RasterSymbology.from_response_raster" href="#geoengine.types.RasterSymbology.from_response_raster">from_response_raster</a></code></li>
<li><code><a title="geoengine.types.RasterSymbology.to_api_dict" href="#geoengine.types.RasterSymbology.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.ResultDescriptor.from_response" href="#geoengine.types.ResultDescriptor.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_plot_result" href="#geoengine.types.ResultDescriptor.is_plot_result">is_plot_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_raster_result" href="#geoengine.types.ResultDescriptor.is_raster_result">is_raster_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_vector_result" href="#geoengine.types.ResultDescriptor.is_vector_result">is_vector_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_reference" href="#geoengine.types.ResultDescriptor.spatial_reference">spatial_reference</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_resolution" href="#geoengine.types.ResultDescriptor.spatial_resolution">spatial_resolution</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.time_bounds" href="#geoengine.types.ResultDescriptor.time_bounds">time_bounds</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.to_api_dict" href="#geoengine.types.ResultDescriptor.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.SpatialBounds.as_bbox_str" href="#geoengine.types.SpatialBounds.as_bbox_str">as_bbox_str</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.as_bbox_tuple" href="#geoengine.types.SpatialBounds.as_bbox_tuple">as_bbox_tuple</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.x_axis_size" href="#geoengine.types.SpatialBounds.x_axis_size">x_axis_size</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.xmax" href="#geoengine.types.SpatialBounds.xmax">xmax</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.xmin" href="#geoengine.types.SpatialBounds.xmin">xmin</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.y_axis_size" href="#geoengine.types.SpatialBounds.y_axis_size">y_axis_size</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.ymax" href="#geoengine.types.SpatialBounds.ymax">ymax</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.ymin" href="#geoengine.types.SpatialBounds.ymin">ymin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.SpatialPartition2D" href="#geoengine.types.SpatialPartition2D">SpatialPartition2D</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.SpatialPartition2D.from_response" href="#geoengine.types.SpatialPartition2D.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.SpatialPartition2D.to_api_dict" href="#geoengine.types.SpatialPartition2D.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.types.SpatialPartition2D.to_bounding_box" href="#geoengine.types.SpatialPartition2D.to_bounding_box">to_bounding_box</a></code></li>
<li><code><a title="geoengine.types.SpatialPartition2D.xmax" href="#geoengine.types.SpatialPartition2D.xmax">xmax</a></code></li>
<li><code><a title="geoengine.types.SpatialPartition2D.xmin" href="#geoengine.types.SpatialPartition2D.xmin">xmin</a></code></li>
<li><code><a title="geoengine.types.SpatialPartition2D.ymax" href="#geoengine.types.SpatialPartition2D.ymax">ymax</a></code></li>
<li><code><a title="geoengine.types.SpatialPartition2D.ymin" href="#geoengine.types.SpatialPartition2D.ymin">ymin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.SpatialResolution.as_tuple" href="#geoengine.types.SpatialResolution.as_tuple">as_tuple</a></code></li>
<li><code><a title="geoengine.types.SpatialResolution.from_response" href="#geoengine.types.SpatialResolution.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.SpatialResolution.to_api_dict" href="#geoengine.types.SpatialResolution.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.types.SpatialResolution.x_resolution" href="#geoengine.types.SpatialResolution.x_resolution">x_resolution</a></code></li>
<li><code><a title="geoengine.types.SpatialResolution.y_resolution" href="#geoengine.types.SpatialResolution.y_resolution">y_resolution</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.Symbology.from_response" href="#geoengine.types.Symbology.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.Symbology.to_api_dict" href="#geoengine.types.Symbology.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.TimeInterval.end" href="#geoengine.types.TimeInterval.end">end</a></code></li>
<li><code><a title="geoengine.types.TimeInterval.from_response" href="#geoengine.types.TimeInterval.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.TimeInterval.is_instant" href="#geoengine.types.TimeInterval.is_instant">is_instant</a></code></li>
<li><code><a title="geoengine.types.TimeInterval.start" href="#geoengine.types.TimeInterval.start">start</a></code></li>
<li><code><a title="geoengine.types.TimeInterval.time_str" href="#geoengine.types.TimeInterval.time_str">time_str</a></code></li>
<li><code><a title="geoengine.types.TimeInterval.to_api_dict" href="#geoengine.types.TimeInterval.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.TimeStep" href="#geoengine.types.TimeStep">TimeStep</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.TimeStep.granularity" href="#geoengine.types.TimeStep.granularity">granularity</a></code></li>
<li><code><a title="geoengine.types.TimeStep.step" href="#geoengine.types.TimeStep.step">step</a></code></li>
<li><code><a title="geoengine.types.TimeStep.to_api_dict" href="#geoengine.types.TimeStep.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.TimeStepGranularity" href="#geoengine.types.TimeStepGranularity">TimeStepGranularity</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.TimeStepGranularity.DAYS" href="#geoengine.types.TimeStepGranularity.DAYS">DAYS</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.HOURS" href="#geoengine.types.TimeStepGranularity.HOURS">HOURS</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.MILLIS" href="#geoengine.types.TimeStepGranularity.MILLIS">MILLIS</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.MINUTES" href="#geoengine.types.TimeStepGranularity.MINUTES">MINUTES</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.MONTHS" href="#geoengine.types.TimeStepGranularity.MONTHS">MONTHS</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.SECONDS" href="#geoengine.types.TimeStepGranularity.SECONDS">SECONDS</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.YEARS" href="#geoengine.types.TimeStepGranularity.YEARS">YEARS</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.to_api_enum" href="#geoengine.types.TimeStepGranularity.to_api_enum">to_api_enum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.UnitlessMeasurement" href="#geoengine.types.UnitlessMeasurement">UnitlessMeasurement</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.UnitlessMeasurement.to_api_dict" href="#geoengine.types.UnitlessMeasurement.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.VectorColumnInfo" href="#geoengine.types.VectorColumnInfo">VectorColumnInfo</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.VectorColumnInfo.data_type" href="#geoengine.types.VectorColumnInfo.data_type">data_type</a></code></li>
<li><code><a title="geoengine.types.VectorColumnInfo.from_response" href="#geoengine.types.VectorColumnInfo.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.VectorColumnInfo.measurement" href="#geoengine.types.VectorColumnInfo.measurement">measurement</a></code></li>
<li><code><a title="geoengine.types.VectorColumnInfo.to_api_dict" href="#geoengine.types.VectorColumnInfo.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.VectorDataType.DATA" href="#geoengine.types.VectorDataType.DATA">DATA</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.MULTI_LINE_STRING" href="#geoengine.types.VectorDataType.MULTI_LINE_STRING">MULTI_LINE_STRING</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.MULTI_POINT" href="#geoengine.types.VectorDataType.MULTI_POINT">MULTI_POINT</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.MULTI_POLYGON" href="#geoengine.types.VectorDataType.MULTI_POLYGON">MULTI_POLYGON</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.from_api_enum" href="#geoengine.types.VectorDataType.from_api_enum">from_api_enum</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.from_geopandas_type_name" href="#geoengine.types.VectorDataType.from_geopandas_type_name">from_geopandas_type_name</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.from_literal" href="#geoengine.types.VectorDataType.from_literal">from_literal</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.from_string" href="#geoengine.types.VectorDataType.from_string">from_string</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.to_api_enum" href="#geoengine.types.VectorDataType.to_api_enum">to_api_enum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.VectorResultDescriptor" href="#geoengine.types.VectorResultDescriptor">VectorResultDescriptor</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.VectorResultDescriptor.columns" href="#geoengine.types.VectorResultDescriptor.columns">columns</a></code></li>
<li><code><a title="geoengine.types.VectorResultDescriptor.data_type" href="#geoengine.types.VectorResultDescriptor.data_type">data_type</a></code></li>
<li><code><a title="geoengine.types.VectorResultDescriptor.from_response_vector" href="#geoengine.types.VectorResultDescriptor.from_response_vector">from_response_vector</a></code></li>
<li><code><a title="geoengine.types.VectorResultDescriptor.spatial_bounds" href="#geoengine.types.VectorResultDescriptor.spatial_bounds">spatial_bounds</a></code></li>
<li><code><a title="geoengine.types.VectorResultDescriptor.to_api_dict" href="#geoengine.types.VectorResultDescriptor.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.VectorSymbology" href="#geoengine.types.VectorSymbology">VectorSymbology</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.VectorSymbology.to_api_dict" href="#geoengine.types.VectorSymbology.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>