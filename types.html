<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>geoengine.types API documentation</title>
<meta name="description" content="Different type mappings of geo engine types" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geoengine.types</code></h1>
</header>
<section id="section-intro">
<p>Different type mappings of geo engine types</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># pylint: disable=too-many-lines

&#39;&#39;&#39;
Different type mappings of geo engine types
&#39;&#39;&#39;

from __future__ import annotations
from abc import abstractmethod
from datetime import datetime, timezone
from uuid import UUID
from enum import Enum
from typing import Any, Dict, Optional, Tuple, Union, cast, List, Literal
from attr import dataclass
import numpy as np
import geoengine_openapi_client
from geoengine.colorizer import Colorizer
from geoengine.error import GeoEngineException, InputException, TypeException


DEFAULT_ISO_TIME_FORMAT = &#34;%Y-%m-%dT%H:%M:%S.%f%z&#34;


class SpatialBounds:
    &#39;&#39;&#39;A spatial bounds object&#39;&#39;&#39;
    xmin: float
    ymin: float
    xmax: float
    ymax: float

    def __init__(self, xmin: float, ymin: float, xmax: float, ymax: float) -&gt; None:
        &#39;&#39;&#39;Initialize a new `SpatialBounds` object&#39;&#39;&#39;
        if (xmin &gt; xmax) or (ymin &gt; ymax):
            raise InputException(&#34;Bbox: Malformed since min must be &lt;= max&#34;)

        self.xmin = xmin
        self.ymin = ymin
        self.xmax = xmax
        self.ymax = ymax

    def as_bbox_str(self, y_axis_first=False) -&gt; str:
        &#39;&#39;&#39;
        A comma-separated string representation of the spatial bounds with OGC axis ordering
        &#39;&#39;&#39;
        bbox_tuple = self.as_bbox_tuple(y_axis_first=y_axis_first)
        return f&#39;{bbox_tuple[0]},{bbox_tuple[1]},{bbox_tuple[2]},{bbox_tuple[3]}&#39;

    def as_bbox_tuple(self, y_axis_first=False) -&gt; Tuple[float, float, float, float]:
        &#39;&#39;&#39;
        Return the bbox with OGC axis ordering of the srs
        &#39;&#39;&#39;

        if y_axis_first:
            return (self.ymin, self.xmin, self.ymax, self.xmax)

        return (self.xmin, self.ymin, self.xmax, self.ymax)

    def x_axis_size(self) -&gt; float:
        &#39;&#39;&#39;The size of the x axis&#39;&#39;&#39;
        return self.xmax - self.xmin

    def y_axis_size(self) -&gt; float:
        &#39;&#39;&#39;The size of the y axis&#39;&#39;&#39;
        return self.ymax - self.ymin


class BoundingBox2D(SpatialBounds):
    &#39;&#39;&#39;&#39;A 2D bounding box.&#39;&#39;&#39;

    def to_api_dict(self) -&gt; geoengine_openapi_client.BoundingBox2D:
        return geoengine_openapi_client.BoundingBox2D(
            lower_left_coordinate=geoengine_openapi_client.Coordinate2D(
                x=self.xmin,
                y=self.ymin,
            ),
            upper_right_coordinate=geoengine_openapi_client.Coordinate2D(
                x=self.xmax,
                y=self.ymax,
            ),
        )

    @staticmethod
    def from_response(response: geoengine_openapi_client.BoundingBox2D) -&gt; BoundingBox2D:
        &#39;&#39;&#39;create a `BoundingBox2D` from an API response&#39;&#39;&#39;
        lower_left = response.lower_left_coordinate
        upper_right = response.upper_right_coordinate

        return BoundingBox2D(
            lower_left.x,
            lower_left.y,
            upper_right.x,
            upper_right.y,
        )

    def __repr__(self) -&gt; str:
        return f&#39;BoundingBox2D(xmin={self.xmin}, ymin={self.ymin}, xmax={self.xmax}, ymax={self.ymax})&#39;


class SpatialPartition2D(SpatialBounds):
    &#39;&#39;&#39;A 2D spatial partition.&#39;&#39;&#39;

    @staticmethod
    def from_response(response: geoengine_openapi_client.SpatialPartition2D) -&gt; SpatialPartition2D:
        &#39;&#39;&#39;create a `SpatialPartition2D` from an API response&#39;&#39;&#39;
        upper_left = response.upper_left_coordinate
        lower_right = response.lower_right_coordinate

        return SpatialPartition2D(
            upper_left.x,
            lower_right.y,
            lower_right.x,
            upper_left.y,

        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.SpatialPartition2D:
        return geoengine_openapi_client.SpatialPartition2D(
            upper_left_coordinate=geoengine_openapi_client.Coordinate2D(
                x=self.xmin,
                y=self.ymax,
            ),
            lower_right_coordinate=geoengine_openapi_client.Coordinate2D(
                x=self.xmax,
                y=self.ymin,
            ),
        )

    def to_bounding_box(self) -&gt; BoundingBox2D:
        &#39;&#39;&#39;convert to a `BoundingBox2D`&#39;&#39;&#39;
        return BoundingBox2D(self.xmin, self.ymin, self.xmax, self.ymax)


class TimeInterval:
    &#39;&#39;&#39;&#39;A time interval.&#39;&#39;&#39;
    start: np.datetime64
    end: Optional[np.datetime64]

    def __init__(self,
                 start: Union[datetime, np.datetime64],
                 end: Optional[Union[datetime, np.datetime64]] = None) -&gt; None:
        &#39;&#39;&#39;Initialize a new `TimeInterval` object&#39;&#39;&#39;

        if isinstance(start, np.datetime64):
            self.start = start
        elif isinstance(start, datetime):
            # We assume that a datetime without a timezone means UTC
            if start.tzinfo is not None:
                start = start.astimezone(tz=timezone.utc).replace(tzinfo=None)
            self.start = np.datetime64(start)
        else:
            raise InputException(&#34;`start` must be of type `datetime.datetime` or `numpy.datetime64`&#34;)

        if end is None:
            self.end = None
        elif isinstance(end, np.datetime64):
            self.end = end
        elif isinstance(end, datetime):
            # We assume that a datetime without a timezone means UTC
            if end.tzinfo is not None:
                end = end.astimezone(tz=timezone.utc).replace(tzinfo=None)
            self.end = np.datetime64(end)
        else:
            raise InputException(&#34;`end` must be of type `datetime.datetime` or `numpy.datetime64`&#34;)

        # Check validity of time interval if an `end` exists
        if end is not None and start &gt; end:
            raise InputException(&#34;Time inverval: Start must be &lt;= End&#34;)

    def is_instant(self) -&gt; bool:
        return self.end is None

    @property
    def time_str(self) -&gt; str:
        &#39;&#39;&#39;
        Return the time instance or interval as a string representation
        &#39;&#39;&#39;

        start_iso = TimeInterval.__datetime_to_iso_str(self.start)

        if self.end is None or self.start == self.end:
            return start_iso

        end_iso = TimeInterval.__datetime_to_iso_str(self.end)

        return start_iso + &#39;/&#39; + end_iso

    @staticmethod
    def from_response(response: Any) -&gt; TimeInterval:
        &#39;&#39;&#39;create a `TimeInterval` from an API response&#39;&#39;&#39;

        if &#39;start&#39; not in response:
            raise TypeException(&#39;TimeInterval must have a start&#39;)

        if isinstance(response[&#39;start&#39;], int):
            start = cast(int, response[&#39;start&#39;])
            end = cast(int, response[&#39;end&#39;]) if &#39;end&#39; in response and response[&#39;end&#39;] is not None else None

            return TimeInterval(
                np.datetime64(start, &#39;ms&#39;),
                np.datetime64(end, &#39;ms&#39;) if end is not None else None,
            )

        start_str = cast(str, response[&#39;start&#39;])
        end_str = cast(str, response[&#39;end&#39;]) if &#39;end&#39; in response and response[&#39;end&#39;] is not None else None

        return TimeInterval(
            datetime.fromisoformat(start_str),
            datetime.fromisoformat(end_str) if end_str is not None else None,
        )

    def __repr__(self) -&gt; str:
        return f&#34;TimeInterval(start={self.start}, end={self.end})&#34;

    def to_api_dict(self) -&gt; geoengine_openapi_client.TimeInterval:
        return geoengine_openapi_client.TimeInterval(
            start=int(self.start.astype(&#39;datetime64[ms]&#39;).astype(int)),
            end=int(self.end.astype(&#39;datetime64[ms]&#39;).astype(int)) if self.end is not None else None,
        )

    @staticmethod
    def __datetime_to_iso_str(timestamp: np.datetime64) -&gt; str:
        return str(np.datetime_as_string(timestamp, unit=&#39;ms&#39;, timezone=&#39;UTC&#39;)).replace(&#39;Z&#39;, &#39;+00:00&#39;)

    def __eq__(self, other: Any) -&gt; bool:
        &#39;&#39;&#39;Check if two `TimeInterval` objects are equal.&#39;&#39;&#39;
        if not isinstance(other, TimeInterval):
            return False
        return self.start == other.start and self.end == other.end


class SpatialResolution:
    &#39;&#39;&#39;&#39;A spatial resolution.&#39;&#39;&#39;
    x_resolution: float
    y_resolution: float

    def __init__(self, x_resolution: float, y_resolution: float) -&gt; None:
        &#39;&#39;&#39;Initialize a new `SpatialResolution` object&#39;&#39;&#39;
        if x_resolution &lt;= 0 or y_resolution &lt;= 0:
            raise InputException(&#34;Resolution: Must be positive&#34;)

        self.x_resolution = x_resolution
        self.y_resolution = y_resolution

    def to_api_dict(self) -&gt; geoengine_openapi_client.SpatialResolution:
        return geoengine_openapi_client.SpatialResolution(
            x=self.x_resolution,
            y=self.y_resolution,
        )

    @staticmethod
    def from_response(response: geoengine_openapi_client.SpatialResolution) -&gt; SpatialResolution:
        &#39;&#39;&#39;create a `SpatialResolution` from an API response&#39;&#39;&#39;
        return SpatialResolution(x_resolution=response.x, y_resolution=response.y)

    def as_tuple(self) -&gt; Tuple[float, float]:
        return (self.x_resolution, self.y_resolution)

    def __str__(self) -&gt; str:
        return str(f&#39;{self.x_resolution},{self.y_resolution}&#39;)

    def __repr__(self) -&gt; str:
        return str(f&#39;SpatialResolution(x={self.x_resolution}, y={self.y_resolution})&#39;)


class QueryRectangle:
    &#39;&#39;&#39;
    A multi-dimensional query rectangle, consisting of spatial and temporal information.
    &#39;&#39;&#39;

    __spatial_bounds: BoundingBox2D
    __time_interval: TimeInterval
    __resolution: SpatialResolution
    __srs: str

    def __init__(self,
                 spatial_bounds: Union[BoundingBox2D, Tuple[float, float, float, float]],
                 time_interval: Union[TimeInterval, Tuple[datetime, Optional[datetime]]],
                 resolution: Union[SpatialResolution, Tuple[float, float]],
                 srs=&#39;EPSG:4326&#39;) -&gt; None:
        &#34;&#34;&#34;
        Initialize a new `QueryRectangle` object

        Parameters
        ----------
        spatial_bounds
            The spatial bounds of the query rectangle.
            Either a `BoundingBox2D` or a tuple of floats (xmin, ymin, xmax, ymax)
        time_interval
            The time interval of the query rectangle.
            Either a `TimeInterval` or a tuple of `datetime.datetime` objects (start, end)
        resolution
            The spatial resolution of the query rectangle.
            Either a `SpatialResolution` or a tuple of floats (x_resolution, y_resolution)
        &#34;&#34;&#34;

        if not isinstance(spatial_bounds, BoundingBox2D):
            spatial_bounds = BoundingBox2D(*spatial_bounds)
        if not isinstance(time_interval, TimeInterval):
            time_interval = TimeInterval(*time_interval)
        if not isinstance(resolution, SpatialResolution):
            resolution = SpatialResolution(*resolution)

        self.__spatial_bounds = spatial_bounds
        self.__time_interval = time_interval
        self.__resolution = resolution
        self.__srs = srs

    @property
    def bbox_str(self) -&gt; str:
        &#39;&#39;&#39;
        A comma-separated string representation of the spatial bounds
        &#39;&#39;&#39;
        return self.__spatial_bounds.as_bbox_str()

    @property
    def bbox_ogc_str(self) -&gt; str:
        &#39;&#39;&#39;
        A comma-separated string representation of the spatial bounds with OGC axis ordering
        &#39;&#39;&#39;
        y_axis_first = self.__srs == &#34;EPSG:4326&#34;
        return self.__spatial_bounds.as_bbox_str(y_axis_first=y_axis_first)

    @property
    def bbox_ogc(self) -&gt; Tuple[float, float, float, float]:
        &#39;&#39;&#39;
        Return the bbox with OGC axis ordering of the srs
        &#39;&#39;&#39;

        # TODO: properly handle axis order
        y_axis_first = self.__srs == &#34;EPSG:4326&#34;
        return self.__spatial_bounds.as_bbox_tuple(y_axis_first=y_axis_first)

    @property
    def resolution_ogc(self) -&gt; Tuple[float, float]:
        &#39;&#39;&#39;
        Return the resolution in OGC style
        &#39;&#39;&#39;
        # TODO: properly handle axis order
        res = self.__resolution

        # TODO: why is the y resolution in this case negative but not in all other cases?
        if self.__srs == &#34;EPSG:4326&#34;:
            return (-res.y_resolution, res.x_resolution)

        return res.as_tuple()

    @property
    def time(self) -&gt; TimeInterval:
        &#39;&#39;&#39;
        Return the time instance or interval
        &#39;&#39;&#39;
        return self.__time_interval

    @property
    def spatial_bounds(self) -&gt; BoundingBox2D:
        &#39;&#39;&#39;
        Return the spatial bounds
        &#39;&#39;&#39;
        return self.__spatial_bounds

    @property
    def spatial_resolution(self) -&gt; SpatialResolution:
        &#39;&#39;&#39;
        Return the spatial resolution
        &#39;&#39;&#39;
        return self.__resolution

    @property
    def time_str(self) -&gt; str:
        &#39;&#39;&#39;
        Return the time instance or interval as a string representation
        &#39;&#39;&#39;
        return self.time.time_str

    @property
    def srs(self) -&gt; str:
        &#39;&#39;&#39;
        Return the SRS string
        &#39;&#39;&#39;
        return self.__srs

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39; Return a string representation of the query rectangle.&#39;&#39;&#39;
        r = &#39;QueryRectangle( \n&#39;
        r += &#39;    &#39; + repr(self.__spatial_bounds) + &#39;\n&#39;
        r += &#39;    &#39; + repr(self.__time_interval) + &#39;\n&#39;
        r += &#39;    &#39; + repr(self.__resolution) + &#39;\n&#39;
        r += f&#39;    srs={self.__srs} \n&#39;
        r += &#39;)&#39;
        return r

    def as_raster_query_rectangle_api_dict(self) -&gt; geoengine_openapi_client.RasterQueryRectangle:
        &#39;&#39;&#39;Return the query rectangle as a dictionary for the API&#39;&#39;&#39;
        return geoengine_openapi_client.RasterQueryRectangle(
            spatial_bounds=SpatialPartition2D(
                self.spatial_bounds.xmin,
                self.spatial_bounds.ymin,
                self.spatial_bounds.xmax,
                self.spatial_bounds.ymax,
            ).to_api_dict(),
            spatial_resolution=self.spatial_resolution.to_api_dict(),
            time_interval=self.time.to_api_dict(),
        )


class ResultDescriptor:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;
    Base class for result descriptors
    &#39;&#39;&#39;

    __spatial_reference: str
    __time_bounds: Optional[TimeInterval]
    __spatial_resolution: Optional[SpatialResolution]

    def __init__(
        self,
        spatial_reference: str,
        time_bounds: Optional[TimeInterval] = None,
        spatial_resolution: Optional[SpatialResolution] = None
    ) -&gt; None:
        &#39;&#39;&#39;Initialize a new `ResultDescriptor` object&#39;&#39;&#39;

        self.__spatial_reference = spatial_reference
        self.__time_bounds = time_bounds

        if spatial_resolution is None or isinstance(spatial_resolution, SpatialResolution):
            self.__spatial_resolution = spatial_resolution
        else:
            raise TypeException(&#39;Spatial resolution must be of type `SpatialResolution` or `None`&#39;)

    @staticmethod
    def from_response(response: geoengine_openapi_client.TypedResultDescriptor) -&gt; ResultDescriptor:
        &#39;&#39;&#39;
        Parse a result descriptor from an http response
        &#39;&#39;&#39;

        inner = response.actual_instance

        if isinstance(inner, geoengine_openapi_client.TypedRasterResultDescriptor):
            return RasterResultDescriptor.from_response_raster(inner)
        if isinstance(inner, geoengine_openapi_client.TypedVectorResultDescriptor):
            return VectorResultDescriptor.from_response_vector(inner)
        if isinstance(inner, geoengine_openapi_client.TypedPlotResultDescriptor):
            return PlotResultDescriptor.from_response_plot(inner)

        raise TypeException(&#39;Unknown `ResultDescriptor` type&#39;)

    @classmethod
    def is_raster_result(cls) -&gt; bool:
        &#39;&#39;&#39;
        Return true if the result is of type raster
        &#39;&#39;&#39;
        return False

    @classmethod
    def is_vector_result(cls) -&gt; bool:
        &#39;&#39;&#39;
        Return true if the result is of type vector
        &#39;&#39;&#39;
        return False

    @classmethod
    def is_plot_result(cls) -&gt; bool:
        &#39;&#39;&#39;
        Return true if the result is of type plot
        &#39;&#39;&#39;

        return False

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;

        return self.__spatial_reference

    @property
    def time_bounds(self) -&gt; Optional[TimeInterval]:
        &#39;&#39;&#39;Return the time bounds&#39;&#39;&#39;

        return self.__time_bounds

    @property
    def spatial_resolution(self) -&gt; Optional[SpatialResolution]:
        &#39;&#39;&#39;Return the spatial resolution&#39;&#39;&#39;

        return self.__spatial_resolution

    @abstractmethod
    def to_api_dict(self) -&gt; geoengine_openapi_client.TypedResultDescriptor:
        pass

    def __iter__(self):
        return iter(self.to_api_dict().items())


class VectorResultDescriptor(ResultDescriptor):
    &#39;&#39;&#39;
    A vector result descriptor
    &#39;&#39;&#39;
    __spatial_bounds: Optional[BoundingBox2D]
    __data_type: VectorDataType
    __columns: Dict[str, VectorColumnInfo]

    def __init__(  # pylint: disable=too-many-arguments,too-many-positional-arguments
        self,
        spatial_reference: str,
        data_type: VectorDataType,
        columns: Dict[str, VectorColumnInfo],
        time_bounds: Optional[TimeInterval] = None,
        spatial_bounds: Optional[BoundingBox2D] = None
    ) -&gt; None:
        &#39;&#39;&#39; Initialize a vector result descriptor &#39;&#39;&#39;
        super().__init__(spatial_reference, time_bounds, None)
        self.__data_type = data_type
        self.__columns = columns
        self.__spatial_bounds = spatial_bounds

    @staticmethod
    def from_response_vector(
            response: geoengine_openapi_client.TypedVectorResultDescriptor) -&gt; VectorResultDescriptor:
        &#39;&#39;&#39;Parse a vector result descriptor from an http response&#39;&#39;&#39;
        sref = response.spatial_reference
        data_type = VectorDataType.from_string(response.data_type)
        columns = {name: VectorColumnInfo.from_response(info) for name, info in response.columns.items()}

        time_bounds = None
        # FIXME: datetime can not represent our min max range
        # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
        #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
        spatial_bounds = None
        if response.bbox is not None:
            spatial_bounds = BoundingBox2D.from_response(response.bbox)

        return VectorResultDescriptor(sref, data_type, columns, time_bounds, spatial_bounds)

    @classmethod
    def is_vector_result(cls) -&gt; bool:
        return True

    @property
    def data_type(self) -&gt; VectorDataType:
        &#39;&#39;&#39;Return the data type&#39;&#39;&#39;
        return self.__data_type

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;
        return super().spatial_reference

    @property
    def columns(self) -&gt; Dict[str, VectorColumnInfo]:
        &#39;&#39;&#39;Return the columns&#39;&#39;&#39;

        return self.__columns

    @property
    def spatial_bounds(self) -&gt; Optional[BoundingBox2D]:
        &#39;&#39;&#39;Return the spatial bounds&#39;&#39;&#39;
        return self.__spatial_bounds

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of the vector result descriptor&#39;&#39;&#39;
        r = &#39;&#39;
        r += f&#39;Data type:         {self.data_type.value}\n&#39;
        r += f&#39;Spatial Reference: {self.spatial_reference}\n&#39;

        r += &#39;Columns:\n&#39;
        for column_name in self.columns:
            column_info = self.columns[column_name]
            r += f&#39;  {column_name}:\n&#39;
            r += f&#39;    Column Type: {column_info.data_type.value}\n&#39;
            r += f&#39;    Measurement: {column_info.measurement}\n&#39;

        return r

    def to_api_dict(self) -&gt; geoengine_openapi_client.TypedResultDescriptor:
        &#39;&#39;&#39;Convert the vector result descriptor to a dictionary&#39;&#39;&#39;

        return geoengine_openapi_client.TypedResultDescriptor(geoengine_openapi_client.TypedVectorResultDescriptor(
            type=&#39;vector&#39;,
            data_type=self.data_type.to_api_enum(),
            spatial_reference=self.spatial_reference,
            columns={name: column_info.to_api_dict() for name, column_info in self.columns.items()},
            time=self.time_bounds.time_str if self.time_bounds is not None else None,
            bbox=self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
            resolution=self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None,
        ))


class FeatureDataType(str, Enum):
    &#39;&#39;&#39;Vector column data type&#39;&#39;&#39;

    CATEGORY = &#34;category&#34;
    INT = &#34;int&#34;
    FLOAT = &#34;float&#34;
    TEXT = &#34;text&#34;
    BOOL = &#34;bool&#34;
    DATETIME = &#34;dateTime&#34;

    @staticmethod
    def from_string(data_type: str) -&gt; FeatureDataType:
        &#39;&#39;&#39;Create a new `VectorColumnDataType` from a string&#39;&#39;&#39;

        return FeatureDataType(data_type)

    def to_api_enum(self) -&gt; geoengine_openapi_client.FeatureDataType:
        &#39;&#39;&#39;Convert to an API enum&#39;&#39;&#39;

        return geoengine_openapi_client.FeatureDataType(self.value)


@dataclass
class VectorColumnInfo:
    &#39;&#39;&#39;Vector column information&#39;&#39;&#39;

    data_type: FeatureDataType
    measurement: Measurement

    @staticmethod
    def from_response(response: geoengine_openapi_client.VectorColumnInfo) -&gt; VectorColumnInfo:
        &#39;&#39;&#39;Create a new `VectorColumnInfo` from a JSON response&#39;&#39;&#39;

        return VectorColumnInfo(
            FeatureDataType.from_string(response.data_type),
            Measurement.from_response(response.measurement)
        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.VectorColumnInfo:
        &#39;&#39;&#39;Convert to a dictionary&#39;&#39;&#39;

        return geoengine_openapi_client.VectorColumnInfo(
            data_type=self.data_type.to_api_enum(),
            measurement=self.measurement.to_api_dict(),
        )


@dataclass(repr=False)
class RasterBandDescriptor:
    &#39;&#39;&#39;A raster band descriptor&#39;&#39;&#39;

    name: str
    measurement: Measurement

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.RasterBandDescriptor) -&gt; RasterBandDescriptor:
        &#39;&#39;&#39;Parse an http response to a `Provenance` object&#39;&#39;&#39;
        return RasterBandDescriptor(response.name, Measurement.from_response(response.measurement))

    def to_api_dict(self) -&gt; geoengine_openapi_client.RasterBandDescriptor:
        return geoengine_openapi_client.RasterBandDescriptor(
            name=self.name,
            measurement=self.measurement.to_api_dict(),
        )

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a raster band descriptor&#39;&#39;&#39;
        return f&#39;{self.name}: {self.measurement}&#39;


class RasterResultDescriptor(ResultDescriptor):
    &#39;&#39;&#39;
    A raster result descriptor
    &#39;&#39;&#39;
    __data_type: Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;]
    __bands: List[RasterBandDescriptor]
    __spatial_bounds: Optional[SpatialPartition2D]

    def __init__(  # pylint: disable=too-many-arguments,too-many-positional-arguments
        self,
        data_type: Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;],
        bands: List[RasterBandDescriptor],
        spatial_reference: str,
        time_bounds: Optional[TimeInterval] = None,
        spatial_bounds: Optional[SpatialPartition2D] = None,
        spatial_resolution: Optional[SpatialResolution] = None
    ) -&gt; None:
        &#39;&#39;&#39;Initialize a new `RasterResultDescriptor`&#39;&#39;&#39;
        super().__init__(spatial_reference, time_bounds, spatial_resolution)
        self.__data_type = data_type
        self.__bands = bands
        self.__spatial_bounds = spatial_bounds

    def to_api_dict(self) -&gt; geoengine_openapi_client.TypedResultDescriptor:
        &#39;&#39;&#39;Convert the raster result descriptor to a dictionary&#39;&#39;&#39;

        return geoengine_openapi_client.TypedResultDescriptor(geoengine_openapi_client.TypedRasterResultDescriptor(
            type=&#39;raster&#39;,
            data_type=self.data_type,
            bands=[band.to_api_dict() for band in self.__bands],
            spatial_reference=self.spatial_reference,
            time=self.time_bounds.time_str if self.time_bounds is not None else None,
            bbox=self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
            resolution=self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None
        ))

    @staticmethod
    def from_response_raster(
            response: geoengine_openapi_client.TypedRasterResultDescriptor) -&gt; RasterResultDescriptor:
        &#39;&#39;&#39;Parse a raster result descriptor from an http response&#39;&#39;&#39;
        spatial_ref = response.spatial_reference
        data_type = response.data_type.value
        bands = [RasterBandDescriptor.from_response(band) for band in response.bands]

        time_bounds = None
        # FIXME: datetime can not represent our min max range
        # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
        #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
        spatial_bounds = None
        if response.bbox is not None:
            spatial_bounds = SpatialPartition2D.from_response(response.bbox)
        spatial_resolution = None
        if response.resolution is not None:
            spatial_resolution = SpatialResolution.from_response(response.resolution)

        return RasterResultDescriptor(
            data_type=data_type,
            bands=bands,
            spatial_reference=spatial_ref,
            time_bounds=time_bounds,
            spatial_bounds=spatial_bounds,
            spatial_resolution=spatial_resolution
        )

    @classmethod
    def is_raster_result(cls) -&gt; bool:
        return True

    @property
    def data_type(self) -&gt; Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;]:
        return self.__data_type

    @property
    def bands(self) -&gt; List[RasterBandDescriptor]:
        return self.__bands

    @property
    def spatial_bounds(self) -&gt; Optional[SpatialPartition2D]:
        return self.__spatial_bounds

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;

        return super().spatial_reference

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of the raster result descriptor&#39;&#39;&#39;
        r = &#39;&#39;
        r += f&#39;Data type:         {self.data_type}\n&#39;
        r += f&#39;Spatial Reference: {self.spatial_reference}\n&#39;
        r += &#39;Bands:\n&#39;

        for band in self.__bands:
            r += f&#39;    {band}\n&#39;

        return r


class PlotResultDescriptor(ResultDescriptor):
    &#39;&#39;&#39;
    A plot result descriptor
    &#39;&#39;&#39;

    __spatial_bounds: Optional[BoundingBox2D]

    def __init__(  # pylint: disable=too-many-arguments]
        self,
        spatial_reference: str,
        time_bounds: Optional[TimeInterval] = None,
        spatial_bounds: Optional[BoundingBox2D] = None
    ) -&gt; None:
        &#39;&#39;&#39;Initialize a new `PlotResultDescriptor`&#39;&#39;&#39;
        super().__init__(spatial_reference, time_bounds, None)
        self.__spatial_bounds = spatial_bounds

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of the plot result descriptor&#39;&#39;&#39;
        r = &#39;Plot Result&#39;

        return r

    @staticmethod
    def from_response_plot(response: geoengine_openapi_client.TypedPlotResultDescriptor) -&gt; PlotResultDescriptor:
        &#39;&#39;&#39;Create a new `PlotResultDescriptor` from a JSON response&#39;&#39;&#39;
        spatial_ref = response.spatial_reference

        time_bounds = None
        # FIXME: datetime can not represent our min max range
        # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
        #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
        spatial_bounds = None
        if response.bbox is not None:
            spatial_bounds = BoundingBox2D.from_response(response.bbox)

        return PlotResultDescriptor(
            spatial_reference=spatial_ref,
            time_bounds=time_bounds,
            spatial_bounds=spatial_bounds
        )

    @classmethod
    def is_plot_result(cls) -&gt; bool:
        return True

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;
        return super().spatial_reference

    @property
    def spatial_bounds(self) -&gt; Optional[BoundingBox2D]:
        return self.__spatial_bounds

    def to_api_dict(self) -&gt; geoengine_openapi_client.TypedResultDescriptor:
        &#39;&#39;&#39;Convert the plot result descriptor to a dictionary&#39;&#39;&#39;

        return geoengine_openapi_client.TypedResultDescriptor(geoengine_openapi_client.TypedPlotResultDescriptor(
            type=&#39;plot&#39;,
            spatial_reference=self.spatial_reference,
            data_type=&#39;Plot&#39;,
            time=self.time_bounds.time_str if self.time_bounds is not None else None,
            bbox=self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None
        ))


class VectorDataType(str, Enum):
    &#39;&#39;&#39;An enum of vector data types&#39;&#39;&#39;

    DATA = &#39;Data&#39;
    MULTI_POINT = &#39;MultiPoint&#39;
    MULTI_LINE_STRING = &#39;MultiLineString&#39;
    MULTI_POLYGON = &#39;MultiPolygon&#39;

    @classmethod
    def from_geopandas_type_name(cls, name: str) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from geopandas geometry type&#39;&#39;&#39;

        name_map = {
            &#34;Point&#34;: VectorDataType.MULTI_POINT,
            &#34;MultiPoint&#34;: VectorDataType.MULTI_POINT,
            &#34;Line&#34;: VectorDataType.MULTI_LINE_STRING,
            &#34;MultiLine&#34;: VectorDataType.MULTI_LINE_STRING,
            &#34;Polygon&#34;: VectorDataType.MULTI_POLYGON,
            &#34;MultiPolygon&#34;: VectorDataType.MULTI_POLYGON,
        }

        if name in name_map:
            return name_map[name]

        raise InputException(&#34;Invalid vector data type&#34;)

    def to_api_enum(self) -&gt; geoengine_openapi_client.VectorDataType:
        return geoengine_openapi_client.VectorDataType(self.value)

    @staticmethod
    def from_literal(literal: Literal[&#39;Data&#39;, &#39;MultiPoint&#39;, &#39;MultiLineString&#39;, &#39;MultiPolygon&#39;]) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from literal&#39;&#39;&#39;
        return VectorDataType(literal)

    @staticmethod
    def from_api_enum(data_type: geoengine_openapi_client.VectorDataType) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from API enum&#39;&#39;&#39;
        return VectorDataType(data_type.value)

    @staticmethod
    def from_string(string: str) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from string&#39;&#39;&#39;
        if string not in VectorDataType.__members__.values():
            raise InputException(&#34;Invalid vector data type: &#34; + string)
        return VectorDataType(string)


class TimeStepGranularity(Enum):
    &#39;&#39;&#39;An enum of time step granularities&#39;&#39;&#39;
    MILLIS = &#39;millis&#39;
    SECONDS = &#39;seconds&#39;
    MINUTES = &#39;minutes&#39;
    HOURS = &#39;hours&#39;
    DAYS = &#39;days&#39;
    MONTHS = &#39;months&#39;
    YEARS = &#39;years&#39;

    def to_api_enum(self) -&gt; geoengine_openapi_client.TimeGranularity:
        return geoengine_openapi_client.TimeGranularity(self.value)


@dataclass
class TimeStep:
    &#39;&#39;&#39;A time step that consists of a granularity and a step size&#39;&#39;&#39;
    step: int
    granularity: TimeStepGranularity

    def to_api_dict(self) -&gt; geoengine_openapi_client.TimeStep:
        return geoengine_openapi_client.TimeStep(
            step=self.step,
            granularity=self.granularity.to_api_enum(),
        )


@dataclass
class Provenance:
    &#39;&#39;&#39;Provenance information as triplet of citation, license and uri&#39;&#39;&#39;

    citation: str
    license: str
    uri: str

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.Provenance) -&gt; Provenance:
        &#39;&#39;&#39;Parse an http response to a `Provenance` object&#39;&#39;&#39;
        return Provenance(response.citation, response.license, response.uri)

    def to_api_dict(self) -&gt; geoengine_openapi_client.Provenance:
        return geoengine_openapi_client.Provenance(
            citation=self.citation,
            license=self.license,
            uri=self.uri,
        )


@dataclass
class ProvenanceEntry:
    &#39;&#39;&#39;Provenance of a dataset&#39;&#39;&#39;

    data: List[DataId]
    provenance: Provenance

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.ProvenanceEntry) -&gt; ProvenanceEntry:
        &#39;&#39;&#39;Parse an http response to a `ProvenanceEntry` object&#39;&#39;&#39;

        dataset = [DataId.from_response(data) for data in response.data]
        provenance = Provenance.from_response(response.provenance)

        return ProvenanceEntry(dataset, provenance)


class Symbology:
    &#39;&#39;&#39;Base class for symbology&#39;&#39;&#39;

    @abstractmethod
    def to_api_dict(self) -&gt; geoengine_openapi_client.Symbology:
        pass

    @staticmethod
    def from_response(response: geoengine_openapi_client.Symbology) -&gt; Symbology:
        &#39;&#39;&#39;Parse an http response to a `Symbology` object&#39;&#39;&#39;
        inner = response.actual_instance

        if isinstance(inner, (
                geoengine_openapi_client.PointSymbology,
                geoengine_openapi_client.LineSymbology,
                geoengine_openapi_client.PolygonSymbology)):
            # return VectorSymbology.from_response_vector(response)
            return VectorSymbology()  # TODO: implement
        if isinstance(inner, geoengine_openapi_client.RasterSymbology):
            return RasterSymbology.from_response_raster(inner)

        raise InputException(&#34;Invalid symbology type&#34;)


class VectorSymbology(Symbology):
    &#39;&#39;&#39;A vector symbology&#39;&#39;&#39;

    # TODO: implement

    def to_api_dict(self) -&gt; geoengine_openapi_client.Symbology:
        return None  # type: ignore


class RasterColorizer:
    &#39;&#39;&#39;Base class for raster colorizer&#39;&#39;&#39;

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.RasterColorizer) -&gt; RasterColorizer:
        &#39;&#39;&#39;Parse an http response to a `RasterColorizer` object&#39;&#39;&#39;
        inner = response.actual_instance

        if isinstance(inner, geoengine_openapi_client.SingleBandRasterColorizer):
            return SingleBandRasterColorizer.from_single_band_response(inner)

        raise GeoEngineException({&#34;message&#34;: &#34;Unknown RasterColorizer type&#34;})

    @abstractmethod
    def to_api_dict(self) -&gt; geoengine_openapi_client.RasterColorizer:
        pass


@dataclass
class SingleBandRasterColorizer(RasterColorizer):
    &#39;&#39;&#39;A raster colorizer for a specified band&#39;&#39;&#39;

    band: int
    band_colorizer: Colorizer

    @staticmethod
    def from_single_band_response(response: geoengine_openapi_client.SingleBandRasterColorizer) -&gt; RasterColorizer:
        return SingleBandRasterColorizer(
            response.band,
            Colorizer.from_response(response.band_colorizer)
        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.RasterColorizer:
        return geoengine_openapi_client.RasterColorizer(geoengine_openapi_client.SingleBandRasterColorizer(
            type=&#39;singleBand&#39;,
            band=self.band,
            band_colorizer=self.band_colorizer.to_api_dict(),
        ))


class RasterSymbology(Symbology):
    &#39;&#39;&#39;A raster symbology&#39;&#39;&#39;
    __opacity: float
    __raster_colorizer: RasterColorizer

    def __init__(self, raster_colorizer: RasterColorizer, opacity: float = 1.0) -&gt; None:
        &#39;&#39;&#39;Initialize a new `RasterSymbology`&#39;&#39;&#39;

        self.__raster_colorizer = raster_colorizer
        self.__opacity = opacity

    def to_api_dict(self) -&gt; geoengine_openapi_client.Symbology:
        &#39;&#39;&#39;Convert the raster symbology to a dictionary&#39;&#39;&#39;

        return geoengine_openapi_client.Symbology(geoengine_openapi_client.RasterSymbology(
            type=&#39;raster&#39;,
            raster_colorizer=self.__raster_colorizer.to_api_dict(),
            opacity=self.__opacity,
        ))

    @staticmethod
    def from_response_raster(response: geoengine_openapi_client.RasterSymbology) -&gt; RasterSymbology:
        &#39;&#39;&#39;Parse an http response to a `RasterSymbology` object&#39;&#39;&#39;

        raster_colorizer = RasterColorizer.from_response(response.raster_colorizer)

        return RasterSymbology(raster_colorizer, response.opacity)

    def __repr__(self) -&gt; str:
        return super().__repr__() + f&#34;({self.__raster_colorizer}, {self.__opacity})&#34;


class DataId:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;Base class for data ids&#39;&#39;&#39;
    @classmethod
    def from_response(cls, response: geoengine_openapi_client.DataId) -&gt; DataId:
        &#39;&#39;&#39;Parse an http response to a `DataId` object&#39;&#39;&#39;
        inner = response.actual_instance

        if isinstance(inner, geoengine_openapi_client.InternalDataId):
            return InternalDataId.from_response_internal(inner)
        if isinstance(inner, geoengine_openapi_client.ExternalDataId):
            return ExternalDataId.from_response_external(inner)

        raise GeoEngineException({&#34;message&#34;: &#34;Unknown DataId type&#34;})

    @abstractmethod
    def to_api_dict(self) -&gt; geoengine_openapi_client.DataId:
        pass


class InternalDataId(DataId):
    &#39;&#39;&#39;An internal data id&#39;&#39;&#39;

    __dataset_id: UUID

    def __init__(self, dataset_id: UUID):
        self.__dataset_id = dataset_id

    @classmethod
    def from_response_internal(cls, response: geoengine_openapi_client.InternalDataId) -&gt; InternalDataId:
        &#39;&#39;&#39;Parse an http response to a `InternalDataId` object&#39;&#39;&#39;
        return InternalDataId(UUID(response.dataset_id))

    def to_api_dict(self) -&gt; geoengine_openapi_client.DataId:
        return geoengine_openapi_client.DataId(geoengine_openapi_client.InternalDataId(
            type=&#34;internal&#34;,
            dataset_id=str(self.__dataset_id)
        ))

    def __str__(self) -&gt; str:
        return str(self.__dataset_id)

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of an internal data id&#39;&#39;&#39;
        return str(self)

    def __eq__(self, other) -&gt; bool:
        &#39;&#39;&#39;Check if two internal data ids are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.__dataset_id == other.__dataset_id  # pylint: disable=protected-access


class ExternalDataId(DataId):
    &#39;&#39;&#39;An external data id&#39;&#39;&#39;

    __provider_id: UUID
    __layer_id: str

    def __init__(self, provider_id: UUID, layer_id: str):
        self.__provider_id = provider_id
        self.__layer_id = layer_id

    @classmethod
    def from_response_external(cls, response: geoengine_openapi_client.ExternalDataId) -&gt; ExternalDataId:
        &#39;&#39;&#39;Parse an http response to a `ExternalDataId` object&#39;&#39;&#39;

        return ExternalDataId(UUID(response.provider_id), response.layer_id)

    def to_api_dict(self) -&gt; geoengine_openapi_client.DataId:
        return geoengine_openapi_client.DataId(geoengine_openapi_client.ExternalDataId(
            type=&#34;external&#34;,
            provider_id=str(self.__provider_id),
            layer_id=self.__layer_id,
        ))

    def __str__(self) -&gt; str:
        return f&#39;{self.__provider_id}:{self.__layer_id}&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of an external data id&#39;&#39;&#39;
        return str(self)

    def __eq__(self, other) -&gt; bool:
        &#39;&#39;&#39;Check if two external data ids are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.__provider_id == other.__provider_id and self.__layer_id == other.__layer_id  # pylint: disable=protected-access


class Measurement:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;
    Base class for measurements
    &#39;&#39;&#39;

    @staticmethod
    def from_response(response: geoengine_openapi_client.Measurement) -&gt; Measurement:
        &#39;&#39;&#39;
        Parse a result descriptor from an http response
        &#39;&#39;&#39;
        inner = response.actual_instance

        if isinstance(inner, geoengine_openapi_client.UnitlessMeasurement):
            return UnitlessMeasurement()
        if isinstance(inner, geoengine_openapi_client.ContinuousMeasurement):
            return ContinuousMeasurement.from_response_continuous(inner)
        if isinstance(inner, geoengine_openapi_client.ClassificationMeasurement):
            return ClassificationMeasurement.from_response_classification(inner)

        raise TypeException(&#39;Unknown `Measurement` type&#39;)

    @abstractmethod
    def to_api_dict(self) -&gt; geoengine_openapi_client.Measurement:
        pass


class UnitlessMeasurement(Measurement):
    &#39;&#39;&#39;A measurement that is unitless&#39;&#39;&#39;

    def __str__(self) -&gt; str:
        &#39;&#39;&#39;String representation of a unitless measurement&#39;&#39;&#39;
        return &#39;unitless&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a unitless measurement&#39;&#39;&#39;
        return str(self)

    def to_api_dict(self) -&gt; geoengine_openapi_client.Measurement:
        return geoengine_openapi_client.Measurement(geoengine_openapi_client.UnitlessMeasurement(
            type=&#39;unitless&#39;
        ))


class ContinuousMeasurement(Measurement):
    &#39;&#39;&#39;A measurement that is continuous&#39;&#39;&#39;

    __measurement: str
    __unit: Optional[str]

    def __init__(self, measurement: str, unit: Optional[str]) -&gt; None:
        &#39;&#39;&#39;Initialize a new `ContiuousMeasurement`&#39;&#39;&#39;

        super().__init__()

        self.__measurement = measurement
        self.__unit = unit

    @staticmethod
    def from_response_continuous(
            response: geoengine_openapi_client.ContinuousMeasurement) -&gt; ContinuousMeasurement:
        &#39;&#39;&#39;Initialize a new `ContiuousMeasurement from a JSON response&#39;&#39;&#39;

        return ContinuousMeasurement(response.measurement, response.unit)

    def __str__(self) -&gt; str:
        &#39;&#39;&#39;String representation of a continuous measurement&#39;&#39;&#39;

        if self.__unit is None:
            return self.__measurement

        return f&#39;{self.__measurement} ({self.__unit})&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a continuous measurement&#39;&#39;&#39;
        return str(self)

    def to_api_dict(self) -&gt; geoengine_openapi_client.Measurement:
        return geoengine_openapi_client.Measurement(geoengine_openapi_client.ContinuousMeasurement(
            type=&#39;continuous&#39;,
            measurement=self.__measurement,
            unit=self.__unit
        ))

    @property
    def measurement(self) -&gt; str:
        return self.__measurement

    @property
    def unit(self) -&gt; Optional[str]:
        return self.__unit


class ClassificationMeasurement(Measurement):
    &#39;&#39;&#39;A measurement that is a classification&#39;&#39;&#39;

    __measurement: str
    __classes: Dict[int, str]

    def __init__(self, measurement: str, classes: Dict[int, str]) -&gt; None:
        &#39;&#39;&#39;Initialize a new `ClassificationMeasurement`&#39;&#39;&#39;

        super().__init__()

        self.__measurement = measurement
        self.__classes = classes

    @staticmethod
    def from_response_classification(
        response: geoengine_openapi_client.ClassificationMeasurement
    ) -&gt; ClassificationMeasurement:
        &#39;&#39;&#39;Initialize a new `ClassificationMeasurement from a JSON response&#39;&#39;&#39;

        measurement = response.measurement

        str_classes: Dict[str, str] = response.classes
        classes = {int(k): v for k, v in str_classes.items()}

        return ClassificationMeasurement(measurement, classes)

    def to_api_dict(self) -&gt; geoengine_openapi_client.Measurement:
        str_classes: Dict[str, str] = {str(k): v for k, v in self.__classes.items()}

        return geoengine_openapi_client.Measurement(geoengine_openapi_client.ClassificationMeasurement(
            type=&#39;classification&#39;,
            measurement=self.__measurement,
            classes=str_classes
        ))

    def __str__(self) -&gt; str:
        &#39;&#39;&#39;String representation of a classification measurement&#39;&#39;&#39;
        classes_str = &#39;, &#39;.join(f&#39;{k}: {v}&#39; for k, v in self.__classes.items())
        return f&#39;{self.__measurement} ({classes_str})&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a classification measurement&#39;&#39;&#39;
        return str(self)

    @property
    def measurement(self) -&gt; str:
        return self.__measurement

    @property
    def classes(self) -&gt; Dict[int, str]:
        return self.__classes


class GeoTransform:
    &#39;&#39;&#39;The `GeoTransform` specifies the relationship between pixel coordinates and geographic coordinates.&#39;&#39;&#39;

    x_min: float
    y_max: float
    &#39;&#39;&#39;In Geo Engine, x_pixel_size is always positive.&#39;&#39;&#39;
    x_pixel_size: float
    &#39;&#39;&#39;In Geo Engine, y_pixel_size is always negative.&#39;&#39;&#39;
    y_pixel_size: float

    def __init__(self, x_min: float, y_max: float, x_pixel_size: float, y_pixel_size: float):
        &#39;&#39;&#39;Initialize a new `GeoTransform`&#39;&#39;&#39;

        assert x_pixel_size &gt; 0, &#39;In Geo Engine, x_pixel_size is always positive.&#39;
        assert y_pixel_size &lt; 0, &#39;In Geo Engine, y_pixel_size is always negative.&#39;

        self.x_min = x_min
        self.y_max = y_max
        self.x_pixel_size = x_pixel_size
        self.y_pixel_size = y_pixel_size

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.GdalDatasetGeoTransform) -&gt; GeoTransform:
        &#39;&#39;&#39;Parse a geotransform from an HTTP JSON response&#39;&#39;&#39;

        return GeoTransform(
            x_min=response.origin_coordinate.x,
            y_max=response.origin_coordinate.y,
            x_pixel_size=response.x_pixel_size,
            y_pixel_size=response.y_pixel_size,
        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.GdalDatasetGeoTransform:
        return geoengine_openapi_client.GdalDatasetGeoTransform(
            origin_coordinate=geoengine_openapi_client.Coordinate2D(
                x=self.x_min,
                y=self.y_max,
            ),
            x_pixel_size=self.x_pixel_size,
            y_pixel_size=self.y_pixel_size
        )

    def to_gdal(self) -&gt; Tuple[float, float, float, float, float, float]:
        &#39;&#39;&#39;Convert to a GDAL geotransform&#39;&#39;&#39;
        return (self.x_min, self.x_pixel_size, 0, self.y_max, 0, self.y_pixel_size)

    def __str__(self) -&gt; str:
        return f&#39;Origin: ({self.x_min}, {self.y_max}), &#39; \
            f&#39;X Pixel Size: {self.x_pixel_size}, &#39; \
            f&#39;Y Pixel Size: {self.y_pixel_size}&#39;

    def __repr__(self) -&gt; str:
        return str(self)

    @property
    def x_half_pixel_size(self) -&gt; float:
        return self.x_pixel_size / 2.0

    @property
    def y_half_pixel_size(self) -&gt; float:
        return self.y_pixel_size / 2.0

    def x_max(self, number_of_pixels: int) -&gt; float:
        return self.x_min + number_of_pixels * self.x_pixel_size

    def y_min(self, number_of_pixels: int) -&gt; float:
        return self.y_max + number_of_pixels * self.y_pixel_size

    def coord_to_pixel_ul(self, x_cord: float, y_coord: float) -&gt; Tuple[int, int]:
        &#39;&#39;&#39;Convert a coordinate to a pixel index rould towards top left&#39;&#39;&#39;
        return (int(np.floor((x_cord - self.x_min) / self.x_pixel_size)),
                int(np.ceil((y_coord - self.y_max) / self.y_pixel_size)))

    def coord_to_pixel_lr(self, x_cord: float, y_coord: float) -&gt; Tuple[int, int]:
        &#39;&#39;&#39;Convert a coordinate to a pixel index ound towards lower right&#39;&#39;&#39;
        return (int(np.ceil((x_cord - self.x_min) / self.x_pixel_size)),
                int(np.floor((y_coord - self.y_max) / self.y_pixel_size)))

    def spatial_resolution(self) -&gt; SpatialResolution:
        return SpatialResolution(
            x_resolution=abs(self.x_pixel_size),
            y_resolution=abs(self.y_pixel_size)
        )

    def __eq__(self, other) -&gt; bool:
        &#39;&#39;&#39;Check if two geotransforms are equal&#39;&#39;&#39;
        if not isinstance(other, GeoTransform):
            return False

        return self.x_min == other.x_min and self.y_max == other.y_max and \
            self.x_pixel_size == other.x_pixel_size and self.y_pixel_size == other.y_pixel_size</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="geoengine.types.BoundingBox2D"><code class="flex name class">
<span>class <span class="ident">BoundingBox2D</span></span>
<span>(</span><span>xmin:float, ymin:float, xmax:float, ymax:float)</span>
</code></dt>
<dd>
<div class="desc"><p>'A 2D bounding box.</p>
<p>Initialize a new <code><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoundingBox2D(SpatialBounds):
    &#39;&#39;&#39;&#39;A 2D bounding box.&#39;&#39;&#39;

    def to_api_dict(self) -&gt; geoengine_openapi_client.BoundingBox2D:
        return geoengine_openapi_client.BoundingBox2D(
            lower_left_coordinate=geoengine_openapi_client.Coordinate2D(
                x=self.xmin,
                y=self.ymin,
            ),
            upper_right_coordinate=geoengine_openapi_client.Coordinate2D(
                x=self.xmax,
                y=self.ymax,
            ),
        )

    @staticmethod
    def from_response(response: geoengine_openapi_client.BoundingBox2D) -&gt; BoundingBox2D:
        &#39;&#39;&#39;create a `BoundingBox2D` from an API response&#39;&#39;&#39;
        lower_left = response.lower_left_coordinate
        upper_right = response.upper_right_coordinate

        return BoundingBox2D(
            lower_left.x,
            lower_left.y,
            upper_right.x,
            upper_right.y,
        )

    def __repr__(self) -&gt; str:
        return f&#39;BoundingBox2D(xmin={self.xmin}, ymin={self.ymin}, xmax={self.xmax}, ymax={self.ymax})&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.BoundingBox2D.xmax"><code class="name">var <span class="ident">xmax</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.BoundingBox2D.xmin"><code class="name">var <span class="ident">xmin</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.BoundingBox2D.ymax"><code class="name">var <span class="ident">ymax</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.BoundingBox2D.ymin"><code class="name">var <span class="ident">ymin</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.BoundingBox2D.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:geoengine_openapi_client.BoundingBox2D) ><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>create a <code><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></code> from an API response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: geoengine_openapi_client.BoundingBox2D) -&gt; BoundingBox2D:
    &#39;&#39;&#39;create a `BoundingBox2D` from an API response&#39;&#39;&#39;
    lower_left = response.lower_left_coordinate
    upper_right = response.upper_right_coordinate

    return BoundingBox2D(
        lower_left.x,
        lower_left.y,
        upper_right.x,
        upper_right.y,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.BoundingBox2D.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.bounding_box2_d.BoundingBox2D</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.BoundingBox2D:
    return geoengine_openapi_client.BoundingBox2D(
        lower_left_coordinate=geoengine_openapi_client.Coordinate2D(
            x=self.xmin,
            y=self.ymin,
        ),
        upper_right_coordinate=geoengine_openapi_client.Coordinate2D(
            x=self.xmax,
            y=self.ymax,
        ),
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.SpatialBounds.as_bbox_str" href="#geoengine.types.SpatialBounds.as_bbox_str">as_bbox_str</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.as_bbox_tuple" href="#geoengine.types.SpatialBounds.as_bbox_tuple">as_bbox_tuple</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.x_axis_size" href="#geoengine.types.SpatialBounds.x_axis_size">x_axis_size</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.y_axis_size" href="#geoengine.types.SpatialBounds.y_axis_size">y_axis_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.ClassificationMeasurement"><code class="flex name class">
<span>class <span class="ident">ClassificationMeasurement</span></span>
<span>(</span><span>measurement:str, classes:Dict[int,str])</span>
</code></dt>
<dd>
<div class="desc"><p>A measurement that is a classification</p>
<p>Initialize a new <code><a title="geoengine.types.ClassificationMeasurement" href="#geoengine.types.ClassificationMeasurement">ClassificationMeasurement</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ClassificationMeasurement(Measurement):
    &#39;&#39;&#39;A measurement that is a classification&#39;&#39;&#39;

    __measurement: str
    __classes: Dict[int, str]

    def __init__(self, measurement: str, classes: Dict[int, str]) -&gt; None:
        &#39;&#39;&#39;Initialize a new `ClassificationMeasurement`&#39;&#39;&#39;

        super().__init__()

        self.__measurement = measurement
        self.__classes = classes

    @staticmethod
    def from_response_classification(
        response: geoengine_openapi_client.ClassificationMeasurement
    ) -&gt; ClassificationMeasurement:
        &#39;&#39;&#39;Initialize a new `ClassificationMeasurement from a JSON response&#39;&#39;&#39;

        measurement = response.measurement

        str_classes: Dict[str, str] = response.classes
        classes = {int(k): v for k, v in str_classes.items()}

        return ClassificationMeasurement(measurement, classes)

    def to_api_dict(self) -&gt; geoengine_openapi_client.Measurement:
        str_classes: Dict[str, str] = {str(k): v for k, v in self.__classes.items()}

        return geoengine_openapi_client.Measurement(geoengine_openapi_client.ClassificationMeasurement(
            type=&#39;classification&#39;,
            measurement=self.__measurement,
            classes=str_classes
        ))

    def __str__(self) -&gt; str:
        &#39;&#39;&#39;String representation of a classification measurement&#39;&#39;&#39;
        classes_str = &#39;, &#39;.join(f&#39;{k}: {v}&#39; for k, v in self.__classes.items())
        return f&#39;{self.__measurement} ({classes_str})&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a classification measurement&#39;&#39;&#39;
        return str(self)

    @property
    def measurement(self) -&gt; str:
        return self.__measurement

    @property
    def classes(self) -&gt; Dict[int, str]:
        return self.__classes</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.ClassificationMeasurement.from_response_classification"><code class="name flex">
<span>def <span class="ident">from_response_classification</span></span>(<span>response:geoengine_openapi_client.ClassificationMeasurement) ><a title="geoengine.types.ClassificationMeasurement" href="#geoengine.types.ClassificationMeasurement">ClassificationMeasurement</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a new `ClassificationMeasurement from a JSON response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_classification(
    response: geoengine_openapi_client.ClassificationMeasurement
) -&gt; ClassificationMeasurement:
    &#39;&#39;&#39;Initialize a new `ClassificationMeasurement from a JSON response&#39;&#39;&#39;

    measurement = response.measurement

    str_classes: Dict[str, str] = response.classes
    classes = {int(k): v for k, v in str_classes.items()}

    return ClassificationMeasurement(measurement, classes)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.ClassificationMeasurement.classes"><code class="name">var <span class="ident">classes</span> :Dict[int,str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def classes(self) -&gt; Dict[int, str]:
    return self.__classes</code></pre>
</details>
</dd>
<dt id="geoengine.types.ClassificationMeasurement.measurement"><code class="name">var <span class="ident">measurement</span> :str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def measurement(self) -&gt; str:
    return self.__measurement</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.ClassificationMeasurement.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.measurement.Measurement</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.Measurement:
    str_classes: Dict[str, str] = {str(k): v for k, v in self.__classes.items()}

    return geoengine_openapi_client.Measurement(geoengine_openapi_client.ClassificationMeasurement(
        type=&#39;classification&#39;,
        measurement=self.__measurement,
        classes=str_classes
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.Measurement.from_response" href="#geoengine.types.Measurement.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.ContinuousMeasurement"><code class="flex name class">
<span>class <span class="ident">ContinuousMeasurement</span></span>
<span>(</span><span>measurement:str, unit:Optional[str])</span>
</code></dt>
<dd>
<div class="desc"><p>A measurement that is continuous</p>
<p>Initialize a new <code>ContiuousMeasurement</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ContinuousMeasurement(Measurement):
    &#39;&#39;&#39;A measurement that is continuous&#39;&#39;&#39;

    __measurement: str
    __unit: Optional[str]

    def __init__(self, measurement: str, unit: Optional[str]) -&gt; None:
        &#39;&#39;&#39;Initialize a new `ContiuousMeasurement`&#39;&#39;&#39;

        super().__init__()

        self.__measurement = measurement
        self.__unit = unit

    @staticmethod
    def from_response_continuous(
            response: geoengine_openapi_client.ContinuousMeasurement) -&gt; ContinuousMeasurement:
        &#39;&#39;&#39;Initialize a new `ContiuousMeasurement from a JSON response&#39;&#39;&#39;

        return ContinuousMeasurement(response.measurement, response.unit)

    def __str__(self) -&gt; str:
        &#39;&#39;&#39;String representation of a continuous measurement&#39;&#39;&#39;

        if self.__unit is None:
            return self.__measurement

        return f&#39;{self.__measurement} ({self.__unit})&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a continuous measurement&#39;&#39;&#39;
        return str(self)

    def to_api_dict(self) -&gt; geoengine_openapi_client.Measurement:
        return geoengine_openapi_client.Measurement(geoengine_openapi_client.ContinuousMeasurement(
            type=&#39;continuous&#39;,
            measurement=self.__measurement,
            unit=self.__unit
        ))

    @property
    def measurement(self) -&gt; str:
        return self.__measurement

    @property
    def unit(self) -&gt; Optional[str]:
        return self.__unit</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.ContinuousMeasurement.from_response_continuous"><code class="name flex">
<span>def <span class="ident">from_response_continuous</span></span>(<span>response:geoengine_openapi_client.ContinuousMeasurement) ><a title="geoengine.types.ContinuousMeasurement" href="#geoengine.types.ContinuousMeasurement">ContinuousMeasurement</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize a new `ContiuousMeasurement from a JSON response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_continuous(
        response: geoengine_openapi_client.ContinuousMeasurement) -&gt; ContinuousMeasurement:
    &#39;&#39;&#39;Initialize a new `ContiuousMeasurement from a JSON response&#39;&#39;&#39;

    return ContinuousMeasurement(response.measurement, response.unit)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.ContinuousMeasurement.measurement"><code class="name">var <span class="ident">measurement</span> :str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def measurement(self) -&gt; str:
    return self.__measurement</code></pre>
</details>
</dd>
<dt id="geoengine.types.ContinuousMeasurement.unit"><code class="name">var <span class="ident">unit</span> :Optional[str]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def unit(self) -&gt; Optional[str]:
    return self.__unit</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.ContinuousMeasurement.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.measurement.Measurement</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.Measurement:
    return geoengine_openapi_client.Measurement(geoengine_openapi_client.ContinuousMeasurement(
        type=&#39;continuous&#39;,
        measurement=self.__measurement,
        unit=self.__unit
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.Measurement.from_response" href="#geoengine.types.Measurement.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.DataId"><code class="flex name class">
<span>class <span class="ident">DataId</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for data ids</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DataId:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;Base class for data ids&#39;&#39;&#39;
    @classmethod
    def from_response(cls, response: geoengine_openapi_client.DataId) -&gt; DataId:
        &#39;&#39;&#39;Parse an http response to a `DataId` object&#39;&#39;&#39;
        inner = response.actual_instance

        if isinstance(inner, geoengine_openapi_client.InternalDataId):
            return InternalDataId.from_response_internal(inner)
        if isinstance(inner, geoengine_openapi_client.ExternalDataId):
            return ExternalDataId.from_response_external(inner)

        raise GeoEngineException({&#34;message&#34;: &#34;Unknown DataId type&#34;})

    @abstractmethod
    def to_api_dict(self) -&gt; geoengine_openapi_client.DataId:
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geoengine.types.ExternalDataId" href="#geoengine.types.ExternalDataId">ExternalDataId</a></li>
<li><a title="geoengine.types.InternalDataId" href="#geoengine.types.InternalDataId">InternalDataId</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.DataId.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:geoengine_openapi_client.DataId) ><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response(cls, response: geoengine_openapi_client.DataId) -&gt; DataId:
    &#39;&#39;&#39;Parse an http response to a `DataId` object&#39;&#39;&#39;
    inner = response.actual_instance

    if isinstance(inner, geoengine_openapi_client.InternalDataId):
        return InternalDataId.from_response_internal(inner)
    if isinstance(inner, geoengine_openapi_client.ExternalDataId):
        return ExternalDataId.from_response_external(inner)

    raise GeoEngineException({&#34;message&#34;: &#34;Unknown DataId type&#34;})</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.DataId.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.data_id.DataId</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_api_dict(self) -&gt; geoengine_openapi_client.DataId:
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.ExternalDataId"><code class="flex name class">
<span>class <span class="ident">ExternalDataId</span></span>
<span>(</span><span>provider_id:UUID, layer_id:str)</span>
</code></dt>
<dd>
<div class="desc"><p>An external data id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExternalDataId(DataId):
    &#39;&#39;&#39;An external data id&#39;&#39;&#39;

    __provider_id: UUID
    __layer_id: str

    def __init__(self, provider_id: UUID, layer_id: str):
        self.__provider_id = provider_id
        self.__layer_id = layer_id

    @classmethod
    def from_response_external(cls, response: geoengine_openapi_client.ExternalDataId) -&gt; ExternalDataId:
        &#39;&#39;&#39;Parse an http response to a `ExternalDataId` object&#39;&#39;&#39;

        return ExternalDataId(UUID(response.provider_id), response.layer_id)

    def to_api_dict(self) -&gt; geoengine_openapi_client.DataId:
        return geoengine_openapi_client.DataId(geoengine_openapi_client.ExternalDataId(
            type=&#34;external&#34;,
            provider_id=str(self.__provider_id),
            layer_id=self.__layer_id,
        ))

    def __str__(self) -&gt; str:
        return f&#39;{self.__provider_id}:{self.__layer_id}&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of an external data id&#39;&#39;&#39;
        return str(self)

    def __eq__(self, other) -&gt; bool:
        &#39;&#39;&#39;Check if two external data ids are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.__provider_id == other.__provider_id and self.__layer_id == other.__layer_id  # pylint: disable=protected-access</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.ExternalDataId.from_response_external"><code class="name flex">
<span>def <span class="ident">from_response_external</span></span>(<span>response:geoengine_openapi_client.ExternalDataId) ><a title="geoengine.types.ExternalDataId" href="#geoengine.types.ExternalDataId">ExternalDataId</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.ExternalDataId" href="#geoengine.types.ExternalDataId">ExternalDataId</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response_external(cls, response: geoengine_openapi_client.ExternalDataId) -&gt; ExternalDataId:
    &#39;&#39;&#39;Parse an http response to a `ExternalDataId` object&#39;&#39;&#39;

    return ExternalDataId(UUID(response.provider_id), response.layer_id)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.ExternalDataId.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.data_id.DataId</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.DataId:
    return geoengine_openapi_client.DataId(geoengine_openapi_client.ExternalDataId(
        type=&#34;external&#34;,
        provider_id=str(self.__provider_id),
        layer_id=self.__layer_id,
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.DataId.from_response" href="#geoengine.types.DataId.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.FeatureDataType"><code class="flex name class">
<span>class <span class="ident">FeatureDataType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Vector column data type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FeatureDataType(str, Enum):
    &#39;&#39;&#39;Vector column data type&#39;&#39;&#39;

    CATEGORY = &#34;category&#34;
    INT = &#34;int&#34;
    FLOAT = &#34;float&#34;
    TEXT = &#34;text&#34;
    BOOL = &#34;bool&#34;
    DATETIME = &#34;dateTime&#34;

    @staticmethod
    def from_string(data_type: str) -&gt; FeatureDataType:
        &#39;&#39;&#39;Create a new `VectorColumnDataType` from a string&#39;&#39;&#39;

        return FeatureDataType(data_type)

    def to_api_enum(self) -&gt; geoengine_openapi_client.FeatureDataType:
        &#39;&#39;&#39;Convert to an API enum&#39;&#39;&#39;

        return geoengine_openapi_client.FeatureDataType(self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.FeatureDataType.BOOL"><code class="name">var <span class="ident">BOOL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.FeatureDataType.CATEGORY"><code class="name">var <span class="ident">CATEGORY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.FeatureDataType.DATETIME"><code class="name">var <span class="ident">DATETIME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.FeatureDataType.FLOAT"><code class="name">var <span class="ident">FLOAT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.FeatureDataType.INT"><code class="name">var <span class="ident">INT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.FeatureDataType.TEXT"><code class="name">var <span class="ident">TEXT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.FeatureDataType.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>data_type:str) ><a title="geoengine.types.FeatureDataType" href="#geoengine.types.FeatureDataType">FeatureDataType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code>VectorColumnDataType</code> from a string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_string(data_type: str) -&gt; FeatureDataType:
    &#39;&#39;&#39;Create a new `VectorColumnDataType` from a string&#39;&#39;&#39;

    return FeatureDataType(data_type)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.FeatureDataType.to_api_enum"><code class="name flex">
<span>def <span class="ident">to_api_enum</span></span>(<span>self) >geoengine_openapi_client.models.feature_data_type.FeatureDataType</span>
</code></dt>
<dd>
<div class="desc"><p>Convert to an API enum</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_enum(self) -&gt; geoengine_openapi_client.FeatureDataType:
    &#39;&#39;&#39;Convert to an API enum&#39;&#39;&#39;

    return geoengine_openapi_client.FeatureDataType(self.value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.GeoTransform"><code class="flex name class">
<span>class <span class="ident">GeoTransform</span></span>
<span>(</span><span>x_min:float, y_max:float, x_pixel_size:float, y_pixel_size:float)</span>
</code></dt>
<dd>
<div class="desc"><p>The <code><a title="geoengine.types.GeoTransform" href="#geoengine.types.GeoTransform">GeoTransform</a></code> specifies the relationship between pixel coordinates and geographic coordinates.</p>
<p>Initialize a new <code><a title="geoengine.types.GeoTransform" href="#geoengine.types.GeoTransform">GeoTransform</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GeoTransform:
    &#39;&#39;&#39;The `GeoTransform` specifies the relationship between pixel coordinates and geographic coordinates.&#39;&#39;&#39;

    x_min: float
    y_max: float
    &#39;&#39;&#39;In Geo Engine, x_pixel_size is always positive.&#39;&#39;&#39;
    x_pixel_size: float
    &#39;&#39;&#39;In Geo Engine, y_pixel_size is always negative.&#39;&#39;&#39;
    y_pixel_size: float

    def __init__(self, x_min: float, y_max: float, x_pixel_size: float, y_pixel_size: float):
        &#39;&#39;&#39;Initialize a new `GeoTransform`&#39;&#39;&#39;

        assert x_pixel_size &gt; 0, &#39;In Geo Engine, x_pixel_size is always positive.&#39;
        assert y_pixel_size &lt; 0, &#39;In Geo Engine, y_pixel_size is always negative.&#39;

        self.x_min = x_min
        self.y_max = y_max
        self.x_pixel_size = x_pixel_size
        self.y_pixel_size = y_pixel_size

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.GdalDatasetGeoTransform) -&gt; GeoTransform:
        &#39;&#39;&#39;Parse a geotransform from an HTTP JSON response&#39;&#39;&#39;

        return GeoTransform(
            x_min=response.origin_coordinate.x,
            y_max=response.origin_coordinate.y,
            x_pixel_size=response.x_pixel_size,
            y_pixel_size=response.y_pixel_size,
        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.GdalDatasetGeoTransform:
        return geoengine_openapi_client.GdalDatasetGeoTransform(
            origin_coordinate=geoengine_openapi_client.Coordinate2D(
                x=self.x_min,
                y=self.y_max,
            ),
            x_pixel_size=self.x_pixel_size,
            y_pixel_size=self.y_pixel_size
        )

    def to_gdal(self) -&gt; Tuple[float, float, float, float, float, float]:
        &#39;&#39;&#39;Convert to a GDAL geotransform&#39;&#39;&#39;
        return (self.x_min, self.x_pixel_size, 0, self.y_max, 0, self.y_pixel_size)

    def __str__(self) -&gt; str:
        return f&#39;Origin: ({self.x_min}, {self.y_max}), &#39; \
            f&#39;X Pixel Size: {self.x_pixel_size}, &#39; \
            f&#39;Y Pixel Size: {self.y_pixel_size}&#39;

    def __repr__(self) -&gt; str:
        return str(self)

    @property
    def x_half_pixel_size(self) -&gt; float:
        return self.x_pixel_size / 2.0

    @property
    def y_half_pixel_size(self) -&gt; float:
        return self.y_pixel_size / 2.0

    def x_max(self, number_of_pixels: int) -&gt; float:
        return self.x_min + number_of_pixels * self.x_pixel_size

    def y_min(self, number_of_pixels: int) -&gt; float:
        return self.y_max + number_of_pixels * self.y_pixel_size

    def coord_to_pixel_ul(self, x_cord: float, y_coord: float) -&gt; Tuple[int, int]:
        &#39;&#39;&#39;Convert a coordinate to a pixel index rould towards top left&#39;&#39;&#39;
        return (int(np.floor((x_cord - self.x_min) / self.x_pixel_size)),
                int(np.ceil((y_coord - self.y_max) / self.y_pixel_size)))

    def coord_to_pixel_lr(self, x_cord: float, y_coord: float) -&gt; Tuple[int, int]:
        &#39;&#39;&#39;Convert a coordinate to a pixel index ound towards lower right&#39;&#39;&#39;
        return (int(np.ceil((x_cord - self.x_min) / self.x_pixel_size)),
                int(np.floor((y_coord - self.y_max) / self.y_pixel_size)))

    def spatial_resolution(self) -&gt; SpatialResolution:
        return SpatialResolution(
            x_resolution=abs(self.x_pixel_size),
            y_resolution=abs(self.y_pixel_size)
        )

    def __eq__(self, other) -&gt; bool:
        &#39;&#39;&#39;Check if two geotransforms are equal&#39;&#39;&#39;
        if not isinstance(other, GeoTransform):
            return False

        return self.x_min == other.x_min and self.y_max == other.y_max and \
            self.x_pixel_size == other.x_pixel_size and self.y_pixel_size == other.y_pixel_size</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.GeoTransform.x_min"><code class="name">var <span class="ident">x_min</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.GeoTransform.x_pixel_size"><code class="name">var <span class="ident">x_pixel_size</span> :float</code></dt>
<dd>
<div class="desc"><p>In Geo Engine, y_pixel_size is always negative.</p></div>
</dd>
<dt id="geoengine.types.GeoTransform.y_max"><code class="name">var <span class="ident">y_max</span> :float</code></dt>
<dd>
<div class="desc"><p>In Geo Engine, x_pixel_size is always positive.</p></div>
</dd>
<dt id="geoengine.types.GeoTransform.y_pixel_size"><code class="name">var <span class="ident">y_pixel_size</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.GeoTransform.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:geoengine_openapi_client.GdalDatasetGeoTransform) ><a title="geoengine.types.GeoTransform" href="#geoengine.types.GeoTransform">GeoTransform</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a geotransform from an HTTP JSON response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response(cls, response: geoengine_openapi_client.GdalDatasetGeoTransform) -&gt; GeoTransform:
    &#39;&#39;&#39;Parse a geotransform from an HTTP JSON response&#39;&#39;&#39;

    return GeoTransform(
        x_min=response.origin_coordinate.x,
        y_max=response.origin_coordinate.y,
        x_pixel_size=response.x_pixel_size,
        y_pixel_size=response.y_pixel_size,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.GeoTransform.x_half_pixel_size"><code class="name">var <span class="ident">x_half_pixel_size</span> :float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def x_half_pixel_size(self) -&gt; float:
    return self.x_pixel_size / 2.0</code></pre>
</details>
</dd>
<dt id="geoengine.types.GeoTransform.y_half_pixel_size"><code class="name">var <span class="ident">y_half_pixel_size</span> :float</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def y_half_pixel_size(self) -&gt; float:
    return self.y_pixel_size / 2.0</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.GeoTransform.coord_to_pixel_lr"><code class="name flex">
<span>def <span class="ident">coord_to_pixel_lr</span></span>(<span>self, x_cord:float, y_coord:float) >Tuple[int,int]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a coordinate to a pixel index ound towards lower right</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coord_to_pixel_lr(self, x_cord: float, y_coord: float) -&gt; Tuple[int, int]:
    &#39;&#39;&#39;Convert a coordinate to a pixel index ound towards lower right&#39;&#39;&#39;
    return (int(np.ceil((x_cord - self.x_min) / self.x_pixel_size)),
            int(np.floor((y_coord - self.y_max) / self.y_pixel_size)))</code></pre>
</details>
</dd>
<dt id="geoengine.types.GeoTransform.coord_to_pixel_ul"><code class="name flex">
<span>def <span class="ident">coord_to_pixel_ul</span></span>(<span>self, x_cord:float, y_coord:float) >Tuple[int,int]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a coordinate to a pixel index rould towards top left</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coord_to_pixel_ul(self, x_cord: float, y_coord: float) -&gt; Tuple[int, int]:
    &#39;&#39;&#39;Convert a coordinate to a pixel index rould towards top left&#39;&#39;&#39;
    return (int(np.floor((x_cord - self.x_min) / self.x_pixel_size)),
            int(np.ceil((y_coord - self.y_max) / self.y_pixel_size)))</code></pre>
</details>
</dd>
<dt id="geoengine.types.GeoTransform.spatial_resolution"><code class="name flex">
<span>def <span class="ident">spatial_resolution</span></span>(<span>self) ><a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def spatial_resolution(self) -&gt; SpatialResolution:
    return SpatialResolution(
        x_resolution=abs(self.x_pixel_size),
        y_resolution=abs(self.y_pixel_size)
    )</code></pre>
</details>
</dd>
<dt id="geoengine.types.GeoTransform.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.gdal_dataset_geo_transform.GdalDatasetGeoTransform</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.GdalDatasetGeoTransform:
    return geoengine_openapi_client.GdalDatasetGeoTransform(
        origin_coordinate=geoengine_openapi_client.Coordinate2D(
            x=self.x_min,
            y=self.y_max,
        ),
        x_pixel_size=self.x_pixel_size,
        y_pixel_size=self.y_pixel_size
    )</code></pre>
</details>
</dd>
<dt id="geoengine.types.GeoTransform.to_gdal"><code class="name flex">
<span>def <span class="ident">to_gdal</span></span>(<span>self) >Tuple[float,float,float,float,float,float]</span>
</code></dt>
<dd>
<div class="desc"><p>Convert to a GDAL geotransform</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_gdal(self) -&gt; Tuple[float, float, float, float, float, float]:
    &#39;&#39;&#39;Convert to a GDAL geotransform&#39;&#39;&#39;
    return (self.x_min, self.x_pixel_size, 0, self.y_max, 0, self.y_pixel_size)</code></pre>
</details>
</dd>
<dt id="geoengine.types.GeoTransform.x_max"><code class="name flex">
<span>def <span class="ident">x_max</span></span>(<span>self, number_of_pixels:int) >float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x_max(self, number_of_pixels: int) -&gt; float:
    return self.x_min + number_of_pixels * self.x_pixel_size</code></pre>
</details>
</dd>
<dt id="geoengine.types.GeoTransform.y_min"><code class="name flex">
<span>def <span class="ident">y_min</span></span>(<span>self, number_of_pixels:int) >float</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def y_min(self, number_of_pixels: int) -&gt; float:
    return self.y_max + number_of_pixels * self.y_pixel_size</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.InternalDataId"><code class="flex name class">
<span>class <span class="ident">InternalDataId</span></span>
<span>(</span><span>dataset_id:UUID)</span>
</code></dt>
<dd>
<div class="desc"><p>An internal data id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InternalDataId(DataId):
    &#39;&#39;&#39;An internal data id&#39;&#39;&#39;

    __dataset_id: UUID

    def __init__(self, dataset_id: UUID):
        self.__dataset_id = dataset_id

    @classmethod
    def from_response_internal(cls, response: geoengine_openapi_client.InternalDataId) -&gt; InternalDataId:
        &#39;&#39;&#39;Parse an http response to a `InternalDataId` object&#39;&#39;&#39;
        return InternalDataId(UUID(response.dataset_id))

    def to_api_dict(self) -&gt; geoengine_openapi_client.DataId:
        return geoengine_openapi_client.DataId(geoengine_openapi_client.InternalDataId(
            type=&#34;internal&#34;,
            dataset_id=str(self.__dataset_id)
        ))

    def __str__(self) -&gt; str:
        return str(self.__dataset_id)

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of an internal data id&#39;&#39;&#39;
        return str(self)

    def __eq__(self, other) -&gt; bool:
        &#39;&#39;&#39;Check if two internal data ids are equal&#39;&#39;&#39;
        if not isinstance(other, self.__class__):
            return False

        return self.__dataset_id == other.__dataset_id  # pylint: disable=protected-access</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.InternalDataId.from_response_internal"><code class="name flex">
<span>def <span class="ident">from_response_internal</span></span>(<span>response:geoengine_openapi_client.InternalDataId) ><a title="geoengine.types.InternalDataId" href="#geoengine.types.InternalDataId">InternalDataId</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.InternalDataId" href="#geoengine.types.InternalDataId">InternalDataId</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response_internal(cls, response: geoengine_openapi_client.InternalDataId) -&gt; InternalDataId:
    &#39;&#39;&#39;Parse an http response to a `InternalDataId` object&#39;&#39;&#39;
    return InternalDataId(UUID(response.dataset_id))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.InternalDataId.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.data_id.DataId</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.DataId:
    return geoengine_openapi_client.DataId(geoengine_openapi_client.InternalDataId(
        type=&#34;internal&#34;,
        dataset_id=str(self.__dataset_id)
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.DataId.from_response" href="#geoengine.types.DataId.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.Measurement"><code class="flex name class">
<span>class <span class="ident">Measurement</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for measurements</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Measurement:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;
    Base class for measurements
    &#39;&#39;&#39;

    @staticmethod
    def from_response(response: geoengine_openapi_client.Measurement) -&gt; Measurement:
        &#39;&#39;&#39;
        Parse a result descriptor from an http response
        &#39;&#39;&#39;
        inner = response.actual_instance

        if isinstance(inner, geoengine_openapi_client.UnitlessMeasurement):
            return UnitlessMeasurement()
        if isinstance(inner, geoengine_openapi_client.ContinuousMeasurement):
            return ContinuousMeasurement.from_response_continuous(inner)
        if isinstance(inner, geoengine_openapi_client.ClassificationMeasurement):
            return ClassificationMeasurement.from_response_classification(inner)

        raise TypeException(&#39;Unknown `Measurement` type&#39;)

    @abstractmethod
    def to_api_dict(self) -&gt; geoengine_openapi_client.Measurement:
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geoengine.types.ClassificationMeasurement" href="#geoengine.types.ClassificationMeasurement">ClassificationMeasurement</a></li>
<li><a title="geoengine.types.ContinuousMeasurement" href="#geoengine.types.ContinuousMeasurement">ContinuousMeasurement</a></li>
<li><a title="geoengine.types.UnitlessMeasurement" href="#geoengine.types.UnitlessMeasurement">UnitlessMeasurement</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.Measurement.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:geoengine_openapi_client.Measurement) ><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a result descriptor from an http response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: geoengine_openapi_client.Measurement) -&gt; Measurement:
    &#39;&#39;&#39;
    Parse a result descriptor from an http response
    &#39;&#39;&#39;
    inner = response.actual_instance

    if isinstance(inner, geoengine_openapi_client.UnitlessMeasurement):
        return UnitlessMeasurement()
    if isinstance(inner, geoengine_openapi_client.ContinuousMeasurement):
        return ContinuousMeasurement.from_response_continuous(inner)
    if isinstance(inner, geoengine_openapi_client.ClassificationMeasurement):
        return ClassificationMeasurement.from_response_classification(inner)

    raise TypeException(&#39;Unknown `Measurement` type&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.Measurement.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.measurement.Measurement</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_api_dict(self) -&gt; geoengine_openapi_client.Measurement:
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.PlotResultDescriptor"><code class="flex name class">
<span>class <span class="ident">PlotResultDescriptor</span></span>
<span>(</span><span>spatial_reference:str, time_bounds:Optional[<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a>]=None, spatial_bounds:Optional[<a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A plot result descriptor</p>
<p>Initialize a new <code><a title="geoengine.types.PlotResultDescriptor" href="#geoengine.types.PlotResultDescriptor">PlotResultDescriptor</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlotResultDescriptor(ResultDescriptor):
    &#39;&#39;&#39;
    A plot result descriptor
    &#39;&#39;&#39;

    __spatial_bounds: Optional[BoundingBox2D]

    def __init__(  # pylint: disable=too-many-arguments]
        self,
        spatial_reference: str,
        time_bounds: Optional[TimeInterval] = None,
        spatial_bounds: Optional[BoundingBox2D] = None
    ) -&gt; None:
        &#39;&#39;&#39;Initialize a new `PlotResultDescriptor`&#39;&#39;&#39;
        super().__init__(spatial_reference, time_bounds, None)
        self.__spatial_bounds = spatial_bounds

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of the plot result descriptor&#39;&#39;&#39;
        r = &#39;Plot Result&#39;

        return r

    @staticmethod
    def from_response_plot(response: geoengine_openapi_client.TypedPlotResultDescriptor) -&gt; PlotResultDescriptor:
        &#39;&#39;&#39;Create a new `PlotResultDescriptor` from a JSON response&#39;&#39;&#39;
        spatial_ref = response.spatial_reference

        time_bounds = None
        # FIXME: datetime can not represent our min max range
        # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
        #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
        spatial_bounds = None
        if response.bbox is not None:
            spatial_bounds = BoundingBox2D.from_response(response.bbox)

        return PlotResultDescriptor(
            spatial_reference=spatial_ref,
            time_bounds=time_bounds,
            spatial_bounds=spatial_bounds
        )

    @classmethod
    def is_plot_result(cls) -&gt; bool:
        return True

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;
        return super().spatial_reference

    @property
    def spatial_bounds(self) -&gt; Optional[BoundingBox2D]:
        return self.__spatial_bounds

    def to_api_dict(self) -&gt; geoengine_openapi_client.TypedResultDescriptor:
        &#39;&#39;&#39;Convert the plot result descriptor to a dictionary&#39;&#39;&#39;

        return geoengine_openapi_client.TypedResultDescriptor(geoengine_openapi_client.TypedPlotResultDescriptor(
            type=&#39;plot&#39;,
            spatial_reference=self.spatial_reference,
            data_type=&#39;Plot&#39;,
            time=self.time_bounds.time_str if self.time_bounds is not None else None,
            bbox=self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None
        ))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.PlotResultDescriptor.from_response_plot"><code class="name flex">
<span>def <span class="ident">from_response_plot</span></span>(<span>response:geoengine_openapi_client.TypedPlotResultDescriptor) ><a title="geoengine.types.PlotResultDescriptor" href="#geoengine.types.PlotResultDescriptor">PlotResultDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="geoengine.types.PlotResultDescriptor" href="#geoengine.types.PlotResultDescriptor">PlotResultDescriptor</a></code> from a JSON response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_plot(response: geoengine_openapi_client.TypedPlotResultDescriptor) -&gt; PlotResultDescriptor:
    &#39;&#39;&#39;Create a new `PlotResultDescriptor` from a JSON response&#39;&#39;&#39;
    spatial_ref = response.spatial_reference

    time_bounds = None
    # FIXME: datetime can not represent our min max range
    # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
    #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
    spatial_bounds = None
    if response.bbox is not None:
        spatial_bounds = BoundingBox2D.from_response(response.bbox)

    return PlotResultDescriptor(
        spatial_reference=spatial_ref,
        time_bounds=time_bounds,
        spatial_bounds=spatial_bounds
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.PlotResultDescriptor.spatial_bounds"><code class="name">var <span class="ident">spatial_bounds</span> :Optional[<a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_bounds(self) -&gt; Optional[BoundingBox2D]:
    return self.__spatial_bounds</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.PlotResultDescriptor.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.typed_result_descriptor.TypedResultDescriptor</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the plot result descriptor to a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.TypedResultDescriptor:
    &#39;&#39;&#39;Convert the plot result descriptor to a dictionary&#39;&#39;&#39;

    return geoengine_openapi_client.TypedResultDescriptor(geoengine_openapi_client.TypedPlotResultDescriptor(
        type=&#39;plot&#39;,
        spatial_reference=self.spatial_reference,
        data_type=&#39;Plot&#39;,
        time=self.time_bounds.time_str if self.time_bounds is not None else None,
        bbox=self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.ResultDescriptor.from_response" href="#geoengine.types.ResultDescriptor.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_plot_result" href="#geoengine.types.ResultDescriptor.is_plot_result">is_plot_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_raster_result" href="#geoengine.types.ResultDescriptor.is_raster_result">is_raster_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_vector_result" href="#geoengine.types.ResultDescriptor.is_vector_result">is_vector_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_reference" href="#geoengine.types.ResultDescriptor.spatial_reference">spatial_reference</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_resolution" href="#geoengine.types.ResultDescriptor.spatial_resolution">spatial_resolution</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.time_bounds" href="#geoengine.types.ResultDescriptor.time_bounds">time_bounds</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.Provenance"><code class="flex name class">
<span>class <span class="ident">Provenance</span></span>
<span>(</span><span>citation:str, license:str, uri:str)</span>
</code></dt>
<dd>
<div class="desc"><p>Provenance information as triplet of citation, license and uri</p>
<p>Method generated by attrs for class Provenance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Provenance:
    &#39;&#39;&#39;Provenance information as triplet of citation, license and uri&#39;&#39;&#39;

    citation: str
    license: str
    uri: str

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.Provenance) -&gt; Provenance:
        &#39;&#39;&#39;Parse an http response to a `Provenance` object&#39;&#39;&#39;
        return Provenance(response.citation, response.license, response.uri)

    def to_api_dict(self) -&gt; geoengine_openapi_client.Provenance:
        return geoengine_openapi_client.Provenance(
            citation=self.citation,
            license=self.license,
            uri=self.uri,
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.Provenance.citation"><code class="name">var <span class="ident">citation</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.Provenance.license"><code class="name">var <span class="ident">license</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.Provenance.uri"><code class="name">var <span class="ident">uri</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.Provenance.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:geoengine_openapi_client.Provenance) ><a title="geoengine.types.Provenance" href="#geoengine.types.Provenance">Provenance</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.Provenance" href="#geoengine.types.Provenance">Provenance</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response(cls, response: geoengine_openapi_client.Provenance) -&gt; Provenance:
    &#39;&#39;&#39;Parse an http response to a `Provenance` object&#39;&#39;&#39;
    return Provenance(response.citation, response.license, response.uri)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.Provenance.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.provenance.Provenance</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.Provenance:
    return geoengine_openapi_client.Provenance(
        citation=self.citation,
        license=self.license,
        uri=self.uri,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.ProvenanceEntry"><code class="flex name class">
<span>class <span class="ident">ProvenanceEntry</span></span>
<span>(</span><span>data:List[<a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a>], provenance:<a title="geoengine.types.Provenance" href="#geoengine.types.Provenance">Provenance</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Provenance of a dataset</p>
<p>Method generated by attrs for class ProvenanceEntry.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ProvenanceEntry:
    &#39;&#39;&#39;Provenance of a dataset&#39;&#39;&#39;

    data: List[DataId]
    provenance: Provenance

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.ProvenanceEntry) -&gt; ProvenanceEntry:
        &#39;&#39;&#39;Parse an http response to a `ProvenanceEntry` object&#39;&#39;&#39;

        dataset = [DataId.from_response(data) for data in response.data]
        provenance = Provenance.from_response(response.provenance)

        return ProvenanceEntry(dataset, provenance)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.ProvenanceEntry.data"><code class="name">var <span class="ident">data</span> :List[<a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.ProvenanceEntry.provenance"><code class="name">var <span class="ident">provenance</span> :<a title="geoengine.types.Provenance" href="#geoengine.types.Provenance">Provenance</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.ProvenanceEntry.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:geoengine_openapi_client.ProvenanceEntry) ><a title="geoengine.types.ProvenanceEntry" href="#geoengine.types.ProvenanceEntry">ProvenanceEntry</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.ProvenanceEntry" href="#geoengine.types.ProvenanceEntry">ProvenanceEntry</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response(cls, response: geoengine_openapi_client.ProvenanceEntry) -&gt; ProvenanceEntry:
    &#39;&#39;&#39;Parse an http response to a `ProvenanceEntry` object&#39;&#39;&#39;

    dataset = [DataId.from_response(data) for data in response.data]
    provenance = Provenance.from_response(response.provenance)

    return ProvenanceEntry(dataset, provenance)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.QueryRectangle"><code class="flex name class">
<span>class <span class="ident">QueryRectangle</span></span>
<span>(</span><span>spatial_bounds:Union[<a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a>,Tuple[float,float,float,float]], time_interval:Union[<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a>,Tuple[datetime,Optional[datetime]]], resolution:Union[<a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a>,Tuple[float,float]], srs='EPSG:4326')</span>
</code></dt>
<dd>
<div class="desc"><p>A multi-dimensional query rectangle, consisting of spatial and temporal information.</p>
<p>Initialize a new <code><a title="geoengine.types.QueryRectangle" href="#geoengine.types.QueryRectangle">QueryRectangle</a></code> object</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>spatial_bounds</code></strong></dt>
<dd>The spatial bounds of the query rectangle.
Either a <code><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></code> or a tuple of floats (xmin, ymin, xmax, ymax)</dd>
<dt><strong><code>time_interval</code></strong></dt>
<dd>The time interval of the query rectangle.
Either a <code><a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a></code> or a tuple of <code>datetime.datetime</code> objects (start, end)</dd>
<dt><strong><code>resolution</code></strong></dt>
<dd>The spatial resolution of the query rectangle.
Either a <code><a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a></code> or a tuple of floats (x_resolution, y_resolution)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class QueryRectangle:
    &#39;&#39;&#39;
    A multi-dimensional query rectangle, consisting of spatial and temporal information.
    &#39;&#39;&#39;

    __spatial_bounds: BoundingBox2D
    __time_interval: TimeInterval
    __resolution: SpatialResolution
    __srs: str

    def __init__(self,
                 spatial_bounds: Union[BoundingBox2D, Tuple[float, float, float, float]],
                 time_interval: Union[TimeInterval, Tuple[datetime, Optional[datetime]]],
                 resolution: Union[SpatialResolution, Tuple[float, float]],
                 srs=&#39;EPSG:4326&#39;) -&gt; None:
        &#34;&#34;&#34;
        Initialize a new `QueryRectangle` object

        Parameters
        ----------
        spatial_bounds
            The spatial bounds of the query rectangle.
            Either a `BoundingBox2D` or a tuple of floats (xmin, ymin, xmax, ymax)
        time_interval
            The time interval of the query rectangle.
            Either a `TimeInterval` or a tuple of `datetime.datetime` objects (start, end)
        resolution
            The spatial resolution of the query rectangle.
            Either a `SpatialResolution` or a tuple of floats (x_resolution, y_resolution)
        &#34;&#34;&#34;

        if not isinstance(spatial_bounds, BoundingBox2D):
            spatial_bounds = BoundingBox2D(*spatial_bounds)
        if not isinstance(time_interval, TimeInterval):
            time_interval = TimeInterval(*time_interval)
        if not isinstance(resolution, SpatialResolution):
            resolution = SpatialResolution(*resolution)

        self.__spatial_bounds = spatial_bounds
        self.__time_interval = time_interval
        self.__resolution = resolution
        self.__srs = srs

    @property
    def bbox_str(self) -&gt; str:
        &#39;&#39;&#39;
        A comma-separated string representation of the spatial bounds
        &#39;&#39;&#39;
        return self.__spatial_bounds.as_bbox_str()

    @property
    def bbox_ogc_str(self) -&gt; str:
        &#39;&#39;&#39;
        A comma-separated string representation of the spatial bounds with OGC axis ordering
        &#39;&#39;&#39;
        y_axis_first = self.__srs == &#34;EPSG:4326&#34;
        return self.__spatial_bounds.as_bbox_str(y_axis_first=y_axis_first)

    @property
    def bbox_ogc(self) -&gt; Tuple[float, float, float, float]:
        &#39;&#39;&#39;
        Return the bbox with OGC axis ordering of the srs
        &#39;&#39;&#39;

        # TODO: properly handle axis order
        y_axis_first = self.__srs == &#34;EPSG:4326&#34;
        return self.__spatial_bounds.as_bbox_tuple(y_axis_first=y_axis_first)

    @property
    def resolution_ogc(self) -&gt; Tuple[float, float]:
        &#39;&#39;&#39;
        Return the resolution in OGC style
        &#39;&#39;&#39;
        # TODO: properly handle axis order
        res = self.__resolution

        # TODO: why is the y resolution in this case negative but not in all other cases?
        if self.__srs == &#34;EPSG:4326&#34;:
            return (-res.y_resolution, res.x_resolution)

        return res.as_tuple()

    @property
    def time(self) -&gt; TimeInterval:
        &#39;&#39;&#39;
        Return the time instance or interval
        &#39;&#39;&#39;
        return self.__time_interval

    @property
    def spatial_bounds(self) -&gt; BoundingBox2D:
        &#39;&#39;&#39;
        Return the spatial bounds
        &#39;&#39;&#39;
        return self.__spatial_bounds

    @property
    def spatial_resolution(self) -&gt; SpatialResolution:
        &#39;&#39;&#39;
        Return the spatial resolution
        &#39;&#39;&#39;
        return self.__resolution

    @property
    def time_str(self) -&gt; str:
        &#39;&#39;&#39;
        Return the time instance or interval as a string representation
        &#39;&#39;&#39;
        return self.time.time_str

    @property
    def srs(self) -&gt; str:
        &#39;&#39;&#39;
        Return the SRS string
        &#39;&#39;&#39;
        return self.__srs

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39; Return a string representation of the query rectangle.&#39;&#39;&#39;
        r = &#39;QueryRectangle( \n&#39;
        r += &#39;    &#39; + repr(self.__spatial_bounds) + &#39;\n&#39;
        r += &#39;    &#39; + repr(self.__time_interval) + &#39;\n&#39;
        r += &#39;    &#39; + repr(self.__resolution) + &#39;\n&#39;
        r += f&#39;    srs={self.__srs} \n&#39;
        r += &#39;)&#39;
        return r

    def as_raster_query_rectangle_api_dict(self) -&gt; geoengine_openapi_client.RasterQueryRectangle:
        &#39;&#39;&#39;Return the query rectangle as a dictionary for the API&#39;&#39;&#39;
        return geoengine_openapi_client.RasterQueryRectangle(
            spatial_bounds=SpatialPartition2D(
                self.spatial_bounds.xmin,
                self.spatial_bounds.ymin,
                self.spatial_bounds.xmax,
                self.spatial_bounds.ymax,
            ).to_api_dict(),
            spatial_resolution=self.spatial_resolution.to_api_dict(),
            time_interval=self.time.to_api_dict(),
        )</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.QueryRectangle.bbox_ogc"><code class="name">var <span class="ident">bbox_ogc</span> :Tuple[float,float,float,float]</code></dt>
<dd>
<div class="desc"><p>Return the bbox with OGC axis ordering of the srs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bbox_ogc(self) -&gt; Tuple[float, float, float, float]:
    &#39;&#39;&#39;
    Return the bbox with OGC axis ordering of the srs
    &#39;&#39;&#39;

    # TODO: properly handle axis order
    y_axis_first = self.__srs == &#34;EPSG:4326&#34;
    return self.__spatial_bounds.as_bbox_tuple(y_axis_first=y_axis_first)</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.bbox_ogc_str"><code class="name">var <span class="ident">bbox_ogc_str</span> :str</code></dt>
<dd>
<div class="desc"><p>A comma-separated string representation of the spatial bounds with OGC axis ordering</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bbox_ogc_str(self) -&gt; str:
    &#39;&#39;&#39;
    A comma-separated string representation of the spatial bounds with OGC axis ordering
    &#39;&#39;&#39;
    y_axis_first = self.__srs == &#34;EPSG:4326&#34;
    return self.__spatial_bounds.as_bbox_str(y_axis_first=y_axis_first)</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.bbox_str"><code class="name">var <span class="ident">bbox_str</span> :str</code></dt>
<dd>
<div class="desc"><p>A comma-separated string representation of the spatial bounds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bbox_str(self) -&gt; str:
    &#39;&#39;&#39;
    A comma-separated string representation of the spatial bounds
    &#39;&#39;&#39;
    return self.__spatial_bounds.as_bbox_str()</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.resolution_ogc"><code class="name">var <span class="ident">resolution_ogc</span> :Tuple[float,float]</code></dt>
<dd>
<div class="desc"><p>Return the resolution in OGC style</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def resolution_ogc(self) -&gt; Tuple[float, float]:
    &#39;&#39;&#39;
    Return the resolution in OGC style
    &#39;&#39;&#39;
    # TODO: properly handle axis order
    res = self.__resolution

    # TODO: why is the y resolution in this case negative but not in all other cases?
    if self.__srs == &#34;EPSG:4326&#34;:
        return (-res.y_resolution, res.x_resolution)

    return res.as_tuple()</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.spatial_bounds"><code class="name">var <span class="ident">spatial_bounds</span> :<a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></code></dt>
<dd>
<div class="desc"><p>Return the spatial bounds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_bounds(self) -&gt; BoundingBox2D:
    &#39;&#39;&#39;
    Return the spatial bounds
    &#39;&#39;&#39;
    return self.__spatial_bounds</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.spatial_resolution"><code class="name">var <span class="ident">spatial_resolution</span> :<a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a></code></dt>
<dd>
<div class="desc"><p>Return the spatial resolution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_resolution(self) -&gt; SpatialResolution:
    &#39;&#39;&#39;
    Return the spatial resolution
    &#39;&#39;&#39;
    return self.__resolution</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.srs"><code class="name">var <span class="ident">srs</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the SRS string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def srs(self) -&gt; str:
    &#39;&#39;&#39;
    Return the SRS string
    &#39;&#39;&#39;
    return self.__srs</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.time"><code class="name">var <span class="ident">time</span> :<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a></code></dt>
<dd>
<div class="desc"><p>Return the time instance or interval</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time(self) -&gt; TimeInterval:
    &#39;&#39;&#39;
    Return the time instance or interval
    &#39;&#39;&#39;
    return self.__time_interval</code></pre>
</details>
</dd>
<dt id="geoengine.types.QueryRectangle.time_str"><code class="name">var <span class="ident">time_str</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the time instance or interval as a string representation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_str(self) -&gt; str:
    &#39;&#39;&#39;
    Return the time instance or interval as a string representation
    &#39;&#39;&#39;
    return self.time.time_str</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.QueryRectangle.as_raster_query_rectangle_api_dict"><code class="name flex">
<span>def <span class="ident">as_raster_query_rectangle_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.raster_query_rectangle.RasterQueryRectangle</span>
</code></dt>
<dd>
<div class="desc"><p>Return the query rectangle as a dictionary for the API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_raster_query_rectangle_api_dict(self) -&gt; geoengine_openapi_client.RasterQueryRectangle:
    &#39;&#39;&#39;Return the query rectangle as a dictionary for the API&#39;&#39;&#39;
    return geoengine_openapi_client.RasterQueryRectangle(
        spatial_bounds=SpatialPartition2D(
            self.spatial_bounds.xmin,
            self.spatial_bounds.ymin,
            self.spatial_bounds.xmax,
            self.spatial_bounds.ymax,
        ).to_api_dict(),
        spatial_resolution=self.spatial_resolution.to_api_dict(),
        time_interval=self.time.to_api_dict(),
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.RasterBandDescriptor"><code class="flex name class">
<span>class <span class="ident">RasterBandDescriptor</span></span>
<span>(</span><span>name:str, measurement:<a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A raster band descriptor</p>
<p>Method generated by attrs for class RasterBandDescriptor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass(repr=False)
class RasterBandDescriptor:
    &#39;&#39;&#39;A raster band descriptor&#39;&#39;&#39;

    name: str
    measurement: Measurement

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.RasterBandDescriptor) -&gt; RasterBandDescriptor:
        &#39;&#39;&#39;Parse an http response to a `Provenance` object&#39;&#39;&#39;
        return RasterBandDescriptor(response.name, Measurement.from_response(response.measurement))

    def to_api_dict(self) -&gt; geoengine_openapi_client.RasterBandDescriptor:
        return geoengine_openapi_client.RasterBandDescriptor(
            name=self.name,
            measurement=self.measurement.to_api_dict(),
        )

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a raster band descriptor&#39;&#39;&#39;
        return f&#39;{self.name}: {self.measurement}&#39;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.RasterBandDescriptor.measurement"><code class="name">var <span class="ident">measurement</span> :<a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.RasterBandDescriptor.name"><code class="name">var <span class="ident">name</span> :str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.RasterBandDescriptor.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:geoengine_openapi_client.RasterBandDescriptor) ><a title="geoengine.types.RasterBandDescriptor" href="#geoengine.types.RasterBandDescriptor">RasterBandDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.Provenance" href="#geoengine.types.Provenance">Provenance</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response(cls, response: geoengine_openapi_client.RasterBandDescriptor) -&gt; RasterBandDescriptor:
    &#39;&#39;&#39;Parse an http response to a `Provenance` object&#39;&#39;&#39;
    return RasterBandDescriptor(response.name, Measurement.from_response(response.measurement))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.RasterBandDescriptor.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.raster_band_descriptor.RasterBandDescriptor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.RasterBandDescriptor:
    return geoengine_openapi_client.RasterBandDescriptor(
        name=self.name,
        measurement=self.measurement.to_api_dict(),
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.RasterColorizer"><code class="flex name class">
<span>class <span class="ident">RasterColorizer</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for raster colorizer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RasterColorizer:
    &#39;&#39;&#39;Base class for raster colorizer&#39;&#39;&#39;

    @classmethod
    def from_response(cls, response: geoengine_openapi_client.RasterColorizer) -&gt; RasterColorizer:
        &#39;&#39;&#39;Parse an http response to a `RasterColorizer` object&#39;&#39;&#39;
        inner = response.actual_instance

        if isinstance(inner, geoengine_openapi_client.SingleBandRasterColorizer):
            return SingleBandRasterColorizer.from_single_band_response(inner)

        raise GeoEngineException({&#34;message&#34;: &#34;Unknown RasterColorizer type&#34;})

    @abstractmethod
    def to_api_dict(self) -&gt; geoengine_openapi_client.RasterColorizer:
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geoengine.types.SingleBandRasterColorizer" href="#geoengine.types.SingleBandRasterColorizer">SingleBandRasterColorizer</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.RasterColorizer.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:geoengine_openapi_client.RasterColorizer) ><a title="geoengine.types.RasterColorizer" href="#geoengine.types.RasterColorizer">RasterColorizer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.RasterColorizer" href="#geoengine.types.RasterColorizer">RasterColorizer</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_response(cls, response: geoengine_openapi_client.RasterColorizer) -&gt; RasterColorizer:
    &#39;&#39;&#39;Parse an http response to a `RasterColorizer` object&#39;&#39;&#39;
    inner = response.actual_instance

    if isinstance(inner, geoengine_openapi_client.SingleBandRasterColorizer):
        return SingleBandRasterColorizer.from_single_band_response(inner)

    raise GeoEngineException({&#34;message&#34;: &#34;Unknown RasterColorizer type&#34;})</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.RasterColorizer.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.raster_colorizer.RasterColorizer</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_api_dict(self) -&gt; geoengine_openapi_client.RasterColorizer:
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.RasterResultDescriptor"><code class="flex name class">
<span>class <span class="ident">RasterResultDescriptor</span></span>
<span>(</span><span>data_type:"Literal['U8','U16','U32','U64','I8','I16','I32','I64','F32','F64']", bands:List[<a title="geoengine.types.RasterBandDescriptor" href="#geoengine.types.RasterBandDescriptor">RasterBandDescriptor</a>], spatial_reference:str, time_bounds:Optional[<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a>]=None, spatial_bounds:Optional[<a title="geoengine.types.SpatialPartition2D" href="#geoengine.types.SpatialPartition2D">SpatialPartition2D</a>]=None, spatial_resolution:Optional[<a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A raster result descriptor</p>
<p>Initialize a new <code><a title="geoengine.types.RasterResultDescriptor" href="#geoengine.types.RasterResultDescriptor">RasterResultDescriptor</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RasterResultDescriptor(ResultDescriptor):
    &#39;&#39;&#39;
    A raster result descriptor
    &#39;&#39;&#39;
    __data_type: Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;]
    __bands: List[RasterBandDescriptor]
    __spatial_bounds: Optional[SpatialPartition2D]

    def __init__(  # pylint: disable=too-many-arguments,too-many-positional-arguments
        self,
        data_type: Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;],
        bands: List[RasterBandDescriptor],
        spatial_reference: str,
        time_bounds: Optional[TimeInterval] = None,
        spatial_bounds: Optional[SpatialPartition2D] = None,
        spatial_resolution: Optional[SpatialResolution] = None
    ) -&gt; None:
        &#39;&#39;&#39;Initialize a new `RasterResultDescriptor`&#39;&#39;&#39;
        super().__init__(spatial_reference, time_bounds, spatial_resolution)
        self.__data_type = data_type
        self.__bands = bands
        self.__spatial_bounds = spatial_bounds

    def to_api_dict(self) -&gt; geoengine_openapi_client.TypedResultDescriptor:
        &#39;&#39;&#39;Convert the raster result descriptor to a dictionary&#39;&#39;&#39;

        return geoengine_openapi_client.TypedResultDescriptor(geoengine_openapi_client.TypedRasterResultDescriptor(
            type=&#39;raster&#39;,
            data_type=self.data_type,
            bands=[band.to_api_dict() for band in self.__bands],
            spatial_reference=self.spatial_reference,
            time=self.time_bounds.time_str if self.time_bounds is not None else None,
            bbox=self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
            resolution=self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None
        ))

    @staticmethod
    def from_response_raster(
            response: geoengine_openapi_client.TypedRasterResultDescriptor) -&gt; RasterResultDescriptor:
        &#39;&#39;&#39;Parse a raster result descriptor from an http response&#39;&#39;&#39;
        spatial_ref = response.spatial_reference
        data_type = response.data_type.value
        bands = [RasterBandDescriptor.from_response(band) for band in response.bands]

        time_bounds = None
        # FIXME: datetime can not represent our min max range
        # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
        #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
        spatial_bounds = None
        if response.bbox is not None:
            spatial_bounds = SpatialPartition2D.from_response(response.bbox)
        spatial_resolution = None
        if response.resolution is not None:
            spatial_resolution = SpatialResolution.from_response(response.resolution)

        return RasterResultDescriptor(
            data_type=data_type,
            bands=bands,
            spatial_reference=spatial_ref,
            time_bounds=time_bounds,
            spatial_bounds=spatial_bounds,
            spatial_resolution=spatial_resolution
        )

    @classmethod
    def is_raster_result(cls) -&gt; bool:
        return True

    @property
    def data_type(self) -&gt; Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;]:
        return self.__data_type

    @property
    def bands(self) -&gt; List[RasterBandDescriptor]:
        return self.__bands

    @property
    def spatial_bounds(self) -&gt; Optional[SpatialPartition2D]:
        return self.__spatial_bounds

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;

        return super().spatial_reference

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of the raster result descriptor&#39;&#39;&#39;
        r = &#39;&#39;
        r += f&#39;Data type:         {self.data_type}\n&#39;
        r += f&#39;Spatial Reference: {self.spatial_reference}\n&#39;
        r += &#39;Bands:\n&#39;

        for band in self.__bands:
            r += f&#39;    {band}\n&#39;

        return r</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.RasterResultDescriptor.from_response_raster"><code class="name flex">
<span>def <span class="ident">from_response_raster</span></span>(<span>response:geoengine_openapi_client.TypedRasterResultDescriptor) ><a title="geoengine.types.RasterResultDescriptor" href="#geoengine.types.RasterResultDescriptor">RasterResultDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a raster result descriptor from an http response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_raster(
        response: geoengine_openapi_client.TypedRasterResultDescriptor) -&gt; RasterResultDescriptor:
    &#39;&#39;&#39;Parse a raster result descriptor from an http response&#39;&#39;&#39;
    spatial_ref = response.spatial_reference
    data_type = response.data_type.value
    bands = [RasterBandDescriptor.from_response(band) for band in response.bands]

    time_bounds = None
    # FIXME: datetime can not represent our min max range
    # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
    #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
    spatial_bounds = None
    if response.bbox is not None:
        spatial_bounds = SpatialPartition2D.from_response(response.bbox)
    spatial_resolution = None
    if response.resolution is not None:
        spatial_resolution = SpatialResolution.from_response(response.resolution)

    return RasterResultDescriptor(
        data_type=data_type,
        bands=bands,
        spatial_reference=spatial_ref,
        time_bounds=time_bounds,
        spatial_bounds=spatial_bounds,
        spatial_resolution=spatial_resolution
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.RasterResultDescriptor.bands"><code class="name">var <span class="ident">bands</span> :List[<a title="geoengine.types.RasterBandDescriptor" href="#geoengine.types.RasterBandDescriptor">RasterBandDescriptor</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bands(self) -&gt; List[RasterBandDescriptor]:
    return self.__bands</code></pre>
</details>
</dd>
<dt id="geoengine.types.RasterResultDescriptor.data_type"><code class="name">var <span class="ident">data_type</span> :Literal['U8','U16','U32','U64','I8','I16','I32','I64','F32','F64']</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_type(self) -&gt; Literal[&#39;U8&#39;, &#39;U16&#39;, &#39;U32&#39;, &#39;U64&#39;, &#39;I8&#39;, &#39;I16&#39;, &#39;I32&#39;, &#39;I64&#39;, &#39;F32&#39;, &#39;F64&#39;]:
    return self.__data_type</code></pre>
</details>
</dd>
<dt id="geoengine.types.RasterResultDescriptor.spatial_bounds"><code class="name">var <span class="ident">spatial_bounds</span> :Optional[<a title="geoengine.types.SpatialPartition2D" href="#geoengine.types.SpatialPartition2D">SpatialPartition2D</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_bounds(self) -&gt; Optional[SpatialPartition2D]:
    return self.__spatial_bounds</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.RasterResultDescriptor.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.typed_result_descriptor.TypedResultDescriptor</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the raster result descriptor to a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.TypedResultDescriptor:
    &#39;&#39;&#39;Convert the raster result descriptor to a dictionary&#39;&#39;&#39;

    return geoengine_openapi_client.TypedResultDescriptor(geoengine_openapi_client.TypedRasterResultDescriptor(
        type=&#39;raster&#39;,
        data_type=self.data_type,
        bands=[band.to_api_dict() for band in self.__bands],
        spatial_reference=self.spatial_reference,
        time=self.time_bounds.time_str if self.time_bounds is not None else None,
        bbox=self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
        resolution=self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.ResultDescriptor.from_response" href="#geoengine.types.ResultDescriptor.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_plot_result" href="#geoengine.types.ResultDescriptor.is_plot_result">is_plot_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_raster_result" href="#geoengine.types.ResultDescriptor.is_raster_result">is_raster_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_vector_result" href="#geoengine.types.ResultDescriptor.is_vector_result">is_vector_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_reference" href="#geoengine.types.ResultDescriptor.spatial_reference">spatial_reference</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_resolution" href="#geoengine.types.ResultDescriptor.spatial_resolution">spatial_resolution</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.time_bounds" href="#geoengine.types.ResultDescriptor.time_bounds">time_bounds</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.RasterSymbology"><code class="flex name class">
<span>class <span class="ident">RasterSymbology</span></span>
<span>(</span><span>raster_colorizer:<a title="geoengine.types.RasterColorizer" href="#geoengine.types.RasterColorizer">RasterColorizer</a>, opacity:float=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>A raster symbology</p>
<p>Initialize a new <code><a title="geoengine.types.RasterSymbology" href="#geoengine.types.RasterSymbology">RasterSymbology</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RasterSymbology(Symbology):
    &#39;&#39;&#39;A raster symbology&#39;&#39;&#39;
    __opacity: float
    __raster_colorizer: RasterColorizer

    def __init__(self, raster_colorizer: RasterColorizer, opacity: float = 1.0) -&gt; None:
        &#39;&#39;&#39;Initialize a new `RasterSymbology`&#39;&#39;&#39;

        self.__raster_colorizer = raster_colorizer
        self.__opacity = opacity

    def to_api_dict(self) -&gt; geoengine_openapi_client.Symbology:
        &#39;&#39;&#39;Convert the raster symbology to a dictionary&#39;&#39;&#39;

        return geoengine_openapi_client.Symbology(geoengine_openapi_client.RasterSymbology(
            type=&#39;raster&#39;,
            raster_colorizer=self.__raster_colorizer.to_api_dict(),
            opacity=self.__opacity,
        ))

    @staticmethod
    def from_response_raster(response: geoengine_openapi_client.RasterSymbology) -&gt; RasterSymbology:
        &#39;&#39;&#39;Parse an http response to a `RasterSymbology` object&#39;&#39;&#39;

        raster_colorizer = RasterColorizer.from_response(response.raster_colorizer)

        return RasterSymbology(raster_colorizer, response.opacity)

    def __repr__(self) -&gt; str:
        return super().__repr__() + f&#34;({self.__raster_colorizer}, {self.__opacity})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.RasterSymbology.from_response_raster"><code class="name flex">
<span>def <span class="ident">from_response_raster</span></span>(<span>response:geoengine_openapi_client.RasterSymbology) ><a title="geoengine.types.RasterSymbology" href="#geoengine.types.RasterSymbology">RasterSymbology</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.RasterSymbology" href="#geoengine.types.RasterSymbology">RasterSymbology</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_raster(response: geoengine_openapi_client.RasterSymbology) -&gt; RasterSymbology:
    &#39;&#39;&#39;Parse an http response to a `RasterSymbology` object&#39;&#39;&#39;

    raster_colorizer = RasterColorizer.from_response(response.raster_colorizer)

    return RasterSymbology(raster_colorizer, response.opacity)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.RasterSymbology.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.symbology.Symbology</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the raster symbology to a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.Symbology:
    &#39;&#39;&#39;Convert the raster symbology to a dictionary&#39;&#39;&#39;

    return geoengine_openapi_client.Symbology(geoengine_openapi_client.RasterSymbology(
        type=&#39;raster&#39;,
        raster_colorizer=self.__raster_colorizer.to_api_dict(),
        opacity=self.__opacity,
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.Symbology.from_response" href="#geoengine.types.Symbology.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.ResultDescriptor"><code class="flex name class">
<span>class <span class="ident">ResultDescriptor</span></span>
<span>(</span><span>spatial_reference:str, time_bounds:Optional[<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a>]=None, spatial_resolution:Optional[<a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for result descriptors</p>
<p>Initialize a new <code><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResultDescriptor:  # pylint: disable=too-few-public-methods
    &#39;&#39;&#39;
    Base class for result descriptors
    &#39;&#39;&#39;

    __spatial_reference: str
    __time_bounds: Optional[TimeInterval]
    __spatial_resolution: Optional[SpatialResolution]

    def __init__(
        self,
        spatial_reference: str,
        time_bounds: Optional[TimeInterval] = None,
        spatial_resolution: Optional[SpatialResolution] = None
    ) -&gt; None:
        &#39;&#39;&#39;Initialize a new `ResultDescriptor` object&#39;&#39;&#39;

        self.__spatial_reference = spatial_reference
        self.__time_bounds = time_bounds

        if spatial_resolution is None or isinstance(spatial_resolution, SpatialResolution):
            self.__spatial_resolution = spatial_resolution
        else:
            raise TypeException(&#39;Spatial resolution must be of type `SpatialResolution` or `None`&#39;)

    @staticmethod
    def from_response(response: geoengine_openapi_client.TypedResultDescriptor) -&gt; ResultDescriptor:
        &#39;&#39;&#39;
        Parse a result descriptor from an http response
        &#39;&#39;&#39;

        inner = response.actual_instance

        if isinstance(inner, geoengine_openapi_client.TypedRasterResultDescriptor):
            return RasterResultDescriptor.from_response_raster(inner)
        if isinstance(inner, geoengine_openapi_client.TypedVectorResultDescriptor):
            return VectorResultDescriptor.from_response_vector(inner)
        if isinstance(inner, geoengine_openapi_client.TypedPlotResultDescriptor):
            return PlotResultDescriptor.from_response_plot(inner)

        raise TypeException(&#39;Unknown `ResultDescriptor` type&#39;)

    @classmethod
    def is_raster_result(cls) -&gt; bool:
        &#39;&#39;&#39;
        Return true if the result is of type raster
        &#39;&#39;&#39;
        return False

    @classmethod
    def is_vector_result(cls) -&gt; bool:
        &#39;&#39;&#39;
        Return true if the result is of type vector
        &#39;&#39;&#39;
        return False

    @classmethod
    def is_plot_result(cls) -&gt; bool:
        &#39;&#39;&#39;
        Return true if the result is of type plot
        &#39;&#39;&#39;

        return False

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;

        return self.__spatial_reference

    @property
    def time_bounds(self) -&gt; Optional[TimeInterval]:
        &#39;&#39;&#39;Return the time bounds&#39;&#39;&#39;

        return self.__time_bounds

    @property
    def spatial_resolution(self) -&gt; Optional[SpatialResolution]:
        &#39;&#39;&#39;Return the spatial resolution&#39;&#39;&#39;

        return self.__spatial_resolution

    @abstractmethod
    def to_api_dict(self) -&gt; geoengine_openapi_client.TypedResultDescriptor:
        pass

    def __iter__(self):
        return iter(self.to_api_dict().items())</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geoengine.types.PlotResultDescriptor" href="#geoengine.types.PlotResultDescriptor">PlotResultDescriptor</a></li>
<li><a title="geoengine.types.RasterResultDescriptor" href="#geoengine.types.RasterResultDescriptor">RasterResultDescriptor</a></li>
<li><a title="geoengine.types.VectorResultDescriptor" href="#geoengine.types.VectorResultDescriptor">VectorResultDescriptor</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.ResultDescriptor.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:geoengine_openapi_client.TypedResultDescriptor) ><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a result descriptor from an http response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: geoengine_openapi_client.TypedResultDescriptor) -&gt; ResultDescriptor:
    &#39;&#39;&#39;
    Parse a result descriptor from an http response
    &#39;&#39;&#39;

    inner = response.actual_instance

    if isinstance(inner, geoengine_openapi_client.TypedRasterResultDescriptor):
        return RasterResultDescriptor.from_response_raster(inner)
    if isinstance(inner, geoengine_openapi_client.TypedVectorResultDescriptor):
        return VectorResultDescriptor.from_response_vector(inner)
    if isinstance(inner, geoengine_openapi_client.TypedPlotResultDescriptor):
        return PlotResultDescriptor.from_response_plot(inner)

    raise TypeException(&#39;Unknown `ResultDescriptor` type&#39;)</code></pre>
</details>
</dd>
<dt id="geoengine.types.ResultDescriptor.is_plot_result"><code class="name flex">
<span>def <span class="ident">is_plot_result</span></span>(<span>) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the result is of type plot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_plot_result(cls) -&gt; bool:
    &#39;&#39;&#39;
    Return true if the result is of type plot
    &#39;&#39;&#39;

    return False</code></pre>
</details>
</dd>
<dt id="geoengine.types.ResultDescriptor.is_raster_result"><code class="name flex">
<span>def <span class="ident">is_raster_result</span></span>(<span>) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the result is of type raster</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_raster_result(cls) -&gt; bool:
    &#39;&#39;&#39;
    Return true if the result is of type raster
    &#39;&#39;&#39;
    return False</code></pre>
</details>
</dd>
<dt id="geoengine.types.ResultDescriptor.is_vector_result"><code class="name flex">
<span>def <span class="ident">is_vector_result</span></span>(<span>) >bool</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the result is of type vector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_vector_result(cls) -&gt; bool:
    &#39;&#39;&#39;
    Return true if the result is of type vector
    &#39;&#39;&#39;
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.ResultDescriptor.spatial_reference"><code class="name">var <span class="ident">spatial_reference</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the spatial reference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_reference(self) -&gt; str:
    &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;

    return self.__spatial_reference</code></pre>
</details>
</dd>
<dt id="geoengine.types.ResultDescriptor.spatial_resolution"><code class="name">var <span class="ident">spatial_resolution</span> :Optional[<a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a>]</code></dt>
<dd>
<div class="desc"><p>Return the spatial resolution</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_resolution(self) -&gt; Optional[SpatialResolution]:
    &#39;&#39;&#39;Return the spatial resolution&#39;&#39;&#39;

    return self.__spatial_resolution</code></pre>
</details>
</dd>
<dt id="geoengine.types.ResultDescriptor.time_bounds"><code class="name">var <span class="ident">time_bounds</span> :Optional[<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a>]</code></dt>
<dd>
<div class="desc"><p>Return the time bounds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_bounds(self) -&gt; Optional[TimeInterval]:
    &#39;&#39;&#39;Return the time bounds&#39;&#39;&#39;

    return self.__time_bounds</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.ResultDescriptor.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.typed_result_descriptor.TypedResultDescriptor</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_api_dict(self) -&gt; geoengine_openapi_client.TypedResultDescriptor:
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.SingleBandRasterColorizer"><code class="flex name class">
<span>class <span class="ident">SingleBandRasterColorizer</span></span>
<span>(</span><span>band:int, band_colorizer:Colorizer)</span>
</code></dt>
<dd>
<div class="desc"><p>A raster colorizer for a specified band</p>
<p>Method generated by attrs for class SingleBandRasterColorizer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class SingleBandRasterColorizer(RasterColorizer):
    &#39;&#39;&#39;A raster colorizer for a specified band&#39;&#39;&#39;

    band: int
    band_colorizer: Colorizer

    @staticmethod
    def from_single_band_response(response: geoengine_openapi_client.SingleBandRasterColorizer) -&gt; RasterColorizer:
        return SingleBandRasterColorizer(
            response.band,
            Colorizer.from_response(response.band_colorizer)
        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.RasterColorizer:
        return geoengine_openapi_client.RasterColorizer(geoengine_openapi_client.SingleBandRasterColorizer(
            type=&#39;singleBand&#39;,
            band=self.band,
            band_colorizer=self.band_colorizer.to_api_dict(),
        ))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.RasterColorizer" href="#geoengine.types.RasterColorizer">RasterColorizer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.SingleBandRasterColorizer.band"><code class="name">var <span class="ident">band</span> :int</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SingleBandRasterColorizer.band_colorizer"><code class="name">var <span class="ident">band_colorizer</span> :<a title="geoengine.colorizer.Colorizer" href="colorizer.html#geoengine.colorizer.Colorizer">Colorizer</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.SingleBandRasterColorizer.from_single_band_response"><code class="name flex">
<span>def <span class="ident">from_single_band_response</span></span>(<span>response:geoengine_openapi_client.SingleBandRasterColorizer) ><a title="geoengine.types.RasterColorizer" href="#geoengine.types.RasterColorizer">RasterColorizer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_single_band_response(response: geoengine_openapi_client.SingleBandRasterColorizer) -&gt; RasterColorizer:
    return SingleBandRasterColorizer(
        response.band,
        Colorizer.from_response(response.band_colorizer)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.SingleBandRasterColorizer.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.raster_colorizer.RasterColorizer</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.RasterColorizer:
    return geoengine_openapi_client.RasterColorizer(geoengine_openapi_client.SingleBandRasterColorizer(
        type=&#39;singleBand&#39;,
        band=self.band,
        band_colorizer=self.band_colorizer.to_api_dict(),
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.RasterColorizer" href="#geoengine.types.RasterColorizer">RasterColorizer</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.RasterColorizer.from_response" href="#geoengine.types.RasterColorizer.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.SpatialBounds"><code class="flex name class">
<span>class <span class="ident">SpatialBounds</span></span>
<span>(</span><span>xmin:float, ymin:float, xmax:float, ymax:float)</span>
</code></dt>
<dd>
<div class="desc"><p>A spatial bounds object</p>
<p>Initialize a new <code><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpatialBounds:
    &#39;&#39;&#39;A spatial bounds object&#39;&#39;&#39;
    xmin: float
    ymin: float
    xmax: float
    ymax: float

    def __init__(self, xmin: float, ymin: float, xmax: float, ymax: float) -&gt; None:
        &#39;&#39;&#39;Initialize a new `SpatialBounds` object&#39;&#39;&#39;
        if (xmin &gt; xmax) or (ymin &gt; ymax):
            raise InputException(&#34;Bbox: Malformed since min must be &lt;= max&#34;)

        self.xmin = xmin
        self.ymin = ymin
        self.xmax = xmax
        self.ymax = ymax

    def as_bbox_str(self, y_axis_first=False) -&gt; str:
        &#39;&#39;&#39;
        A comma-separated string representation of the spatial bounds with OGC axis ordering
        &#39;&#39;&#39;
        bbox_tuple = self.as_bbox_tuple(y_axis_first=y_axis_first)
        return f&#39;{bbox_tuple[0]},{bbox_tuple[1]},{bbox_tuple[2]},{bbox_tuple[3]}&#39;

    def as_bbox_tuple(self, y_axis_first=False) -&gt; Tuple[float, float, float, float]:
        &#39;&#39;&#39;
        Return the bbox with OGC axis ordering of the srs
        &#39;&#39;&#39;

        if y_axis_first:
            return (self.ymin, self.xmin, self.ymax, self.xmax)

        return (self.xmin, self.ymin, self.xmax, self.ymax)

    def x_axis_size(self) -&gt; float:
        &#39;&#39;&#39;The size of the x axis&#39;&#39;&#39;
        return self.xmax - self.xmin

    def y_axis_size(self) -&gt; float:
        &#39;&#39;&#39;The size of the y axis&#39;&#39;&#39;
        return self.ymax - self.ymin</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></li>
<li><a title="geoengine.types.SpatialPartition2D" href="#geoengine.types.SpatialPartition2D">SpatialPartition2D</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.SpatialBounds.xmax"><code class="name">var <span class="ident">xmax</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialBounds.xmin"><code class="name">var <span class="ident">xmin</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialBounds.ymax"><code class="name">var <span class="ident">ymax</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialBounds.ymin"><code class="name">var <span class="ident">ymin</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.SpatialBounds.as_bbox_str"><code class="name flex">
<span>def <span class="ident">as_bbox_str</span></span>(<span>self, y_axis_first=False) >str</span>
</code></dt>
<dd>
<div class="desc"><p>A comma-separated string representation of the spatial bounds with OGC axis ordering</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_bbox_str(self, y_axis_first=False) -&gt; str:
    &#39;&#39;&#39;
    A comma-separated string representation of the spatial bounds with OGC axis ordering
    &#39;&#39;&#39;
    bbox_tuple = self.as_bbox_tuple(y_axis_first=y_axis_first)
    return f&#39;{bbox_tuple[0]},{bbox_tuple[1]},{bbox_tuple[2]},{bbox_tuple[3]}&#39;</code></pre>
</details>
</dd>
<dt id="geoengine.types.SpatialBounds.as_bbox_tuple"><code class="name flex">
<span>def <span class="ident">as_bbox_tuple</span></span>(<span>self, y_axis_first=False) >Tuple[float,float,float,float]</span>
</code></dt>
<dd>
<div class="desc"><p>Return the bbox with OGC axis ordering of the srs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_bbox_tuple(self, y_axis_first=False) -&gt; Tuple[float, float, float, float]:
    &#39;&#39;&#39;
    Return the bbox with OGC axis ordering of the srs
    &#39;&#39;&#39;

    if y_axis_first:
        return (self.ymin, self.xmin, self.ymax, self.xmax)

    return (self.xmin, self.ymin, self.xmax, self.ymax)</code></pre>
</details>
</dd>
<dt id="geoengine.types.SpatialBounds.x_axis_size"><code class="name flex">
<span>def <span class="ident">x_axis_size</span></span>(<span>self) >float</span>
</code></dt>
<dd>
<div class="desc"><p>The size of the x axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x_axis_size(self) -&gt; float:
    &#39;&#39;&#39;The size of the x axis&#39;&#39;&#39;
    return self.xmax - self.xmin</code></pre>
</details>
</dd>
<dt id="geoengine.types.SpatialBounds.y_axis_size"><code class="name flex">
<span>def <span class="ident">y_axis_size</span></span>(<span>self) >float</span>
</code></dt>
<dd>
<div class="desc"><p>The size of the y axis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def y_axis_size(self) -&gt; float:
    &#39;&#39;&#39;The size of the y axis&#39;&#39;&#39;
    return self.ymax - self.ymin</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.SpatialPartition2D"><code class="flex name class">
<span>class <span class="ident">SpatialPartition2D</span></span>
<span>(</span><span>xmin:float, ymin:float, xmax:float, ymax:float)</span>
</code></dt>
<dd>
<div class="desc"><p>A 2D spatial partition.</p>
<p>Initialize a new <code><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpatialPartition2D(SpatialBounds):
    &#39;&#39;&#39;A 2D spatial partition.&#39;&#39;&#39;

    @staticmethod
    def from_response(response: geoengine_openapi_client.SpatialPartition2D) -&gt; SpatialPartition2D:
        &#39;&#39;&#39;create a `SpatialPartition2D` from an API response&#39;&#39;&#39;
        upper_left = response.upper_left_coordinate
        lower_right = response.lower_right_coordinate

        return SpatialPartition2D(
            upper_left.x,
            lower_right.y,
            lower_right.x,
            upper_left.y,

        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.SpatialPartition2D:
        return geoengine_openapi_client.SpatialPartition2D(
            upper_left_coordinate=geoengine_openapi_client.Coordinate2D(
                x=self.xmin,
                y=self.ymax,
            ),
            lower_right_coordinate=geoengine_openapi_client.Coordinate2D(
                x=self.xmax,
                y=self.ymin,
            ),
        )

    def to_bounding_box(self) -&gt; BoundingBox2D:
        &#39;&#39;&#39;convert to a `BoundingBox2D`&#39;&#39;&#39;
        return BoundingBox2D(self.xmin, self.ymin, self.xmax, self.ymax)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.SpatialPartition2D.xmax"><code class="name">var <span class="ident">xmax</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialPartition2D.xmin"><code class="name">var <span class="ident">xmin</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialPartition2D.ymax"><code class="name">var <span class="ident">ymax</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialPartition2D.ymin"><code class="name">var <span class="ident">ymin</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.SpatialPartition2D.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:geoengine_openapi_client.SpatialPartition2D) ><a title="geoengine.types.SpatialPartition2D" href="#geoengine.types.SpatialPartition2D">SpatialPartition2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>create a <code><a title="geoengine.types.SpatialPartition2D" href="#geoengine.types.SpatialPartition2D">SpatialPartition2D</a></code> from an API response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: geoengine_openapi_client.SpatialPartition2D) -&gt; SpatialPartition2D:
    &#39;&#39;&#39;create a `SpatialPartition2D` from an API response&#39;&#39;&#39;
    upper_left = response.upper_left_coordinate
    lower_right = response.lower_right_coordinate

    return SpatialPartition2D(
        upper_left.x,
        lower_right.y,
        lower_right.x,
        upper_left.y,

    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.SpatialPartition2D.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.spatial_partition2_d.SpatialPartition2D</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.SpatialPartition2D:
    return geoengine_openapi_client.SpatialPartition2D(
        upper_left_coordinate=geoengine_openapi_client.Coordinate2D(
            x=self.xmin,
            y=self.ymax,
        ),
        lower_right_coordinate=geoengine_openapi_client.Coordinate2D(
            x=self.xmax,
            y=self.ymin,
        ),
    )</code></pre>
</details>
</dd>
<dt id="geoengine.types.SpatialPartition2D.to_bounding_box"><code class="name flex">
<span>def <span class="ident">to_bounding_box</span></span>(<span>self) ><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></span>
</code></dt>
<dd>
<div class="desc"><p>convert to a <code><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_bounding_box(self) -&gt; BoundingBox2D:
    &#39;&#39;&#39;convert to a `BoundingBox2D`&#39;&#39;&#39;
    return BoundingBox2D(self.xmin, self.ymin, self.xmax, self.ymax)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.SpatialBounds.as_bbox_str" href="#geoengine.types.SpatialBounds.as_bbox_str">as_bbox_str</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.as_bbox_tuple" href="#geoengine.types.SpatialBounds.as_bbox_tuple">as_bbox_tuple</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.x_axis_size" href="#geoengine.types.SpatialBounds.x_axis_size">x_axis_size</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.y_axis_size" href="#geoengine.types.SpatialBounds.y_axis_size">y_axis_size</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.SpatialResolution"><code class="flex name class">
<span>class <span class="ident">SpatialResolution</span></span>
<span>(</span><span>x_resolution:float, y_resolution:float)</span>
</code></dt>
<dd>
<div class="desc"><p>'A spatial resolution.</p>
<p>Initialize a new <code><a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpatialResolution:
    &#39;&#39;&#39;&#39;A spatial resolution.&#39;&#39;&#39;
    x_resolution: float
    y_resolution: float

    def __init__(self, x_resolution: float, y_resolution: float) -&gt; None:
        &#39;&#39;&#39;Initialize a new `SpatialResolution` object&#39;&#39;&#39;
        if x_resolution &lt;= 0 or y_resolution &lt;= 0:
            raise InputException(&#34;Resolution: Must be positive&#34;)

        self.x_resolution = x_resolution
        self.y_resolution = y_resolution

    def to_api_dict(self) -&gt; geoengine_openapi_client.SpatialResolution:
        return geoengine_openapi_client.SpatialResolution(
            x=self.x_resolution,
            y=self.y_resolution,
        )

    @staticmethod
    def from_response(response: geoengine_openapi_client.SpatialResolution) -&gt; SpatialResolution:
        &#39;&#39;&#39;create a `SpatialResolution` from an API response&#39;&#39;&#39;
        return SpatialResolution(x_resolution=response.x, y_resolution=response.y)

    def as_tuple(self) -&gt; Tuple[float, float]:
        return (self.x_resolution, self.y_resolution)

    def __str__(self) -&gt; str:
        return str(f&#39;{self.x_resolution},{self.y_resolution}&#39;)

    def __repr__(self) -&gt; str:
        return str(f&#39;SpatialResolution(x={self.x_resolution}, y={self.y_resolution})&#39;)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.SpatialResolution.x_resolution"><code class="name">var <span class="ident">x_resolution</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.SpatialResolution.y_resolution"><code class="name">var <span class="ident">y_resolution</span> :float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.SpatialResolution.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:geoengine_openapi_client.SpatialResolution) ><a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a></span>
</code></dt>
<dd>
<div class="desc"><p>create a <code><a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a></code> from an API response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: geoengine_openapi_client.SpatialResolution) -&gt; SpatialResolution:
    &#39;&#39;&#39;create a `SpatialResolution` from an API response&#39;&#39;&#39;
    return SpatialResolution(x_resolution=response.x, y_resolution=response.y)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.SpatialResolution.as_tuple"><code class="name flex">
<span>def <span class="ident">as_tuple</span></span>(<span>self) >Tuple[float,float]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def as_tuple(self) -&gt; Tuple[float, float]:
    return (self.x_resolution, self.y_resolution)</code></pre>
</details>
</dd>
<dt id="geoengine.types.SpatialResolution.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.spatial_resolution.SpatialResolution</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.SpatialResolution:
    return geoengine_openapi_client.SpatialResolution(
        x=self.x_resolution,
        y=self.y_resolution,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.Symbology"><code class="flex name class">
<span>class <span class="ident">Symbology</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for symbology</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Symbology:
    &#39;&#39;&#39;Base class for symbology&#39;&#39;&#39;

    @abstractmethod
    def to_api_dict(self) -&gt; geoengine_openapi_client.Symbology:
        pass

    @staticmethod
    def from_response(response: geoengine_openapi_client.Symbology) -&gt; Symbology:
        &#39;&#39;&#39;Parse an http response to a `Symbology` object&#39;&#39;&#39;
        inner = response.actual_instance

        if isinstance(inner, (
                geoengine_openapi_client.PointSymbology,
                geoengine_openapi_client.LineSymbology,
                geoengine_openapi_client.PolygonSymbology)):
            # return VectorSymbology.from_response_vector(response)
            return VectorSymbology()  # TODO: implement
        if isinstance(inner, geoengine_openapi_client.RasterSymbology):
            return RasterSymbology.from_response_raster(inner)

        raise InputException(&#34;Invalid symbology type&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geoengine.types.RasterSymbology" href="#geoengine.types.RasterSymbology">RasterSymbology</a></li>
<li><a title="geoengine.types.VectorSymbology" href="#geoengine.types.VectorSymbology">VectorSymbology</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.Symbology.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:geoengine_openapi_client.Symbology) ><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse an http response to a <code><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: geoengine_openapi_client.Symbology) -&gt; Symbology:
    &#39;&#39;&#39;Parse an http response to a `Symbology` object&#39;&#39;&#39;
    inner = response.actual_instance

    if isinstance(inner, (
            geoengine_openapi_client.PointSymbology,
            geoengine_openapi_client.LineSymbology,
            geoengine_openapi_client.PolygonSymbology)):
        # return VectorSymbology.from_response_vector(response)
        return VectorSymbology()  # TODO: implement
    if isinstance(inner, geoengine_openapi_client.RasterSymbology):
        return RasterSymbology.from_response_raster(inner)

    raise InputException(&#34;Invalid symbology type&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.Symbology.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.symbology.Symbology</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_api_dict(self) -&gt; geoengine_openapi_client.Symbology:
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.TimeInterval"><code class="flex name class">
<span>class <span class="ident">TimeInterval</span></span>
<span>(</span><span>start:Union[datetime,np.datetime64], end:Optional[Union[datetime,np.datetime64]]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>'A time interval.</p>
<p>Initialize a new <code><a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a></code> object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeInterval:
    &#39;&#39;&#39;&#39;A time interval.&#39;&#39;&#39;
    start: np.datetime64
    end: Optional[np.datetime64]

    def __init__(self,
                 start: Union[datetime, np.datetime64],
                 end: Optional[Union[datetime, np.datetime64]] = None) -&gt; None:
        &#39;&#39;&#39;Initialize a new `TimeInterval` object&#39;&#39;&#39;

        if isinstance(start, np.datetime64):
            self.start = start
        elif isinstance(start, datetime):
            # We assume that a datetime without a timezone means UTC
            if start.tzinfo is not None:
                start = start.astimezone(tz=timezone.utc).replace(tzinfo=None)
            self.start = np.datetime64(start)
        else:
            raise InputException(&#34;`start` must be of type `datetime.datetime` or `numpy.datetime64`&#34;)

        if end is None:
            self.end = None
        elif isinstance(end, np.datetime64):
            self.end = end
        elif isinstance(end, datetime):
            # We assume that a datetime without a timezone means UTC
            if end.tzinfo is not None:
                end = end.astimezone(tz=timezone.utc).replace(tzinfo=None)
            self.end = np.datetime64(end)
        else:
            raise InputException(&#34;`end` must be of type `datetime.datetime` or `numpy.datetime64`&#34;)

        # Check validity of time interval if an `end` exists
        if end is not None and start &gt; end:
            raise InputException(&#34;Time inverval: Start must be &lt;= End&#34;)

    def is_instant(self) -&gt; bool:
        return self.end is None

    @property
    def time_str(self) -&gt; str:
        &#39;&#39;&#39;
        Return the time instance or interval as a string representation
        &#39;&#39;&#39;

        start_iso = TimeInterval.__datetime_to_iso_str(self.start)

        if self.end is None or self.start == self.end:
            return start_iso

        end_iso = TimeInterval.__datetime_to_iso_str(self.end)

        return start_iso + &#39;/&#39; + end_iso

    @staticmethod
    def from_response(response: Any) -&gt; TimeInterval:
        &#39;&#39;&#39;create a `TimeInterval` from an API response&#39;&#39;&#39;

        if &#39;start&#39; not in response:
            raise TypeException(&#39;TimeInterval must have a start&#39;)

        if isinstance(response[&#39;start&#39;], int):
            start = cast(int, response[&#39;start&#39;])
            end = cast(int, response[&#39;end&#39;]) if &#39;end&#39; in response and response[&#39;end&#39;] is not None else None

            return TimeInterval(
                np.datetime64(start, &#39;ms&#39;),
                np.datetime64(end, &#39;ms&#39;) if end is not None else None,
            )

        start_str = cast(str, response[&#39;start&#39;])
        end_str = cast(str, response[&#39;end&#39;]) if &#39;end&#39; in response and response[&#39;end&#39;] is not None else None

        return TimeInterval(
            datetime.fromisoformat(start_str),
            datetime.fromisoformat(end_str) if end_str is not None else None,
        )

    def __repr__(self) -&gt; str:
        return f&#34;TimeInterval(start={self.start}, end={self.end})&#34;

    def to_api_dict(self) -&gt; geoengine_openapi_client.TimeInterval:
        return geoengine_openapi_client.TimeInterval(
            start=int(self.start.astype(&#39;datetime64[ms]&#39;).astype(int)),
            end=int(self.end.astype(&#39;datetime64[ms]&#39;).astype(int)) if self.end is not None else None,
        )

    @staticmethod
    def __datetime_to_iso_str(timestamp: np.datetime64) -&gt; str:
        return str(np.datetime_as_string(timestamp, unit=&#39;ms&#39;, timezone=&#39;UTC&#39;)).replace(&#39;Z&#39;, &#39;+00:00&#39;)

    def __eq__(self, other: Any) -&gt; bool:
        &#39;&#39;&#39;Check if two `TimeInterval` objects are equal.&#39;&#39;&#39;
        if not isinstance(other, TimeInterval):
            return False
        return self.start == other.start and self.end == other.end</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.TimeInterval.end"><code class="name">var <span class="ident">end</span> :Optional[numpy.datetime64]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeInterval.start"><code class="name">var <span class="ident">start</span> :numpy.datetime64</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.TimeInterval.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:Any) ><a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a></span>
</code></dt>
<dd>
<div class="desc"><p>create a <code><a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a></code> from an API response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: Any) -&gt; TimeInterval:
    &#39;&#39;&#39;create a `TimeInterval` from an API response&#39;&#39;&#39;

    if &#39;start&#39; not in response:
        raise TypeException(&#39;TimeInterval must have a start&#39;)

    if isinstance(response[&#39;start&#39;], int):
        start = cast(int, response[&#39;start&#39;])
        end = cast(int, response[&#39;end&#39;]) if &#39;end&#39; in response and response[&#39;end&#39;] is not None else None

        return TimeInterval(
            np.datetime64(start, &#39;ms&#39;),
            np.datetime64(end, &#39;ms&#39;) if end is not None else None,
        )

    start_str = cast(str, response[&#39;start&#39;])
    end_str = cast(str, response[&#39;end&#39;]) if &#39;end&#39; in response and response[&#39;end&#39;] is not None else None

    return TimeInterval(
        datetime.fromisoformat(start_str),
        datetime.fromisoformat(end_str) if end_str is not None else None,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.TimeInterval.time_str"><code class="name">var <span class="ident">time_str</span> :str</code></dt>
<dd>
<div class="desc"><p>Return the time instance or interval as a string representation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def time_str(self) -&gt; str:
    &#39;&#39;&#39;
    Return the time instance or interval as a string representation
    &#39;&#39;&#39;

    start_iso = TimeInterval.__datetime_to_iso_str(self.start)

    if self.end is None or self.start == self.end:
        return start_iso

    end_iso = TimeInterval.__datetime_to_iso_str(self.end)

    return start_iso + &#39;/&#39; + end_iso</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.TimeInterval.is_instant"><code class="name flex">
<span>def <span class="ident">is_instant</span></span>(<span>self) >bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_instant(self) -&gt; bool:
    return self.end is None</code></pre>
</details>
</dd>
<dt id="geoengine.types.TimeInterval.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.time_interval.TimeInterval</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.TimeInterval:
    return geoengine_openapi_client.TimeInterval(
        start=int(self.start.astype(&#39;datetime64[ms]&#39;).astype(int)),
        end=int(self.end.astype(&#39;datetime64[ms]&#39;).astype(int)) if self.end is not None else None,
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.TimeStep"><code class="flex name class">
<span>class <span class="ident">TimeStep</span></span>
<span>(</span><span>step:int, granularity:<a title="geoengine.types.TimeStepGranularity" href="#geoengine.types.TimeStepGranularity">TimeStepGranularity</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A time step that consists of a granularity and a step size</p>
<p>Method generated by attrs for class TimeStep.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class TimeStep:
    &#39;&#39;&#39;A time step that consists of a granularity and a step size&#39;&#39;&#39;
    step: int
    granularity: TimeStepGranularity

    def to_api_dict(self) -&gt; geoengine_openapi_client.TimeStep:
        return geoengine_openapi_client.TimeStep(
            step=self.step,
            granularity=self.granularity.to_api_enum(),
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.TimeStep.granularity"><code class="name">var <span class="ident">granularity</span> :<a title="geoengine.types.TimeStepGranularity" href="#geoengine.types.TimeStepGranularity">TimeStepGranularity</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStep.step"><code class="name">var <span class="ident">step</span> :int</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.TimeStep.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.time_step.TimeStep</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.TimeStep:
    return geoengine_openapi_client.TimeStep(
        step=self.step,
        granularity=self.granularity.to_api_enum(),
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.TimeStepGranularity"><code class="flex name class">
<span>class <span class="ident">TimeStepGranularity</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enum of time step granularities</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimeStepGranularity(Enum):
    &#39;&#39;&#39;An enum of time step granularities&#39;&#39;&#39;
    MILLIS = &#39;millis&#39;
    SECONDS = &#39;seconds&#39;
    MINUTES = &#39;minutes&#39;
    HOURS = &#39;hours&#39;
    DAYS = &#39;days&#39;
    MONTHS = &#39;months&#39;
    YEARS = &#39;years&#39;

    def to_api_enum(self) -&gt; geoengine_openapi_client.TimeGranularity:
        return geoengine_openapi_client.TimeGranularity(self.value)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.TimeStepGranularity.DAYS"><code class="name">var <span class="ident">DAYS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStepGranularity.HOURS"><code class="name">var <span class="ident">HOURS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStepGranularity.MILLIS"><code class="name">var <span class="ident">MILLIS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStepGranularity.MINUTES"><code class="name">var <span class="ident">MINUTES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStepGranularity.MONTHS"><code class="name">var <span class="ident">MONTHS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStepGranularity.SECONDS"><code class="name">var <span class="ident">SECONDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.TimeStepGranularity.YEARS"><code class="name">var <span class="ident">YEARS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.TimeStepGranularity.to_api_enum"><code class="name flex">
<span>def <span class="ident">to_api_enum</span></span>(<span>self) >geoengine_openapi_client.models.time_granularity.TimeGranularity</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_enum(self) -&gt; geoengine_openapi_client.TimeGranularity:
    return geoengine_openapi_client.TimeGranularity(self.value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.UnitlessMeasurement"><code class="flex name class">
<span>class <span class="ident">UnitlessMeasurement</span></span>
</code></dt>
<dd>
<div class="desc"><p>A measurement that is unitless</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UnitlessMeasurement(Measurement):
    &#39;&#39;&#39;A measurement that is unitless&#39;&#39;&#39;

    def __str__(self) -&gt; str:
        &#39;&#39;&#39;String representation of a unitless measurement&#39;&#39;&#39;
        return &#39;unitless&#39;

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of a unitless measurement&#39;&#39;&#39;
        return str(self)

    def to_api_dict(self) -&gt; geoengine_openapi_client.Measurement:
        return geoengine_openapi_client.Measurement(geoengine_openapi_client.UnitlessMeasurement(
            type=&#39;unitless&#39;
        ))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.UnitlessMeasurement.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.measurement.Measurement</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.Measurement:
    return geoengine_openapi_client.Measurement(geoengine_openapi_client.UnitlessMeasurement(
        type=&#39;unitless&#39;
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.Measurement.from_response" href="#geoengine.types.Measurement.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.VectorColumnInfo"><code class="flex name class">
<span>class <span class="ident">VectorColumnInfo</span></span>
<span>(</span><span>data_type:<a title="geoengine.types.FeatureDataType" href="#geoengine.types.FeatureDataType">FeatureDataType</a>, measurement:<a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Vector column information</p>
<p>Method generated by attrs for class VectorColumnInfo.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class VectorColumnInfo:
    &#39;&#39;&#39;Vector column information&#39;&#39;&#39;

    data_type: FeatureDataType
    measurement: Measurement

    @staticmethod
    def from_response(response: geoengine_openapi_client.VectorColumnInfo) -&gt; VectorColumnInfo:
        &#39;&#39;&#39;Create a new `VectorColumnInfo` from a JSON response&#39;&#39;&#39;

        return VectorColumnInfo(
            FeatureDataType.from_string(response.data_type),
            Measurement.from_response(response.measurement)
        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.VectorColumnInfo:
        &#39;&#39;&#39;Convert to a dictionary&#39;&#39;&#39;

        return geoengine_openapi_client.VectorColumnInfo(
            data_type=self.data_type.to_api_enum(),
            measurement=self.measurement.to_api_dict(),
        )</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.VectorColumnInfo.data_type"><code class="name">var <span class="ident">data_type</span> :<a title="geoengine.types.FeatureDataType" href="#geoengine.types.FeatureDataType">FeatureDataType</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.VectorColumnInfo.measurement"><code class="name">var <span class="ident">measurement</span> :<a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.VectorColumnInfo.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response:geoengine_openapi_client.VectorColumnInfo) ><a title="geoengine.types.VectorColumnInfo" href="#geoengine.types.VectorColumnInfo">VectorColumnInfo</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new <code><a title="geoengine.types.VectorColumnInfo" href="#geoengine.types.VectorColumnInfo">VectorColumnInfo</a></code> from a JSON response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: geoengine_openapi_client.VectorColumnInfo) -&gt; VectorColumnInfo:
    &#39;&#39;&#39;Create a new `VectorColumnInfo` from a JSON response&#39;&#39;&#39;

    return VectorColumnInfo(
        FeatureDataType.from_string(response.data_type),
        Measurement.from_response(response.measurement)
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.VectorColumnInfo.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.vector_column_info.VectorColumnInfo</span>
</code></dt>
<dd>
<div class="desc"><p>Convert to a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.VectorColumnInfo:
    &#39;&#39;&#39;Convert to a dictionary&#39;&#39;&#39;

    return geoengine_openapi_client.VectorColumnInfo(
        data_type=self.data_type.to_api_enum(),
        measurement=self.measurement.to_api_dict(),
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.VectorDataType"><code class="flex name class">
<span>class <span class="ident">VectorDataType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>An enum of vector data types</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VectorDataType(str, Enum):
    &#39;&#39;&#39;An enum of vector data types&#39;&#39;&#39;

    DATA = &#39;Data&#39;
    MULTI_POINT = &#39;MultiPoint&#39;
    MULTI_LINE_STRING = &#39;MultiLineString&#39;
    MULTI_POLYGON = &#39;MultiPolygon&#39;

    @classmethod
    def from_geopandas_type_name(cls, name: str) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from geopandas geometry type&#39;&#39;&#39;

        name_map = {
            &#34;Point&#34;: VectorDataType.MULTI_POINT,
            &#34;MultiPoint&#34;: VectorDataType.MULTI_POINT,
            &#34;Line&#34;: VectorDataType.MULTI_LINE_STRING,
            &#34;MultiLine&#34;: VectorDataType.MULTI_LINE_STRING,
            &#34;Polygon&#34;: VectorDataType.MULTI_POLYGON,
            &#34;MultiPolygon&#34;: VectorDataType.MULTI_POLYGON,
        }

        if name in name_map:
            return name_map[name]

        raise InputException(&#34;Invalid vector data type&#34;)

    def to_api_enum(self) -&gt; geoengine_openapi_client.VectorDataType:
        return geoengine_openapi_client.VectorDataType(self.value)

    @staticmethod
    def from_literal(literal: Literal[&#39;Data&#39;, &#39;MultiPoint&#39;, &#39;MultiLineString&#39;, &#39;MultiPolygon&#39;]) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from literal&#39;&#39;&#39;
        return VectorDataType(literal)

    @staticmethod
    def from_api_enum(data_type: geoengine_openapi_client.VectorDataType) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from API enum&#39;&#39;&#39;
        return VectorDataType(data_type.value)

    @staticmethod
    def from_string(string: str) -&gt; VectorDataType:
        &#39;&#39;&#39;Resolve vector data type from string&#39;&#39;&#39;
        if string not in VectorDataType.__members__.values():
            raise InputException(&#34;Invalid vector data type: &#34; + string)
        return VectorDataType(string)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.types.VectorDataType.DATA"><code class="name">var <span class="ident">DATA</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.VectorDataType.MULTI_LINE_STRING"><code class="name">var <span class="ident">MULTI_LINE_STRING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.VectorDataType.MULTI_POINT"><code class="name">var <span class="ident">MULTI_POINT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.types.VectorDataType.MULTI_POLYGON"><code class="name">var <span class="ident">MULTI_POLYGON</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.VectorDataType.from_api_enum"><code class="name flex">
<span>def <span class="ident">from_api_enum</span></span>(<span>data_type:geoengine_openapi_client.VectorDataType) ><a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve vector data type from API enum</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_api_enum(data_type: geoengine_openapi_client.VectorDataType) -&gt; VectorDataType:
    &#39;&#39;&#39;Resolve vector data type from API enum&#39;&#39;&#39;
    return VectorDataType(data_type.value)</code></pre>
</details>
</dd>
<dt id="geoengine.types.VectorDataType.from_geopandas_type_name"><code class="name flex">
<span>def <span class="ident">from_geopandas_type_name</span></span>(<span>name:str) ><a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve vector data type from geopandas geometry type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_geopandas_type_name(cls, name: str) -&gt; VectorDataType:
    &#39;&#39;&#39;Resolve vector data type from geopandas geometry type&#39;&#39;&#39;

    name_map = {
        &#34;Point&#34;: VectorDataType.MULTI_POINT,
        &#34;MultiPoint&#34;: VectorDataType.MULTI_POINT,
        &#34;Line&#34;: VectorDataType.MULTI_LINE_STRING,
        &#34;MultiLine&#34;: VectorDataType.MULTI_LINE_STRING,
        &#34;Polygon&#34;: VectorDataType.MULTI_POLYGON,
        &#34;MultiPolygon&#34;: VectorDataType.MULTI_POLYGON,
    }

    if name in name_map:
        return name_map[name]

    raise InputException(&#34;Invalid vector data type&#34;)</code></pre>
</details>
</dd>
<dt id="geoengine.types.VectorDataType.from_literal"><code class="name flex">
<span>def <span class="ident">from_literal</span></span>(<span>literal:"Literal['Data','MultiPoint','MultiLineString','MultiPolygon']") ><a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve vector data type from literal</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_literal(literal: Literal[&#39;Data&#39;, &#39;MultiPoint&#39;, &#39;MultiLineString&#39;, &#39;MultiPolygon&#39;]) -&gt; VectorDataType:
    &#39;&#39;&#39;Resolve vector data type from literal&#39;&#39;&#39;
    return VectorDataType(literal)</code></pre>
</details>
</dd>
<dt id="geoengine.types.VectorDataType.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>string:str) ><a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a></span>
</code></dt>
<dd>
<div class="desc"><p>Resolve vector data type from string</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_string(string: str) -&gt; VectorDataType:
    &#39;&#39;&#39;Resolve vector data type from string&#39;&#39;&#39;
    if string not in VectorDataType.__members__.values():
        raise InputException(&#34;Invalid vector data type: &#34; + string)
    return VectorDataType(string)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.VectorDataType.to_api_enum"><code class="name flex">
<span>def <span class="ident">to_api_enum</span></span>(<span>self) >geoengine_openapi_client.models.vector_data_type.VectorDataType</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_enum(self) -&gt; geoengine_openapi_client.VectorDataType:
    return geoengine_openapi_client.VectorDataType(self.value)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.types.VectorResultDescriptor"><code class="flex name class">
<span>class <span class="ident">VectorResultDescriptor</span></span>
<span>(</span><span>spatial_reference:str, data_type:<a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a>, columns:Dict[str,<a title="geoengine.types.VectorColumnInfo" href="#geoengine.types.VectorColumnInfo">VectorColumnInfo</a>], time_bounds:Optional[<a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a>]=None, spatial_bounds:Optional[<a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a>]=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A vector result descriptor</p>
<p>Initialize a vector result descriptor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VectorResultDescriptor(ResultDescriptor):
    &#39;&#39;&#39;
    A vector result descriptor
    &#39;&#39;&#39;
    __spatial_bounds: Optional[BoundingBox2D]
    __data_type: VectorDataType
    __columns: Dict[str, VectorColumnInfo]

    def __init__(  # pylint: disable=too-many-arguments,too-many-positional-arguments
        self,
        spatial_reference: str,
        data_type: VectorDataType,
        columns: Dict[str, VectorColumnInfo],
        time_bounds: Optional[TimeInterval] = None,
        spatial_bounds: Optional[BoundingBox2D] = None
    ) -&gt; None:
        &#39;&#39;&#39; Initialize a vector result descriptor &#39;&#39;&#39;
        super().__init__(spatial_reference, time_bounds, None)
        self.__data_type = data_type
        self.__columns = columns
        self.__spatial_bounds = spatial_bounds

    @staticmethod
    def from_response_vector(
            response: geoengine_openapi_client.TypedVectorResultDescriptor) -&gt; VectorResultDescriptor:
        &#39;&#39;&#39;Parse a vector result descriptor from an http response&#39;&#39;&#39;
        sref = response.spatial_reference
        data_type = VectorDataType.from_string(response.data_type)
        columns = {name: VectorColumnInfo.from_response(info) for name, info in response.columns.items()}

        time_bounds = None
        # FIXME: datetime can not represent our min max range
        # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
        #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
        spatial_bounds = None
        if response.bbox is not None:
            spatial_bounds = BoundingBox2D.from_response(response.bbox)

        return VectorResultDescriptor(sref, data_type, columns, time_bounds, spatial_bounds)

    @classmethod
    def is_vector_result(cls) -&gt; bool:
        return True

    @property
    def data_type(self) -&gt; VectorDataType:
        &#39;&#39;&#39;Return the data type&#39;&#39;&#39;
        return self.__data_type

    @property
    def spatial_reference(self) -&gt; str:
        &#39;&#39;&#39;Return the spatial reference&#39;&#39;&#39;
        return super().spatial_reference

    @property
    def columns(self) -&gt; Dict[str, VectorColumnInfo]:
        &#39;&#39;&#39;Return the columns&#39;&#39;&#39;

        return self.__columns

    @property
    def spatial_bounds(self) -&gt; Optional[BoundingBox2D]:
        &#39;&#39;&#39;Return the spatial bounds&#39;&#39;&#39;
        return self.__spatial_bounds

    def __repr__(self) -&gt; str:
        &#39;&#39;&#39;Display representation of the vector result descriptor&#39;&#39;&#39;
        r = &#39;&#39;
        r += f&#39;Data type:         {self.data_type.value}\n&#39;
        r += f&#39;Spatial Reference: {self.spatial_reference}\n&#39;

        r += &#39;Columns:\n&#39;
        for column_name in self.columns:
            column_info = self.columns[column_name]
            r += f&#39;  {column_name}:\n&#39;
            r += f&#39;    Column Type: {column_info.data_type.value}\n&#39;
            r += f&#39;    Measurement: {column_info.measurement}\n&#39;

        return r

    def to_api_dict(self) -&gt; geoengine_openapi_client.TypedResultDescriptor:
        &#39;&#39;&#39;Convert the vector result descriptor to a dictionary&#39;&#39;&#39;

        return geoengine_openapi_client.TypedResultDescriptor(geoengine_openapi_client.TypedVectorResultDescriptor(
            type=&#39;vector&#39;,
            data_type=self.data_type.to_api_enum(),
            spatial_reference=self.spatial_reference,
            columns={name: column_info.to_api_dict() for name, column_info in self.columns.items()},
            time=self.time_bounds.time_str if self.time_bounds is not None else None,
            bbox=self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
            resolution=self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None,
        ))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.types.VectorResultDescriptor.from_response_vector"><code class="name flex">
<span>def <span class="ident">from_response_vector</span></span>(<span>response:geoengine_openapi_client.TypedVectorResultDescriptor) ><a title="geoengine.types.VectorResultDescriptor" href="#geoengine.types.VectorResultDescriptor">VectorResultDescriptor</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a vector result descriptor from an http response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_vector(
        response: geoengine_openapi_client.TypedVectorResultDescriptor) -&gt; VectorResultDescriptor:
    &#39;&#39;&#39;Parse a vector result descriptor from an http response&#39;&#39;&#39;
    sref = response.spatial_reference
    data_type = VectorDataType.from_string(response.data_type)
    columns = {name: VectorColumnInfo.from_response(info) for name, info in response.columns.items()}

    time_bounds = None
    # FIXME: datetime can not represent our min max range
    # if &#39;time&#39; in response and response[&#39;time&#39;] is not None:
    #    time_bounds = TimeInterval.from_response(response[&#39;time&#39;])
    spatial_bounds = None
    if response.bbox is not None:
        spatial_bounds = BoundingBox2D.from_response(response.bbox)

    return VectorResultDescriptor(sref, data_type, columns, time_bounds, spatial_bounds)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="geoengine.types.VectorResultDescriptor.columns"><code class="name">var <span class="ident">columns</span> :Dict[str,<a title="geoengine.types.VectorColumnInfo" href="#geoengine.types.VectorColumnInfo">VectorColumnInfo</a>]</code></dt>
<dd>
<div class="desc"><p>Return the columns</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def columns(self) -&gt; Dict[str, VectorColumnInfo]:
    &#39;&#39;&#39;Return the columns&#39;&#39;&#39;

    return self.__columns</code></pre>
</details>
</dd>
<dt id="geoengine.types.VectorResultDescriptor.data_type"><code class="name">var <span class="ident">data_type</span> :<a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a></code></dt>
<dd>
<div class="desc"><p>Return the data type</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_type(self) -&gt; VectorDataType:
    &#39;&#39;&#39;Return the data type&#39;&#39;&#39;
    return self.__data_type</code></pre>
</details>
</dd>
<dt id="geoengine.types.VectorResultDescriptor.spatial_bounds"><code class="name">var <span class="ident">spatial_bounds</span> :Optional[<a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a>]</code></dt>
<dd>
<div class="desc"><p>Return the spatial bounds</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def spatial_bounds(self) -&gt; Optional[BoundingBox2D]:
    &#39;&#39;&#39;Return the spatial bounds&#39;&#39;&#39;
    return self.__spatial_bounds</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.VectorResultDescriptor.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.typed_result_descriptor.TypedResultDescriptor</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the vector result descriptor to a dictionary</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.TypedResultDescriptor:
    &#39;&#39;&#39;Convert the vector result descriptor to a dictionary&#39;&#39;&#39;

    return geoengine_openapi_client.TypedResultDescriptor(geoengine_openapi_client.TypedVectorResultDescriptor(
        type=&#39;vector&#39;,
        data_type=self.data_type.to_api_enum(),
        spatial_reference=self.spatial_reference,
        columns={name: column_info.to_api_dict() for name, column_info in self.columns.items()},
        time=self.time_bounds.time_str if self.time_bounds is not None else None,
        bbox=self.spatial_bounds.to_api_dict() if self.spatial_bounds is not None else None,
        resolution=self.spatial_resolution.to_api_dict() if self.spatial_resolution is not None else None,
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.ResultDescriptor.from_response" href="#geoengine.types.ResultDescriptor.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_plot_result" href="#geoengine.types.ResultDescriptor.is_plot_result">is_plot_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_raster_result" href="#geoengine.types.ResultDescriptor.is_raster_result">is_raster_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_vector_result" href="#geoengine.types.ResultDescriptor.is_vector_result">is_vector_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_reference" href="#geoengine.types.ResultDescriptor.spatial_reference">spatial_reference</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_resolution" href="#geoengine.types.ResultDescriptor.spatial_resolution">spatial_resolution</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.time_bounds" href="#geoengine.types.ResultDescriptor.time_bounds">time_bounds</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.types.VectorSymbology"><code class="flex name class">
<span>class <span class="ident">VectorSymbology</span></span>
</code></dt>
<dd>
<div class="desc"><p>A vector symbology</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class VectorSymbology(Symbology):
    &#39;&#39;&#39;A vector symbology&#39;&#39;&#39;

    # TODO: implement

    def to_api_dict(self) -&gt; geoengine_openapi_client.Symbology:
        return None  # type: ignore</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="geoengine.types.VectorSymbology.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) >geoengine_openapi_client.models.symbology.Symbology</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.Symbology:
    return None  # type: ignore</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.types.Symbology.from_response" href="#geoengine.types.Symbology.from_response">from_response</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geoengine" href="index.html">geoengine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="geoengine.types.BoundingBox2D" href="#geoengine.types.BoundingBox2D">BoundingBox2D</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.BoundingBox2D.from_response" href="#geoengine.types.BoundingBox2D.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.BoundingBox2D.to_api_dict" href="#geoengine.types.BoundingBox2D.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.types.BoundingBox2D.xmax" href="#geoengine.types.BoundingBox2D.xmax">xmax</a></code></li>
<li><code><a title="geoengine.types.BoundingBox2D.xmin" href="#geoengine.types.BoundingBox2D.xmin">xmin</a></code></li>
<li><code><a title="geoengine.types.BoundingBox2D.ymax" href="#geoengine.types.BoundingBox2D.ymax">ymax</a></code></li>
<li><code><a title="geoengine.types.BoundingBox2D.ymin" href="#geoengine.types.BoundingBox2D.ymin">ymin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.ClassificationMeasurement" href="#geoengine.types.ClassificationMeasurement">ClassificationMeasurement</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.ClassificationMeasurement.classes" href="#geoengine.types.ClassificationMeasurement.classes">classes</a></code></li>
<li><code><a title="geoengine.types.ClassificationMeasurement.from_response_classification" href="#geoengine.types.ClassificationMeasurement.from_response_classification">from_response_classification</a></code></li>
<li><code><a title="geoengine.types.ClassificationMeasurement.measurement" href="#geoengine.types.ClassificationMeasurement.measurement">measurement</a></code></li>
<li><code><a title="geoengine.types.ClassificationMeasurement.to_api_dict" href="#geoengine.types.ClassificationMeasurement.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.ContinuousMeasurement" href="#geoengine.types.ContinuousMeasurement">ContinuousMeasurement</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.ContinuousMeasurement.from_response_continuous" href="#geoengine.types.ContinuousMeasurement.from_response_continuous">from_response_continuous</a></code></li>
<li><code><a title="geoengine.types.ContinuousMeasurement.measurement" href="#geoengine.types.ContinuousMeasurement.measurement">measurement</a></code></li>
<li><code><a title="geoengine.types.ContinuousMeasurement.to_api_dict" href="#geoengine.types.ContinuousMeasurement.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.types.ContinuousMeasurement.unit" href="#geoengine.types.ContinuousMeasurement.unit">unit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.DataId" href="#geoengine.types.DataId">DataId</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.DataId.from_response" href="#geoengine.types.DataId.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.DataId.to_api_dict" href="#geoengine.types.DataId.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.ExternalDataId" href="#geoengine.types.ExternalDataId">ExternalDataId</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.ExternalDataId.from_response_external" href="#geoengine.types.ExternalDataId.from_response_external">from_response_external</a></code></li>
<li><code><a title="geoengine.types.ExternalDataId.to_api_dict" href="#geoengine.types.ExternalDataId.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.FeatureDataType" href="#geoengine.types.FeatureDataType">FeatureDataType</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.FeatureDataType.BOOL" href="#geoengine.types.FeatureDataType.BOOL">BOOL</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.CATEGORY" href="#geoengine.types.FeatureDataType.CATEGORY">CATEGORY</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.DATETIME" href="#geoengine.types.FeatureDataType.DATETIME">DATETIME</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.FLOAT" href="#geoengine.types.FeatureDataType.FLOAT">FLOAT</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.INT" href="#geoengine.types.FeatureDataType.INT">INT</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.TEXT" href="#geoengine.types.FeatureDataType.TEXT">TEXT</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.from_string" href="#geoengine.types.FeatureDataType.from_string">from_string</a></code></li>
<li><code><a title="geoengine.types.FeatureDataType.to_api_enum" href="#geoengine.types.FeatureDataType.to_api_enum">to_api_enum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.GeoTransform" href="#geoengine.types.GeoTransform">GeoTransform</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.GeoTransform.coord_to_pixel_lr" href="#geoengine.types.GeoTransform.coord_to_pixel_lr">coord_to_pixel_lr</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.coord_to_pixel_ul" href="#geoengine.types.GeoTransform.coord_to_pixel_ul">coord_to_pixel_ul</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.from_response" href="#geoengine.types.GeoTransform.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.spatial_resolution" href="#geoengine.types.GeoTransform.spatial_resolution">spatial_resolution</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.to_api_dict" href="#geoengine.types.GeoTransform.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.to_gdal" href="#geoengine.types.GeoTransform.to_gdal">to_gdal</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.x_half_pixel_size" href="#geoengine.types.GeoTransform.x_half_pixel_size">x_half_pixel_size</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.x_max" href="#geoengine.types.GeoTransform.x_max">x_max</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.x_min" href="#geoengine.types.GeoTransform.x_min">x_min</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.x_pixel_size" href="#geoengine.types.GeoTransform.x_pixel_size">x_pixel_size</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.y_half_pixel_size" href="#geoengine.types.GeoTransform.y_half_pixel_size">y_half_pixel_size</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.y_max" href="#geoengine.types.GeoTransform.y_max">y_max</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.y_min" href="#geoengine.types.GeoTransform.y_min">y_min</a></code></li>
<li><code><a title="geoengine.types.GeoTransform.y_pixel_size" href="#geoengine.types.GeoTransform.y_pixel_size">y_pixel_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.InternalDataId" href="#geoengine.types.InternalDataId">InternalDataId</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.InternalDataId.from_response_internal" href="#geoengine.types.InternalDataId.from_response_internal">from_response_internal</a></code></li>
<li><code><a title="geoengine.types.InternalDataId.to_api_dict" href="#geoengine.types.InternalDataId.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.Measurement" href="#geoengine.types.Measurement">Measurement</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.Measurement.from_response" href="#geoengine.types.Measurement.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.Measurement.to_api_dict" href="#geoengine.types.Measurement.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.PlotResultDescriptor" href="#geoengine.types.PlotResultDescriptor">PlotResultDescriptor</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.PlotResultDescriptor.from_response_plot" href="#geoengine.types.PlotResultDescriptor.from_response_plot">from_response_plot</a></code></li>
<li><code><a title="geoengine.types.PlotResultDescriptor.spatial_bounds" href="#geoengine.types.PlotResultDescriptor.spatial_bounds">spatial_bounds</a></code></li>
<li><code><a title="geoengine.types.PlotResultDescriptor.to_api_dict" href="#geoengine.types.PlotResultDescriptor.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.Provenance" href="#geoengine.types.Provenance">Provenance</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.Provenance.citation" href="#geoengine.types.Provenance.citation">citation</a></code></li>
<li><code><a title="geoengine.types.Provenance.from_response" href="#geoengine.types.Provenance.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.Provenance.license" href="#geoengine.types.Provenance.license">license</a></code></li>
<li><code><a title="geoengine.types.Provenance.to_api_dict" href="#geoengine.types.Provenance.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.types.Provenance.uri" href="#geoengine.types.Provenance.uri">uri</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.ProvenanceEntry" href="#geoengine.types.ProvenanceEntry">ProvenanceEntry</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.ProvenanceEntry.data" href="#geoengine.types.ProvenanceEntry.data">data</a></code></li>
<li><code><a title="geoengine.types.ProvenanceEntry.from_response" href="#geoengine.types.ProvenanceEntry.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.ProvenanceEntry.provenance" href="#geoengine.types.ProvenanceEntry.provenance">provenance</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.QueryRectangle" href="#geoengine.types.QueryRectangle">QueryRectangle</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.QueryRectangle.as_raster_query_rectangle_api_dict" href="#geoengine.types.QueryRectangle.as_raster_query_rectangle_api_dict">as_raster_query_rectangle_api_dict</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.bbox_ogc" href="#geoengine.types.QueryRectangle.bbox_ogc">bbox_ogc</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.bbox_ogc_str" href="#geoengine.types.QueryRectangle.bbox_ogc_str">bbox_ogc_str</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.bbox_str" href="#geoengine.types.QueryRectangle.bbox_str">bbox_str</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.resolution_ogc" href="#geoengine.types.QueryRectangle.resolution_ogc">resolution_ogc</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.spatial_bounds" href="#geoengine.types.QueryRectangle.spatial_bounds">spatial_bounds</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.spatial_resolution" href="#geoengine.types.QueryRectangle.spatial_resolution">spatial_resolution</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.srs" href="#geoengine.types.QueryRectangle.srs">srs</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.time" href="#geoengine.types.QueryRectangle.time">time</a></code></li>
<li><code><a title="geoengine.types.QueryRectangle.time_str" href="#geoengine.types.QueryRectangle.time_str">time_str</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.RasterBandDescriptor" href="#geoengine.types.RasterBandDescriptor">RasterBandDescriptor</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.RasterBandDescriptor.from_response" href="#geoengine.types.RasterBandDescriptor.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.RasterBandDescriptor.measurement" href="#geoengine.types.RasterBandDescriptor.measurement">measurement</a></code></li>
<li><code><a title="geoengine.types.RasterBandDescriptor.name" href="#geoengine.types.RasterBandDescriptor.name">name</a></code></li>
<li><code><a title="geoengine.types.RasterBandDescriptor.to_api_dict" href="#geoengine.types.RasterBandDescriptor.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.RasterColorizer" href="#geoengine.types.RasterColorizer">RasterColorizer</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.RasterColorizer.from_response" href="#geoengine.types.RasterColorizer.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.RasterColorizer.to_api_dict" href="#geoengine.types.RasterColorizer.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.RasterResultDescriptor" href="#geoengine.types.RasterResultDescriptor">RasterResultDescriptor</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.RasterResultDescriptor.bands" href="#geoengine.types.RasterResultDescriptor.bands">bands</a></code></li>
<li><code><a title="geoengine.types.RasterResultDescriptor.data_type" href="#geoengine.types.RasterResultDescriptor.data_type">data_type</a></code></li>
<li><code><a title="geoengine.types.RasterResultDescriptor.from_response_raster" href="#geoengine.types.RasterResultDescriptor.from_response_raster">from_response_raster</a></code></li>
<li><code><a title="geoengine.types.RasterResultDescriptor.spatial_bounds" href="#geoengine.types.RasterResultDescriptor.spatial_bounds">spatial_bounds</a></code></li>
<li><code><a title="geoengine.types.RasterResultDescriptor.to_api_dict" href="#geoengine.types.RasterResultDescriptor.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.RasterSymbology" href="#geoengine.types.RasterSymbology">RasterSymbology</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.RasterSymbology.from_response_raster" href="#geoengine.types.RasterSymbology.from_response_raster">from_response_raster</a></code></li>
<li><code><a title="geoengine.types.RasterSymbology.to_api_dict" href="#geoengine.types.RasterSymbology.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.ResultDescriptor" href="#geoengine.types.ResultDescriptor">ResultDescriptor</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.ResultDescriptor.from_response" href="#geoengine.types.ResultDescriptor.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_plot_result" href="#geoengine.types.ResultDescriptor.is_plot_result">is_plot_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_raster_result" href="#geoengine.types.ResultDescriptor.is_raster_result">is_raster_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.is_vector_result" href="#geoengine.types.ResultDescriptor.is_vector_result">is_vector_result</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_reference" href="#geoengine.types.ResultDescriptor.spatial_reference">spatial_reference</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.spatial_resolution" href="#geoengine.types.ResultDescriptor.spatial_resolution">spatial_resolution</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.time_bounds" href="#geoengine.types.ResultDescriptor.time_bounds">time_bounds</a></code></li>
<li><code><a title="geoengine.types.ResultDescriptor.to_api_dict" href="#geoengine.types.ResultDescriptor.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.SingleBandRasterColorizer" href="#geoengine.types.SingleBandRasterColorizer">SingleBandRasterColorizer</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.SingleBandRasterColorizer.band" href="#geoengine.types.SingleBandRasterColorizer.band">band</a></code></li>
<li><code><a title="geoengine.types.SingleBandRasterColorizer.band_colorizer" href="#geoengine.types.SingleBandRasterColorizer.band_colorizer">band_colorizer</a></code></li>
<li><code><a title="geoengine.types.SingleBandRasterColorizer.from_single_band_response" href="#geoengine.types.SingleBandRasterColorizer.from_single_band_response">from_single_band_response</a></code></li>
<li><code><a title="geoengine.types.SingleBandRasterColorizer.to_api_dict" href="#geoengine.types.SingleBandRasterColorizer.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.SpatialBounds" href="#geoengine.types.SpatialBounds">SpatialBounds</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.SpatialBounds.as_bbox_str" href="#geoengine.types.SpatialBounds.as_bbox_str">as_bbox_str</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.as_bbox_tuple" href="#geoengine.types.SpatialBounds.as_bbox_tuple">as_bbox_tuple</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.x_axis_size" href="#geoengine.types.SpatialBounds.x_axis_size">x_axis_size</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.xmax" href="#geoengine.types.SpatialBounds.xmax">xmax</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.xmin" href="#geoengine.types.SpatialBounds.xmin">xmin</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.y_axis_size" href="#geoengine.types.SpatialBounds.y_axis_size">y_axis_size</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.ymax" href="#geoengine.types.SpatialBounds.ymax">ymax</a></code></li>
<li><code><a title="geoengine.types.SpatialBounds.ymin" href="#geoengine.types.SpatialBounds.ymin">ymin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.SpatialPartition2D" href="#geoengine.types.SpatialPartition2D">SpatialPartition2D</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.SpatialPartition2D.from_response" href="#geoengine.types.SpatialPartition2D.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.SpatialPartition2D.to_api_dict" href="#geoengine.types.SpatialPartition2D.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.types.SpatialPartition2D.to_bounding_box" href="#geoengine.types.SpatialPartition2D.to_bounding_box">to_bounding_box</a></code></li>
<li><code><a title="geoengine.types.SpatialPartition2D.xmax" href="#geoengine.types.SpatialPartition2D.xmax">xmax</a></code></li>
<li><code><a title="geoengine.types.SpatialPartition2D.xmin" href="#geoengine.types.SpatialPartition2D.xmin">xmin</a></code></li>
<li><code><a title="geoengine.types.SpatialPartition2D.ymax" href="#geoengine.types.SpatialPartition2D.ymax">ymax</a></code></li>
<li><code><a title="geoengine.types.SpatialPartition2D.ymin" href="#geoengine.types.SpatialPartition2D.ymin">ymin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.SpatialResolution" href="#geoengine.types.SpatialResolution">SpatialResolution</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.SpatialResolution.as_tuple" href="#geoengine.types.SpatialResolution.as_tuple">as_tuple</a></code></li>
<li><code><a title="geoengine.types.SpatialResolution.from_response" href="#geoengine.types.SpatialResolution.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.SpatialResolution.to_api_dict" href="#geoengine.types.SpatialResolution.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.types.SpatialResolution.x_resolution" href="#geoengine.types.SpatialResolution.x_resolution">x_resolution</a></code></li>
<li><code><a title="geoengine.types.SpatialResolution.y_resolution" href="#geoengine.types.SpatialResolution.y_resolution">y_resolution</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.Symbology" href="#geoengine.types.Symbology">Symbology</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.Symbology.from_response" href="#geoengine.types.Symbology.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.Symbology.to_api_dict" href="#geoengine.types.Symbology.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.TimeInterval" href="#geoengine.types.TimeInterval">TimeInterval</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.TimeInterval.end" href="#geoengine.types.TimeInterval.end">end</a></code></li>
<li><code><a title="geoengine.types.TimeInterval.from_response" href="#geoengine.types.TimeInterval.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.TimeInterval.is_instant" href="#geoengine.types.TimeInterval.is_instant">is_instant</a></code></li>
<li><code><a title="geoengine.types.TimeInterval.start" href="#geoengine.types.TimeInterval.start">start</a></code></li>
<li><code><a title="geoengine.types.TimeInterval.time_str" href="#geoengine.types.TimeInterval.time_str">time_str</a></code></li>
<li><code><a title="geoengine.types.TimeInterval.to_api_dict" href="#geoengine.types.TimeInterval.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.TimeStep" href="#geoengine.types.TimeStep">TimeStep</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.TimeStep.granularity" href="#geoengine.types.TimeStep.granularity">granularity</a></code></li>
<li><code><a title="geoengine.types.TimeStep.step" href="#geoengine.types.TimeStep.step">step</a></code></li>
<li><code><a title="geoengine.types.TimeStep.to_api_dict" href="#geoengine.types.TimeStep.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.TimeStepGranularity" href="#geoengine.types.TimeStepGranularity">TimeStepGranularity</a></code></h4>
<ul class="two-column">
<li><code><a title="geoengine.types.TimeStepGranularity.DAYS" href="#geoengine.types.TimeStepGranularity.DAYS">DAYS</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.HOURS" href="#geoengine.types.TimeStepGranularity.HOURS">HOURS</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.MILLIS" href="#geoengine.types.TimeStepGranularity.MILLIS">MILLIS</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.MINUTES" href="#geoengine.types.TimeStepGranularity.MINUTES">MINUTES</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.MONTHS" href="#geoengine.types.TimeStepGranularity.MONTHS">MONTHS</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.SECONDS" href="#geoengine.types.TimeStepGranularity.SECONDS">SECONDS</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.YEARS" href="#geoengine.types.TimeStepGranularity.YEARS">YEARS</a></code></li>
<li><code><a title="geoengine.types.TimeStepGranularity.to_api_enum" href="#geoengine.types.TimeStepGranularity.to_api_enum">to_api_enum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.UnitlessMeasurement" href="#geoengine.types.UnitlessMeasurement">UnitlessMeasurement</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.UnitlessMeasurement.to_api_dict" href="#geoengine.types.UnitlessMeasurement.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.VectorColumnInfo" href="#geoengine.types.VectorColumnInfo">VectorColumnInfo</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.VectorColumnInfo.data_type" href="#geoengine.types.VectorColumnInfo.data_type">data_type</a></code></li>
<li><code><a title="geoengine.types.VectorColumnInfo.from_response" href="#geoengine.types.VectorColumnInfo.from_response">from_response</a></code></li>
<li><code><a title="geoengine.types.VectorColumnInfo.measurement" href="#geoengine.types.VectorColumnInfo.measurement">measurement</a></code></li>
<li><code><a title="geoengine.types.VectorColumnInfo.to_api_dict" href="#geoengine.types.VectorColumnInfo.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.VectorDataType" href="#geoengine.types.VectorDataType">VectorDataType</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.VectorDataType.DATA" href="#geoengine.types.VectorDataType.DATA">DATA</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.MULTI_LINE_STRING" href="#geoengine.types.VectorDataType.MULTI_LINE_STRING">MULTI_LINE_STRING</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.MULTI_POINT" href="#geoengine.types.VectorDataType.MULTI_POINT">MULTI_POINT</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.MULTI_POLYGON" href="#geoengine.types.VectorDataType.MULTI_POLYGON">MULTI_POLYGON</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.from_api_enum" href="#geoengine.types.VectorDataType.from_api_enum">from_api_enum</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.from_geopandas_type_name" href="#geoengine.types.VectorDataType.from_geopandas_type_name">from_geopandas_type_name</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.from_literal" href="#geoengine.types.VectorDataType.from_literal">from_literal</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.from_string" href="#geoengine.types.VectorDataType.from_string">from_string</a></code></li>
<li><code><a title="geoengine.types.VectorDataType.to_api_enum" href="#geoengine.types.VectorDataType.to_api_enum">to_api_enum</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.VectorResultDescriptor" href="#geoengine.types.VectorResultDescriptor">VectorResultDescriptor</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.VectorResultDescriptor.columns" href="#geoengine.types.VectorResultDescriptor.columns">columns</a></code></li>
<li><code><a title="geoengine.types.VectorResultDescriptor.data_type" href="#geoengine.types.VectorResultDescriptor.data_type">data_type</a></code></li>
<li><code><a title="geoengine.types.VectorResultDescriptor.from_response_vector" href="#geoengine.types.VectorResultDescriptor.from_response_vector">from_response_vector</a></code></li>
<li><code><a title="geoengine.types.VectorResultDescriptor.spatial_bounds" href="#geoengine.types.VectorResultDescriptor.spatial_bounds">spatial_bounds</a></code></li>
<li><code><a title="geoengine.types.VectorResultDescriptor.to_api_dict" href="#geoengine.types.VectorResultDescriptor.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.types.VectorSymbology" href="#geoengine.types.VectorSymbology">VectorSymbology</a></code></h4>
<ul class="">
<li><code><a title="geoengine.types.VectorSymbology.to_api_dict" href="#geoengine.types.VectorSymbology.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>