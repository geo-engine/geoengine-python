<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>geoengine.colorizer API documentation</title>
<meta name="description" content="This module is used to generate geoengine compatible color map definitions as a json string." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>geoengine.colorizer</code></h1>
</header>
<section id="section-intro">
<p>This module is used to generate geoengine compatible color map definitions as a json string.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module is used to generate geoengine compatible color map definitions as a json string.&#34;&#34;&#34;

from __future__ import annotations
from abc import abstractmethod
from dataclasses import dataclass
import json
import warnings
from typing import Dict, List, Tuple, Union, cast
import numpy as np
import numpy.typing as npt
from matplotlib.colors import Colormap
from matplotlib.cm import ScalarMappable
import geoengine_openapi_client

Rgba = Tuple[int, int, int, int]


@dataclass
class ColorBreakpoint():
    &#34;&#34;&#34;This class is used to generate geoengine compatible color breakpoint definitions.&#34;&#34;&#34;
    value: float
    color: Rgba

    def to_api_dict(self) -&gt; geoengine_openapi_client.Breakpoint:
        &#34;&#34;&#34;Return the color breakpoint as a dictionary.&#34;&#34;&#34;
        return geoengine_openapi_client.Breakpoint(value=self.value, color=self.color)

    @staticmethod
    def from_response(response: geoengine_openapi_client.Breakpoint) -&gt; ColorBreakpoint:
        &#34;&#34;&#34;Parse a http response to a `ColorBreakpoint`.&#34;&#34;&#34;
        return ColorBreakpoint(cast(float, response.value), cast(Rgba, tuple(cast(List[int], response.color))))


@dataclass
class Colorizer():
    &#34;&#34;&#34;This class is used to generate geoengine compatible color map definitions as a json string.&#34;&#34;&#34;

    no_data_color: Rgba

    @staticmethod
    def linear_with_mpl_cmap(
        color_map: Union[str, Colormap],
        min_max: Tuple[float, float],
        n_steps: int = 10,
        over_color: Rgba = (0, 0, 0, 0),
        under_color: Rgba = (0, 0, 0, 0),
        no_data_color: Rgba = (0, 0, 0, 0)
    ) -&gt; LinearGradientColorizer:
        &#34;&#34;&#34;Initialize the colorizer.&#34;&#34;&#34;
        # pylint: disable=too-many-arguments,too-many-positional-arguments

        if n_steps &lt; 2:
            raise ValueError(f&#34;n_steps must be greater than or equal to 2, got {n_steps} instead.&#34;)
        if min_max[1] &lt;= min_max[0]:
            raise ValueError(f&#34;min_max[1] must be greater than min_max[0], got {min_max[1]} and {min_max[0]}.&#34;)
        if len(over_color) != 4:
            raise ValueError(f&#34;overColor must be a tuple of length 4, got {len(over_color)} instead.&#34;)
        if len(under_color) != 4:
            raise ValueError(f&#34;underColor must be a tuple of length 4, got {len(under_color)} instead.&#34;)
        if len(no_data_color) != 4:
            raise ValueError(f&#34;noDataColor must be a tuple of length 4, got {len(no_data_color)} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in no_data_color):
            raise ValueError(f&#34;noDataColor must be a RGBA color specification, got {no_data_color} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in over_color):
            raise ValueError(f&#34;overColor must be a RGBA color specification, got {over_color} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in under_color):
            raise ValueError(f&#34;underColor must be a RGBA color specification, got {under_color} instead.&#34;)

        # get the map, and transform it to a list of (uint8) rgba values
        list_of_rgba_colors: List[npt.NDArray[np.uint8]] = ScalarMappable(cmap=color_map).to_rgba(
            np.linspace(min_max[0], min_max[1], n_steps), bytes=True)

        # if you want to remap the colors, you can do it here (e.g. cutting of the most extreme colors)
        values_of_breakpoints: List[float] = np.linspace(min_max[0], min_max[1], n_steps).tolist()

        # generate color map steps for geoengine
        breakpoints: List[ColorBreakpoint] = [
            ColorBreakpoint(
                color=(int(color[0]), int(color[1]), int(color[2]), int(color[3])), value=value
            ) for (value, color) in zip(
                values_of_breakpoints, list_of_rgba_colors)
        ]

        return LinearGradientColorizer(
            breakpoints=breakpoints,
            no_data_color=no_data_color,
            over_color=over_color,
            under_color=under_color
        )

    @staticmethod
    def logarithmic_with_mpl_cmap(
        color_map: Union[str, Colormap],
        min_max: Tuple[float, float],
        n_steps: int = 10,
        over_color: Rgba = (0, 0, 0, 0),
        under_color: Rgba = (0, 0, 0, 0),
        no_data_color: Rgba = (0, 0, 0, 0)
    ) -&gt; LogarithmicGradientColorizer:
        &#34;&#34;&#34;Initialize the colorizer.&#34;&#34;&#34;
        # pylint: disable=too-many-arguments, too-many-positional-arguments

        if n_steps &lt; 2:
            raise ValueError(f&#34;n_steps must be greater than or equal to 2, got {n_steps} instead.&#34;)
        if min_max[0] &lt;= 0:
            raise ValueError(f&#34;min_max[0] must be greater than 0 for a logarithmic gradient, got {min_max[0]}.&#34;)
        if min_max[1] &lt;= min_max[0]:
            raise ValueError(f&#34;min_max[1] must be greater than min_max[0], got {min_max[1]} and {min_max[0]}.&#34;)
        if len(over_color) != 4:
            raise ValueError(f&#34;overColor must be a tuple of length 4, got {len(over_color)} instead.&#34;)
        if len(under_color) != 4:
            raise ValueError(f&#34;underColor must be a tuple of length 4, got {len(under_color)} instead.&#34;)
        if len(no_data_color) != 4:
            raise ValueError(f&#34;noDataColor must be a tuple of length 4, got {len(no_data_color)} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in no_data_color):
            raise ValueError(f&#34;noDataColor must be a RGBA color specification, got {no_data_color} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in over_color):
            raise ValueError(f&#34;overColor must be a RGBA color specification, got {over_color} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in under_color):
            raise ValueError(f&#34;underColor must be a RGBA color specification, got {under_color} instead.&#34;)

        # get the map, and transform it to a list of (uint8) rgba values
        list_of_rgba_colors: List[npt.NDArray[np.uint8]] = ScalarMappable(cmap=color_map).to_rgba(
            np.linspace(min_max[0], min_max[1], n_steps), bytes=True)

        # if you want to remap the colors, you can do it here (e.g. cutting of the most extreme colors)
        values_of_breakpoints: List[float] = np.logspace(np.log10(min_max[0]), np.log10(min_max[1]), n_steps).tolist()

        # generate color map steps for geoengine
        breakpoints: List[ColorBreakpoint] = [
            ColorBreakpoint(
                color=(int(color[0]), int(color[1]), int(color[2]), int(color[3])), value=value
            ) for (value, color) in zip(
                values_of_breakpoints, list_of_rgba_colors)
        ]

        return LogarithmicGradientColorizer(
            breakpoints=breakpoints,
            no_data_color=no_data_color,
            over_color=over_color,
            under_color=under_color
        )

    @staticmethod
    def palette(
        color_mapping: Dict[float, Rgba],
        default_color: Rgba = (0, 0, 0, 0),
        no_data_color: Rgba = (0, 0, 0, 0),
    ) -&gt; PaletteColorizer:
        &#34;&#34;&#34;Initialize the colorizer.&#34;&#34;&#34;

        if len(no_data_color) != 4:
            raise ValueError(f&#34;noDataColor must be a tuple of length 4, got {len(no_data_color)} instead.&#34;)
        if len(default_color) != 4:
            raise ValueError(f&#34;defaultColor must be a tuple of length 4, got {len(default_color)} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in no_data_color):
            raise ValueError(f&#34;noDataColor must be a RGBA color specification, got {no_data_color} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in default_color):
            raise ValueError(f&#34;defaultColor must be a RGBA color specification, got {default_color} instead.&#34;)

        return PaletteColorizer(
            colors=color_mapping,
            no_data_color=no_data_color,
            default_color=default_color,
        )

    @staticmethod
    def palette_with_colormap(
        values: List[float],
        color_map: Union[str, Colormap],
        default_color: Rgba = (0, 0, 0, 0),
        no_data_color: Rgba = (0, 0, 0, 0),
    ) -&gt; PaletteColorizer:
        &#34;&#34;&#34;This method generates a palette colorizer from a given list of values.
        A colormap can be given as an object or by name only.&#34;&#34;&#34;

        if len(no_data_color) != 4:
            raise ValueError(f&#34;noDataColor must be a tuple of length 4, got {len(no_data_color)} instead.&#34;)
        if len(default_color) != 4:
            raise ValueError(f&#34;defaultColor must be a tuple of length 4, got {len(default_color)} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in no_data_color):
            raise ValueError(f&#34;noDataColor must be a RGBA color specification, got {no_data_color} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in default_color):
            raise ValueError(f&#34;defaultColor must be a RGBA color specification, got {default_color} instead.&#34;)

        n_colors_of_cmap: int = ScalarMappable(cmap=color_map).get_cmap().N

        if n_colors_of_cmap &lt; len(values):
            warnings.warn(UserWarning(f&#34;Warning!\nYour colormap does not have enough colors &#34;
                                      &#34;to display all unique values of the palette!&#34;
                                      f&#34;\nNumber of values given: {len(values)} vs. &#34;
                                      f&#34;Number of available colors: {n_colors_of_cmap}&#34;))

        # we only need to generate enough different colors for all values specified in the colors parameter
        list_of_rgba_colors: List[npt.NDArray[np.uint8]] = ScalarMappable(cmap=color_map).to_rgba(
            np.linspace(0, len(values), len(values)), bytes=True)

        # generate the dict with value: color mapping
        color_mapping: Dict[float, Rgba] = dict(zip(
            values,
            [(int(color[0]), int(color[1]), int(color[2]), int(color[3])) for color in list_of_rgba_colors])
        )

        return PaletteColorizer(
            colors=color_mapping,
            no_data_color=no_data_color,
            default_color=default_color,
        )

    @staticmethod
    def rgba() -&gt; RgbaColorizer:
        return RgbaColorizer()

    @abstractmethod
    def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
        pass

    def to_json(self) -&gt; str:
        &#34;&#34;&#34;Return the colorizer as a JSON string.&#34;&#34;&#34;
        return json.dumps(self.to_api_dict())

    @staticmethod
    def from_response(response: geoengine_openapi_client.Colorizer) -&gt; Colorizer:
        &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;
        inner = response.actual_instance

        if isinstance(inner, geoengine_openapi_client.LinearGradient):
            return LinearGradientColorizer.from_response_linear(inner)
        if isinstance(inner, geoengine_openapi_client.PaletteColorizer):
            return PaletteColorizer.from_response_palette(inner)
        if isinstance(inner, geoengine_openapi_client.LogarithmicGradient):
            return LogarithmicGradientColorizer.from_response_logarithmic(inner)
        if isinstance(inner, geoengine_openapi_client.RgbaColorizer):
            return RgbaColorizer.from_response_rgba(inner)

        raise TypeError(&#34;Unknown colorizer type&#34;)


@dataclass
class LinearGradientColorizer(Colorizer):
    &#39;&#39;&#39;A linear gradient colorizer.&#39;&#39;&#39;
    breakpoints: List[ColorBreakpoint]
    over_color: Rgba
    under_color: Rgba

    @staticmethod
    def from_response_linear(response: geoengine_openapi_client.LinearGradient) -&gt; LinearGradientColorizer:
        &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;
        breakpoints = [ColorBreakpoint.from_response(breakpoint) for breakpoint in response.breakpoints]
        return LinearGradientColorizer(
            no_data_color=response.no_data_color,
            breakpoints=breakpoints,
            over_color=response.over_color,
            under_color=response.under_color,
        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
        &#34;&#34;&#34;Return the colorizer as a dictionary.&#34;&#34;&#34;
        return geoengine_openapi_client.Colorizer(geoengine_openapi_client.LinearGradient(
            type=&#39;linearGradient&#39;,
            breakpoints=[breakpoint.to_api_dict() for breakpoint in self.breakpoints],
            no_data_color=self.no_data_color,
            over_color=self.over_color,
            under_color=self.under_color
        ))


@dataclass
class LogarithmicGradientColorizer(Colorizer):
    &#39;&#39;&#39;A logarithmic gradient colorizer.&#39;&#39;&#39;
    breakpoints: List[ColorBreakpoint]
    over_color: Rgba
    under_color: Rgba

    @staticmethod
    def from_response_logarithmic(
            response: geoengine_openapi_client.LogarithmicGradient) -&gt; LogarithmicGradientColorizer:
        &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;
        breakpoints = [ColorBreakpoint.from_response(breakpoint) for breakpoint in response.breakpoints]
        return LogarithmicGradientColorizer(
            breakpoints=breakpoints,
            no_data_color=response.no_data_color,
            over_color=response.over_color,
            under_color=response.under_color,
        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
        &#34;&#34;&#34;Return the colorizer as a dictionary.&#34;&#34;&#34;
        return geoengine_openapi_client.Colorizer(geoengine_openapi_client.LogarithmicGradient(
            type=&#39;logarithmicGradient&#39;,
            breakpoints=[breakpoint.to_api_dict() for breakpoint in self.breakpoints],
            no_data_color=self.no_data_color,
            over_color=self.over_color,
            under_color=self.under_color,
        ))


@dataclass
class PaletteColorizer(Colorizer):
    &#39;&#39;&#39;A palette colorizer.&#39;&#39;&#39;
    colors: Dict[float, Rgba]
    default_color: Rgba

    @staticmethod
    def from_response_palette(response: geoengine_openapi_client.PaletteColorizer) -&gt; PaletteColorizer:
        &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;

        return PaletteColorizer(
            colors={float(k): v for k, v in response.colors.items()},
            no_data_color=response.no_data_color,
            default_color=response.default_color,
        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
        &#34;&#34;&#34;Return the colorizer as a dictionary.&#34;&#34;&#34;
        return geoengine_openapi_client.Colorizer(geoengine_openapi_client.PaletteColorizer(
            type=&#39;palette&#39;,
            colors=self.colors,
            default_color=self.default_color,
            no_data_color=self.no_data_color,
        ))


class RgbaColorizer(Colorizer):
    &#39;&#39;&#39;A Rgba colorizer.&#39;&#39;&#39;

    def __init__(self, no_data_color: Rgba = (0, 0, 0, 0)):
        super().__init__(no_data_color)

    @staticmethod
    def from_response_rgba(_response: geoengine_openapi_client.RgbaColorizer) -&gt; RgbaColorizer:
        &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;

        return RgbaColorizer()

    def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
        &#34;&#34;&#34;Return the colorizer as a dictionary.&#34;&#34;&#34;
        return geoengine_openapi_client.Colorizer(geoengine_openapi_client.RgbaColorizer(
            type=&#39;rgba&#39;,
        ))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="geoengine.colorizer.ColorBreakpoint"><code class="flex name class">
<span>class <span class="ident">ColorBreakpoint</span></span>
<span>(</span><span>value: float, color: Rgba)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to generate geoengine compatible color breakpoint definitions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class ColorBreakpoint():
    &#34;&#34;&#34;This class is used to generate geoengine compatible color breakpoint definitions.&#34;&#34;&#34;
    value: float
    color: Rgba

    def to_api_dict(self) -&gt; geoengine_openapi_client.Breakpoint:
        &#34;&#34;&#34;Return the color breakpoint as a dictionary.&#34;&#34;&#34;
        return geoengine_openapi_client.Breakpoint(value=self.value, color=self.color)

    @staticmethod
    def from_response(response: geoengine_openapi_client.Breakpoint) -&gt; ColorBreakpoint:
        &#34;&#34;&#34;Parse a http response to a `ColorBreakpoint`.&#34;&#34;&#34;
        return ColorBreakpoint(cast(float, response.value), cast(Rgba, tuple(cast(List[int], response.color))))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.colorizer.ColorBreakpoint.color"><code class="name">var <span class="ident">color</span> : Tuple[int, int, int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.colorizer.ColorBreakpoint.value"><code class="name">var <span class="ident">value</span> : float</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.colorizer.ColorBreakpoint.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response: geoengine_openapi_client.Breakpoint) ‑> <a title="geoengine.colorizer.ColorBreakpoint" href="#geoengine.colorizer.ColorBreakpoint">ColorBreakpoint</a></span>
</code></dt>
<dd>
<div class="desc"><p>Parse a http response to a <code><a title="geoengine.colorizer.ColorBreakpoint" href="#geoengine.colorizer.ColorBreakpoint">ColorBreakpoint</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: geoengine_openapi_client.Breakpoint) -&gt; ColorBreakpoint:
    &#34;&#34;&#34;Parse a http response to a `ColorBreakpoint`.&#34;&#34;&#34;
    return ColorBreakpoint(cast(float, response.value), cast(Rgba, tuple(cast(List[int], response.color))))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.colorizer.ColorBreakpoint.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ‑> geoengine_openapi_client.models.breakpoint.Breakpoint</span>
</code></dt>
<dd>
<div class="desc"><p>Return the color breakpoint as a dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.Breakpoint:
    &#34;&#34;&#34;Return the color breakpoint as a dictionary.&#34;&#34;&#34;
    return geoengine_openapi_client.Breakpoint(value=self.value, color=self.color)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.colorizer.Colorizer"><code class="flex name class">
<span>class <span class="ident">Colorizer</span></span>
<span>(</span><span>no_data_color: Rgba)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is used to generate geoengine compatible color map definitions as a json string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class Colorizer():
    &#34;&#34;&#34;This class is used to generate geoengine compatible color map definitions as a json string.&#34;&#34;&#34;

    no_data_color: Rgba

    @staticmethod
    def linear_with_mpl_cmap(
        color_map: Union[str, Colormap],
        min_max: Tuple[float, float],
        n_steps: int = 10,
        over_color: Rgba = (0, 0, 0, 0),
        under_color: Rgba = (0, 0, 0, 0),
        no_data_color: Rgba = (0, 0, 0, 0)
    ) -&gt; LinearGradientColorizer:
        &#34;&#34;&#34;Initialize the colorizer.&#34;&#34;&#34;
        # pylint: disable=too-many-arguments,too-many-positional-arguments

        if n_steps &lt; 2:
            raise ValueError(f&#34;n_steps must be greater than or equal to 2, got {n_steps} instead.&#34;)
        if min_max[1] &lt;= min_max[0]:
            raise ValueError(f&#34;min_max[1] must be greater than min_max[0], got {min_max[1]} and {min_max[0]}.&#34;)
        if len(over_color) != 4:
            raise ValueError(f&#34;overColor must be a tuple of length 4, got {len(over_color)} instead.&#34;)
        if len(under_color) != 4:
            raise ValueError(f&#34;underColor must be a tuple of length 4, got {len(under_color)} instead.&#34;)
        if len(no_data_color) != 4:
            raise ValueError(f&#34;noDataColor must be a tuple of length 4, got {len(no_data_color)} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in no_data_color):
            raise ValueError(f&#34;noDataColor must be a RGBA color specification, got {no_data_color} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in over_color):
            raise ValueError(f&#34;overColor must be a RGBA color specification, got {over_color} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in under_color):
            raise ValueError(f&#34;underColor must be a RGBA color specification, got {under_color} instead.&#34;)

        # get the map, and transform it to a list of (uint8) rgba values
        list_of_rgba_colors: List[npt.NDArray[np.uint8]] = ScalarMappable(cmap=color_map).to_rgba(
            np.linspace(min_max[0], min_max[1], n_steps), bytes=True)

        # if you want to remap the colors, you can do it here (e.g. cutting of the most extreme colors)
        values_of_breakpoints: List[float] = np.linspace(min_max[0], min_max[1], n_steps).tolist()

        # generate color map steps for geoengine
        breakpoints: List[ColorBreakpoint] = [
            ColorBreakpoint(
                color=(int(color[0]), int(color[1]), int(color[2]), int(color[3])), value=value
            ) for (value, color) in zip(
                values_of_breakpoints, list_of_rgba_colors)
        ]

        return LinearGradientColorizer(
            breakpoints=breakpoints,
            no_data_color=no_data_color,
            over_color=over_color,
            under_color=under_color
        )

    @staticmethod
    def logarithmic_with_mpl_cmap(
        color_map: Union[str, Colormap],
        min_max: Tuple[float, float],
        n_steps: int = 10,
        over_color: Rgba = (0, 0, 0, 0),
        under_color: Rgba = (0, 0, 0, 0),
        no_data_color: Rgba = (0, 0, 0, 0)
    ) -&gt; LogarithmicGradientColorizer:
        &#34;&#34;&#34;Initialize the colorizer.&#34;&#34;&#34;
        # pylint: disable=too-many-arguments, too-many-positional-arguments

        if n_steps &lt; 2:
            raise ValueError(f&#34;n_steps must be greater than or equal to 2, got {n_steps} instead.&#34;)
        if min_max[0] &lt;= 0:
            raise ValueError(f&#34;min_max[0] must be greater than 0 for a logarithmic gradient, got {min_max[0]}.&#34;)
        if min_max[1] &lt;= min_max[0]:
            raise ValueError(f&#34;min_max[1] must be greater than min_max[0], got {min_max[1]} and {min_max[0]}.&#34;)
        if len(over_color) != 4:
            raise ValueError(f&#34;overColor must be a tuple of length 4, got {len(over_color)} instead.&#34;)
        if len(under_color) != 4:
            raise ValueError(f&#34;underColor must be a tuple of length 4, got {len(under_color)} instead.&#34;)
        if len(no_data_color) != 4:
            raise ValueError(f&#34;noDataColor must be a tuple of length 4, got {len(no_data_color)} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in no_data_color):
            raise ValueError(f&#34;noDataColor must be a RGBA color specification, got {no_data_color} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in over_color):
            raise ValueError(f&#34;overColor must be a RGBA color specification, got {over_color} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in under_color):
            raise ValueError(f&#34;underColor must be a RGBA color specification, got {under_color} instead.&#34;)

        # get the map, and transform it to a list of (uint8) rgba values
        list_of_rgba_colors: List[npt.NDArray[np.uint8]] = ScalarMappable(cmap=color_map).to_rgba(
            np.linspace(min_max[0], min_max[1], n_steps), bytes=True)

        # if you want to remap the colors, you can do it here (e.g. cutting of the most extreme colors)
        values_of_breakpoints: List[float] = np.logspace(np.log10(min_max[0]), np.log10(min_max[1]), n_steps).tolist()

        # generate color map steps for geoengine
        breakpoints: List[ColorBreakpoint] = [
            ColorBreakpoint(
                color=(int(color[0]), int(color[1]), int(color[2]), int(color[3])), value=value
            ) for (value, color) in zip(
                values_of_breakpoints, list_of_rgba_colors)
        ]

        return LogarithmicGradientColorizer(
            breakpoints=breakpoints,
            no_data_color=no_data_color,
            over_color=over_color,
            under_color=under_color
        )

    @staticmethod
    def palette(
        color_mapping: Dict[float, Rgba],
        default_color: Rgba = (0, 0, 0, 0),
        no_data_color: Rgba = (0, 0, 0, 0),
    ) -&gt; PaletteColorizer:
        &#34;&#34;&#34;Initialize the colorizer.&#34;&#34;&#34;

        if len(no_data_color) != 4:
            raise ValueError(f&#34;noDataColor must be a tuple of length 4, got {len(no_data_color)} instead.&#34;)
        if len(default_color) != 4:
            raise ValueError(f&#34;defaultColor must be a tuple of length 4, got {len(default_color)} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in no_data_color):
            raise ValueError(f&#34;noDataColor must be a RGBA color specification, got {no_data_color} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in default_color):
            raise ValueError(f&#34;defaultColor must be a RGBA color specification, got {default_color} instead.&#34;)

        return PaletteColorizer(
            colors=color_mapping,
            no_data_color=no_data_color,
            default_color=default_color,
        )

    @staticmethod
    def palette_with_colormap(
        values: List[float],
        color_map: Union[str, Colormap],
        default_color: Rgba = (0, 0, 0, 0),
        no_data_color: Rgba = (0, 0, 0, 0),
    ) -&gt; PaletteColorizer:
        &#34;&#34;&#34;This method generates a palette colorizer from a given list of values.
        A colormap can be given as an object or by name only.&#34;&#34;&#34;

        if len(no_data_color) != 4:
            raise ValueError(f&#34;noDataColor must be a tuple of length 4, got {len(no_data_color)} instead.&#34;)
        if len(default_color) != 4:
            raise ValueError(f&#34;defaultColor must be a tuple of length 4, got {len(default_color)} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in no_data_color):
            raise ValueError(f&#34;noDataColor must be a RGBA color specification, got {no_data_color} instead.&#34;)
        if not all(0 &lt;= elem &lt; 256 for elem in default_color):
            raise ValueError(f&#34;defaultColor must be a RGBA color specification, got {default_color} instead.&#34;)

        n_colors_of_cmap: int = ScalarMappable(cmap=color_map).get_cmap().N

        if n_colors_of_cmap &lt; len(values):
            warnings.warn(UserWarning(f&#34;Warning!\nYour colormap does not have enough colors &#34;
                                      &#34;to display all unique values of the palette!&#34;
                                      f&#34;\nNumber of values given: {len(values)} vs. &#34;
                                      f&#34;Number of available colors: {n_colors_of_cmap}&#34;))

        # we only need to generate enough different colors for all values specified in the colors parameter
        list_of_rgba_colors: List[npt.NDArray[np.uint8]] = ScalarMappable(cmap=color_map).to_rgba(
            np.linspace(0, len(values), len(values)), bytes=True)

        # generate the dict with value: color mapping
        color_mapping: Dict[float, Rgba] = dict(zip(
            values,
            [(int(color[0]), int(color[1]), int(color[2]), int(color[3])) for color in list_of_rgba_colors])
        )

        return PaletteColorizer(
            colors=color_mapping,
            no_data_color=no_data_color,
            default_color=default_color,
        )

    @staticmethod
    def rgba() -&gt; RgbaColorizer:
        return RgbaColorizer()

    @abstractmethod
    def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
        pass

    def to_json(self) -&gt; str:
        &#34;&#34;&#34;Return the colorizer as a JSON string.&#34;&#34;&#34;
        return json.dumps(self.to_api_dict())

    @staticmethod
    def from_response(response: geoengine_openapi_client.Colorizer) -&gt; Colorizer:
        &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;
        inner = response.actual_instance

        if isinstance(inner, geoengine_openapi_client.LinearGradient):
            return LinearGradientColorizer.from_response_linear(inner)
        if isinstance(inner, geoengine_openapi_client.PaletteColorizer):
            return PaletteColorizer.from_response_palette(inner)
        if isinstance(inner, geoengine_openapi_client.LogarithmicGradient):
            return LogarithmicGradientColorizer.from_response_logarithmic(inner)
        if isinstance(inner, geoengine_openapi_client.RgbaColorizer):
            return RgbaColorizer.from_response_rgba(inner)

        raise TypeError(&#34;Unknown colorizer type&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="geoengine.colorizer.LinearGradientColorizer" href="#geoengine.colorizer.LinearGradientColorizer">LinearGradientColorizer</a></li>
<li><a title="geoengine.colorizer.LogarithmicGradientColorizer" href="#geoengine.colorizer.LogarithmicGradientColorizer">LogarithmicGradientColorizer</a></li>
<li><a title="geoengine.colorizer.PaletteColorizer" href="#geoengine.colorizer.PaletteColorizer">PaletteColorizer</a></li>
<li><a title="geoengine.colorizer.RgbaColorizer" href="#geoengine.colorizer.RgbaColorizer">RgbaColorizer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.colorizer.Colorizer.no_data_color"><code class="name">var <span class="ident">no_data_color</span> : Tuple[int, int, int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.colorizer.Colorizer.from_response"><code class="name flex">
<span>def <span class="ident">from_response</span></span>(<span>response: geoengine_openapi_client.Colorizer) ‑> <a title="geoengine.colorizer.Colorizer" href="#geoengine.colorizer.Colorizer">Colorizer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a colorizer from a response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response(response: geoengine_openapi_client.Colorizer) -&gt; Colorizer:
    &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;
    inner = response.actual_instance

    if isinstance(inner, geoengine_openapi_client.LinearGradient):
        return LinearGradientColorizer.from_response_linear(inner)
    if isinstance(inner, geoengine_openapi_client.PaletteColorizer):
        return PaletteColorizer.from_response_palette(inner)
    if isinstance(inner, geoengine_openapi_client.LogarithmicGradient):
        return LogarithmicGradientColorizer.from_response_logarithmic(inner)
    if isinstance(inner, geoengine_openapi_client.RgbaColorizer):
        return RgbaColorizer.from_response_rgba(inner)

    raise TypeError(&#34;Unknown colorizer type&#34;)</code></pre>
</details>
</dd>
<dt id="geoengine.colorizer.Colorizer.linear_with_mpl_cmap"><code class="name flex">
<span>def <span class="ident">linear_with_mpl_cmap</span></span>(<span>color_map: Union[str, Colormap], min_max: Tuple[float, float], n_steps: int = 10, over_color: Rgba = (0, 0, 0, 0), under_color: Rgba = (0, 0, 0, 0), no_data_color: Rgba = (0, 0, 0, 0)) ‑> <a title="geoengine.colorizer.LinearGradientColorizer" href="#geoengine.colorizer.LinearGradientColorizer">LinearGradientColorizer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the colorizer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def linear_with_mpl_cmap(
    color_map: Union[str, Colormap],
    min_max: Tuple[float, float],
    n_steps: int = 10,
    over_color: Rgba = (0, 0, 0, 0),
    under_color: Rgba = (0, 0, 0, 0),
    no_data_color: Rgba = (0, 0, 0, 0)
) -&gt; LinearGradientColorizer:
    &#34;&#34;&#34;Initialize the colorizer.&#34;&#34;&#34;
    # pylint: disable=too-many-arguments,too-many-positional-arguments

    if n_steps &lt; 2:
        raise ValueError(f&#34;n_steps must be greater than or equal to 2, got {n_steps} instead.&#34;)
    if min_max[1] &lt;= min_max[0]:
        raise ValueError(f&#34;min_max[1] must be greater than min_max[0], got {min_max[1]} and {min_max[0]}.&#34;)
    if len(over_color) != 4:
        raise ValueError(f&#34;overColor must be a tuple of length 4, got {len(over_color)} instead.&#34;)
    if len(under_color) != 4:
        raise ValueError(f&#34;underColor must be a tuple of length 4, got {len(under_color)} instead.&#34;)
    if len(no_data_color) != 4:
        raise ValueError(f&#34;noDataColor must be a tuple of length 4, got {len(no_data_color)} instead.&#34;)
    if not all(0 &lt;= elem &lt; 256 for elem in no_data_color):
        raise ValueError(f&#34;noDataColor must be a RGBA color specification, got {no_data_color} instead.&#34;)
    if not all(0 &lt;= elem &lt; 256 for elem in over_color):
        raise ValueError(f&#34;overColor must be a RGBA color specification, got {over_color} instead.&#34;)
    if not all(0 &lt;= elem &lt; 256 for elem in under_color):
        raise ValueError(f&#34;underColor must be a RGBA color specification, got {under_color} instead.&#34;)

    # get the map, and transform it to a list of (uint8) rgba values
    list_of_rgba_colors: List[npt.NDArray[np.uint8]] = ScalarMappable(cmap=color_map).to_rgba(
        np.linspace(min_max[0], min_max[1], n_steps), bytes=True)

    # if you want to remap the colors, you can do it here (e.g. cutting of the most extreme colors)
    values_of_breakpoints: List[float] = np.linspace(min_max[0], min_max[1], n_steps).tolist()

    # generate color map steps for geoengine
    breakpoints: List[ColorBreakpoint] = [
        ColorBreakpoint(
            color=(int(color[0]), int(color[1]), int(color[2]), int(color[3])), value=value
        ) for (value, color) in zip(
            values_of_breakpoints, list_of_rgba_colors)
    ]

    return LinearGradientColorizer(
        breakpoints=breakpoints,
        no_data_color=no_data_color,
        over_color=over_color,
        under_color=under_color
    )</code></pre>
</details>
</dd>
<dt id="geoengine.colorizer.Colorizer.logarithmic_with_mpl_cmap"><code class="name flex">
<span>def <span class="ident">logarithmic_with_mpl_cmap</span></span>(<span>color_map: Union[str, Colormap], min_max: Tuple[float, float], n_steps: int = 10, over_color: Rgba = (0, 0, 0, 0), under_color: Rgba = (0, 0, 0, 0), no_data_color: Rgba = (0, 0, 0, 0)) ‑> <a title="geoengine.colorizer.LogarithmicGradientColorizer" href="#geoengine.colorizer.LogarithmicGradientColorizer">LogarithmicGradientColorizer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the colorizer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def logarithmic_with_mpl_cmap(
    color_map: Union[str, Colormap],
    min_max: Tuple[float, float],
    n_steps: int = 10,
    over_color: Rgba = (0, 0, 0, 0),
    under_color: Rgba = (0, 0, 0, 0),
    no_data_color: Rgba = (0, 0, 0, 0)
) -&gt; LogarithmicGradientColorizer:
    &#34;&#34;&#34;Initialize the colorizer.&#34;&#34;&#34;
    # pylint: disable=too-many-arguments, too-many-positional-arguments

    if n_steps &lt; 2:
        raise ValueError(f&#34;n_steps must be greater than or equal to 2, got {n_steps} instead.&#34;)
    if min_max[0] &lt;= 0:
        raise ValueError(f&#34;min_max[0] must be greater than 0 for a logarithmic gradient, got {min_max[0]}.&#34;)
    if min_max[1] &lt;= min_max[0]:
        raise ValueError(f&#34;min_max[1] must be greater than min_max[0], got {min_max[1]} and {min_max[0]}.&#34;)
    if len(over_color) != 4:
        raise ValueError(f&#34;overColor must be a tuple of length 4, got {len(over_color)} instead.&#34;)
    if len(under_color) != 4:
        raise ValueError(f&#34;underColor must be a tuple of length 4, got {len(under_color)} instead.&#34;)
    if len(no_data_color) != 4:
        raise ValueError(f&#34;noDataColor must be a tuple of length 4, got {len(no_data_color)} instead.&#34;)
    if not all(0 &lt;= elem &lt; 256 for elem in no_data_color):
        raise ValueError(f&#34;noDataColor must be a RGBA color specification, got {no_data_color} instead.&#34;)
    if not all(0 &lt;= elem &lt; 256 for elem in over_color):
        raise ValueError(f&#34;overColor must be a RGBA color specification, got {over_color} instead.&#34;)
    if not all(0 &lt;= elem &lt; 256 for elem in under_color):
        raise ValueError(f&#34;underColor must be a RGBA color specification, got {under_color} instead.&#34;)

    # get the map, and transform it to a list of (uint8) rgba values
    list_of_rgba_colors: List[npt.NDArray[np.uint8]] = ScalarMappable(cmap=color_map).to_rgba(
        np.linspace(min_max[0], min_max[1], n_steps), bytes=True)

    # if you want to remap the colors, you can do it here (e.g. cutting of the most extreme colors)
    values_of_breakpoints: List[float] = np.logspace(np.log10(min_max[0]), np.log10(min_max[1]), n_steps).tolist()

    # generate color map steps for geoengine
    breakpoints: List[ColorBreakpoint] = [
        ColorBreakpoint(
            color=(int(color[0]), int(color[1]), int(color[2]), int(color[3])), value=value
        ) for (value, color) in zip(
            values_of_breakpoints, list_of_rgba_colors)
    ]

    return LogarithmicGradientColorizer(
        breakpoints=breakpoints,
        no_data_color=no_data_color,
        over_color=over_color,
        under_color=under_color
    )</code></pre>
</details>
</dd>
<dt id="geoengine.colorizer.Colorizer.palette"><code class="name flex">
<span>def <span class="ident">palette</span></span>(<span>color_mapping: Dict[float, Rgba], default_color: Rgba = (0, 0, 0, 0), no_data_color: Rgba = (0, 0, 0, 0)) ‑> <a title="geoengine.colorizer.PaletteColorizer" href="#geoengine.colorizer.PaletteColorizer">PaletteColorizer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the colorizer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def palette(
    color_mapping: Dict[float, Rgba],
    default_color: Rgba = (0, 0, 0, 0),
    no_data_color: Rgba = (0, 0, 0, 0),
) -&gt; PaletteColorizer:
    &#34;&#34;&#34;Initialize the colorizer.&#34;&#34;&#34;

    if len(no_data_color) != 4:
        raise ValueError(f&#34;noDataColor must be a tuple of length 4, got {len(no_data_color)} instead.&#34;)
    if len(default_color) != 4:
        raise ValueError(f&#34;defaultColor must be a tuple of length 4, got {len(default_color)} instead.&#34;)
    if not all(0 &lt;= elem &lt; 256 for elem in no_data_color):
        raise ValueError(f&#34;noDataColor must be a RGBA color specification, got {no_data_color} instead.&#34;)
    if not all(0 &lt;= elem &lt; 256 for elem in default_color):
        raise ValueError(f&#34;defaultColor must be a RGBA color specification, got {default_color} instead.&#34;)

    return PaletteColorizer(
        colors=color_mapping,
        no_data_color=no_data_color,
        default_color=default_color,
    )</code></pre>
</details>
</dd>
<dt id="geoengine.colorizer.Colorizer.palette_with_colormap"><code class="name flex">
<span>def <span class="ident">palette_with_colormap</span></span>(<span>values: List[float], color_map: Union[str, Colormap], default_color: Rgba = (0, 0, 0, 0), no_data_color: Rgba = (0, 0, 0, 0)) ‑> <a title="geoengine.colorizer.PaletteColorizer" href="#geoengine.colorizer.PaletteColorizer">PaletteColorizer</a></span>
</code></dt>
<dd>
<div class="desc"><p>This method generates a palette colorizer from a given list of values.
A colormap can be given as an object or by name only.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def palette_with_colormap(
    values: List[float],
    color_map: Union[str, Colormap],
    default_color: Rgba = (0, 0, 0, 0),
    no_data_color: Rgba = (0, 0, 0, 0),
) -&gt; PaletteColorizer:
    &#34;&#34;&#34;This method generates a palette colorizer from a given list of values.
    A colormap can be given as an object or by name only.&#34;&#34;&#34;

    if len(no_data_color) != 4:
        raise ValueError(f&#34;noDataColor must be a tuple of length 4, got {len(no_data_color)} instead.&#34;)
    if len(default_color) != 4:
        raise ValueError(f&#34;defaultColor must be a tuple of length 4, got {len(default_color)} instead.&#34;)
    if not all(0 &lt;= elem &lt; 256 for elem in no_data_color):
        raise ValueError(f&#34;noDataColor must be a RGBA color specification, got {no_data_color} instead.&#34;)
    if not all(0 &lt;= elem &lt; 256 for elem in default_color):
        raise ValueError(f&#34;defaultColor must be a RGBA color specification, got {default_color} instead.&#34;)

    n_colors_of_cmap: int = ScalarMappable(cmap=color_map).get_cmap().N

    if n_colors_of_cmap &lt; len(values):
        warnings.warn(UserWarning(f&#34;Warning!\nYour colormap does not have enough colors &#34;
                                  &#34;to display all unique values of the palette!&#34;
                                  f&#34;\nNumber of values given: {len(values)} vs. &#34;
                                  f&#34;Number of available colors: {n_colors_of_cmap}&#34;))

    # we only need to generate enough different colors for all values specified in the colors parameter
    list_of_rgba_colors: List[npt.NDArray[np.uint8]] = ScalarMappable(cmap=color_map).to_rgba(
        np.linspace(0, len(values), len(values)), bytes=True)

    # generate the dict with value: color mapping
    color_mapping: Dict[float, Rgba] = dict(zip(
        values,
        [(int(color[0]), int(color[1]), int(color[2]), int(color[3])) for color in list_of_rgba_colors])
    )

    return PaletteColorizer(
        colors=color_mapping,
        no_data_color=no_data_color,
        default_color=default_color,
    )</code></pre>
</details>
</dd>
<dt id="geoengine.colorizer.Colorizer.rgba"><code class="name flex">
<span>def <span class="ident">rgba</span></span>(<span>) ‑> <a title="geoengine.colorizer.RgbaColorizer" href="#geoengine.colorizer.RgbaColorizer">RgbaColorizer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def rgba() -&gt; RgbaColorizer:
    return RgbaColorizer()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.colorizer.Colorizer.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ‑> geoengine_openapi_client.models.colorizer.Colorizer</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
    pass</code></pre>
</details>
</dd>
<dt id="geoengine.colorizer.Colorizer.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Return the colorizer as a JSON string.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; str:
    &#34;&#34;&#34;Return the colorizer as a JSON string.&#34;&#34;&#34;
    return json.dumps(self.to_api_dict())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="geoengine.colorizer.LinearGradientColorizer"><code class="flex name class">
<span>class <span class="ident">LinearGradientColorizer</span></span>
<span>(</span><span>no_data_color: Rgba, breakpoints: List[<a title="geoengine.colorizer.ColorBreakpoint" href="#geoengine.colorizer.ColorBreakpoint">ColorBreakpoint</a>], over_color: Rgba, under_color: Rgba)</span>
</code></dt>
<dd>
<div class="desc"><p>A linear gradient colorizer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class LinearGradientColorizer(Colorizer):
    &#39;&#39;&#39;A linear gradient colorizer.&#39;&#39;&#39;
    breakpoints: List[ColorBreakpoint]
    over_color: Rgba
    under_color: Rgba

    @staticmethod
    def from_response_linear(response: geoengine_openapi_client.LinearGradient) -&gt; LinearGradientColorizer:
        &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;
        breakpoints = [ColorBreakpoint.from_response(breakpoint) for breakpoint in response.breakpoints]
        return LinearGradientColorizer(
            no_data_color=response.no_data_color,
            breakpoints=breakpoints,
            over_color=response.over_color,
            under_color=response.under_color,
        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
        &#34;&#34;&#34;Return the colorizer as a dictionary.&#34;&#34;&#34;
        return geoengine_openapi_client.Colorizer(geoengine_openapi_client.LinearGradient(
            type=&#39;linearGradient&#39;,
            breakpoints=[breakpoint.to_api_dict() for breakpoint in self.breakpoints],
            no_data_color=self.no_data_color,
            over_color=self.over_color,
            under_color=self.under_color
        ))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.colorizer.Colorizer" href="#geoengine.colorizer.Colorizer">Colorizer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.colorizer.LinearGradientColorizer.breakpoints"><code class="name">var <span class="ident">breakpoints</span> : List[<a title="geoengine.colorizer.ColorBreakpoint" href="#geoengine.colorizer.ColorBreakpoint">ColorBreakpoint</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.colorizer.LinearGradientColorizer.over_color"><code class="name">var <span class="ident">over_color</span> : Tuple[int, int, int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.colorizer.LinearGradientColorizer.under_color"><code class="name">var <span class="ident">under_color</span> : Tuple[int, int, int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.colorizer.LinearGradientColorizer.from_response_linear"><code class="name flex">
<span>def <span class="ident">from_response_linear</span></span>(<span>response: geoengine_openapi_client.LinearGradient) ‑> <a title="geoengine.colorizer.LinearGradientColorizer" href="#geoengine.colorizer.LinearGradientColorizer">LinearGradientColorizer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a colorizer from a response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_linear(response: geoengine_openapi_client.LinearGradient) -&gt; LinearGradientColorizer:
    &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;
    breakpoints = [ColorBreakpoint.from_response(breakpoint) for breakpoint in response.breakpoints]
    return LinearGradientColorizer(
        no_data_color=response.no_data_color,
        breakpoints=breakpoints,
        over_color=response.over_color,
        under_color=response.under_color,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.colorizer.LinearGradientColorizer.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ‑> geoengine_openapi_client.models.colorizer.Colorizer</span>
</code></dt>
<dd>
<div class="desc"><p>Return the colorizer as a dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
    &#34;&#34;&#34;Return the colorizer as a dictionary.&#34;&#34;&#34;
    return geoengine_openapi_client.Colorizer(geoengine_openapi_client.LinearGradient(
        type=&#39;linearGradient&#39;,
        breakpoints=[breakpoint.to_api_dict() for breakpoint in self.breakpoints],
        no_data_color=self.no_data_color,
        over_color=self.over_color,
        under_color=self.under_color
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.colorizer.Colorizer" href="#geoengine.colorizer.Colorizer">Colorizer</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.colorizer.Colorizer.from_response" href="#geoengine.colorizer.Colorizer.from_response">from_response</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.linear_with_mpl_cmap" href="#geoengine.colorizer.Colorizer.linear_with_mpl_cmap">linear_with_mpl_cmap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.logarithmic_with_mpl_cmap" href="#geoengine.colorizer.Colorizer.logarithmic_with_mpl_cmap">logarithmic_with_mpl_cmap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.palette" href="#geoengine.colorizer.Colorizer.palette">palette</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.palette_with_colormap" href="#geoengine.colorizer.Colorizer.palette_with_colormap">palette_with_colormap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.to_json" href="#geoengine.colorizer.Colorizer.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.colorizer.LogarithmicGradientColorizer"><code class="flex name class">
<span>class <span class="ident">LogarithmicGradientColorizer</span></span>
<span>(</span><span>no_data_color: Rgba, breakpoints: List[<a title="geoengine.colorizer.ColorBreakpoint" href="#geoengine.colorizer.ColorBreakpoint">ColorBreakpoint</a>], over_color: Rgba, under_color: Rgba)</span>
</code></dt>
<dd>
<div class="desc"><p>A logarithmic gradient colorizer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class LogarithmicGradientColorizer(Colorizer):
    &#39;&#39;&#39;A logarithmic gradient colorizer.&#39;&#39;&#39;
    breakpoints: List[ColorBreakpoint]
    over_color: Rgba
    under_color: Rgba

    @staticmethod
    def from_response_logarithmic(
            response: geoengine_openapi_client.LogarithmicGradient) -&gt; LogarithmicGradientColorizer:
        &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;
        breakpoints = [ColorBreakpoint.from_response(breakpoint) for breakpoint in response.breakpoints]
        return LogarithmicGradientColorizer(
            breakpoints=breakpoints,
            no_data_color=response.no_data_color,
            over_color=response.over_color,
            under_color=response.under_color,
        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
        &#34;&#34;&#34;Return the colorizer as a dictionary.&#34;&#34;&#34;
        return geoengine_openapi_client.Colorizer(geoengine_openapi_client.LogarithmicGradient(
            type=&#39;logarithmicGradient&#39;,
            breakpoints=[breakpoint.to_api_dict() for breakpoint in self.breakpoints],
            no_data_color=self.no_data_color,
            over_color=self.over_color,
            under_color=self.under_color,
        ))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.colorizer.Colorizer" href="#geoengine.colorizer.Colorizer">Colorizer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.colorizer.LogarithmicGradientColorizer.breakpoints"><code class="name">var <span class="ident">breakpoints</span> : List[<a title="geoengine.colorizer.ColorBreakpoint" href="#geoengine.colorizer.ColorBreakpoint">ColorBreakpoint</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.colorizer.LogarithmicGradientColorizer.over_color"><code class="name">var <span class="ident">over_color</span> : Tuple[int, int, int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.colorizer.LogarithmicGradientColorizer.under_color"><code class="name">var <span class="ident">under_color</span> : Tuple[int, int, int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.colorizer.LogarithmicGradientColorizer.from_response_logarithmic"><code class="name flex">
<span>def <span class="ident">from_response_logarithmic</span></span>(<span>response: geoengine_openapi_client.LogarithmicGradient) ‑> <a title="geoengine.colorizer.LogarithmicGradientColorizer" href="#geoengine.colorizer.LogarithmicGradientColorizer">LogarithmicGradientColorizer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a colorizer from a response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_logarithmic(
        response: geoengine_openapi_client.LogarithmicGradient) -&gt; LogarithmicGradientColorizer:
    &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;
    breakpoints = [ColorBreakpoint.from_response(breakpoint) for breakpoint in response.breakpoints]
    return LogarithmicGradientColorizer(
        breakpoints=breakpoints,
        no_data_color=response.no_data_color,
        over_color=response.over_color,
        under_color=response.under_color,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.colorizer.LogarithmicGradientColorizer.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ‑> geoengine_openapi_client.models.colorizer.Colorizer</span>
</code></dt>
<dd>
<div class="desc"><p>Return the colorizer as a dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
    &#34;&#34;&#34;Return the colorizer as a dictionary.&#34;&#34;&#34;
    return geoengine_openapi_client.Colorizer(geoengine_openapi_client.LogarithmicGradient(
        type=&#39;logarithmicGradient&#39;,
        breakpoints=[breakpoint.to_api_dict() for breakpoint in self.breakpoints],
        no_data_color=self.no_data_color,
        over_color=self.over_color,
        under_color=self.under_color,
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.colorizer.Colorizer" href="#geoengine.colorizer.Colorizer">Colorizer</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.colorizer.Colorizer.from_response" href="#geoengine.colorizer.Colorizer.from_response">from_response</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.linear_with_mpl_cmap" href="#geoengine.colorizer.Colorizer.linear_with_mpl_cmap">linear_with_mpl_cmap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.logarithmic_with_mpl_cmap" href="#geoengine.colorizer.Colorizer.logarithmic_with_mpl_cmap">logarithmic_with_mpl_cmap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.palette" href="#geoengine.colorizer.Colorizer.palette">palette</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.palette_with_colormap" href="#geoengine.colorizer.Colorizer.palette_with_colormap">palette_with_colormap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.to_json" href="#geoengine.colorizer.Colorizer.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.colorizer.PaletteColorizer"><code class="flex name class">
<span>class <span class="ident">PaletteColorizer</span></span>
<span>(</span><span>no_data_color: Rgba, colors: Dict[float, Rgba], default_color: Rgba)</span>
</code></dt>
<dd>
<div class="desc"><p>A palette colorizer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclass
class PaletteColorizer(Colorizer):
    &#39;&#39;&#39;A palette colorizer.&#39;&#39;&#39;
    colors: Dict[float, Rgba]
    default_color: Rgba

    @staticmethod
    def from_response_palette(response: geoengine_openapi_client.PaletteColorizer) -&gt; PaletteColorizer:
        &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;

        return PaletteColorizer(
            colors={float(k): v for k, v in response.colors.items()},
            no_data_color=response.no_data_color,
            default_color=response.default_color,
        )

    def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
        &#34;&#34;&#34;Return the colorizer as a dictionary.&#34;&#34;&#34;
        return geoengine_openapi_client.Colorizer(geoengine_openapi_client.PaletteColorizer(
            type=&#39;palette&#39;,
            colors=self.colors,
            default_color=self.default_color,
            no_data_color=self.no_data_color,
        ))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.colorizer.Colorizer" href="#geoengine.colorizer.Colorizer">Colorizer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.colorizer.PaletteColorizer.colors"><code class="name">var <span class="ident">colors</span> : Dict[float, Tuple[int, int, int, int]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="geoengine.colorizer.PaletteColorizer.default_color"><code class="name">var <span class="ident">default_color</span> : Tuple[int, int, int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.colorizer.PaletteColorizer.from_response_palette"><code class="name flex">
<span>def <span class="ident">from_response_palette</span></span>(<span>response: geoengine_openapi_client.PaletteColorizer) ‑> <a title="geoengine.colorizer.PaletteColorizer" href="#geoengine.colorizer.PaletteColorizer">PaletteColorizer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a colorizer from a response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_palette(response: geoengine_openapi_client.PaletteColorizer) -&gt; PaletteColorizer:
    &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;

    return PaletteColorizer(
        colors={float(k): v for k, v in response.colors.items()},
        no_data_color=response.no_data_color,
        default_color=response.default_color,
    )</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.colorizer.PaletteColorizer.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ‑> geoengine_openapi_client.models.colorizer.Colorizer</span>
</code></dt>
<dd>
<div class="desc"><p>Return the colorizer as a dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
    &#34;&#34;&#34;Return the colorizer as a dictionary.&#34;&#34;&#34;
    return geoengine_openapi_client.Colorizer(geoengine_openapi_client.PaletteColorizer(
        type=&#39;palette&#39;,
        colors=self.colors,
        default_color=self.default_color,
        no_data_color=self.no_data_color,
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.colorizer.Colorizer" href="#geoengine.colorizer.Colorizer">Colorizer</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.colorizer.Colorizer.from_response" href="#geoengine.colorizer.Colorizer.from_response">from_response</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.linear_with_mpl_cmap" href="#geoengine.colorizer.Colorizer.linear_with_mpl_cmap">linear_with_mpl_cmap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.logarithmic_with_mpl_cmap" href="#geoengine.colorizer.Colorizer.logarithmic_with_mpl_cmap">logarithmic_with_mpl_cmap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.palette" href="#geoengine.colorizer.Colorizer.palette">palette</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.palette_with_colormap" href="#geoengine.colorizer.Colorizer.palette_with_colormap">palette_with_colormap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.to_json" href="#geoengine.colorizer.Colorizer.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="geoengine.colorizer.RgbaColorizer"><code class="flex name class">
<span>class <span class="ident">RgbaColorizer</span></span>
<span>(</span><span>no_data_color: Rgba = (0, 0, 0, 0))</span>
</code></dt>
<dd>
<div class="desc"><p>A Rgba colorizer.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RgbaColorizer(Colorizer):
    &#39;&#39;&#39;A Rgba colorizer.&#39;&#39;&#39;

    def __init__(self, no_data_color: Rgba = (0, 0, 0, 0)):
        super().__init__(no_data_color)

    @staticmethod
    def from_response_rgba(_response: geoengine_openapi_client.RgbaColorizer) -&gt; RgbaColorizer:
        &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;

        return RgbaColorizer()

    def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
        &#34;&#34;&#34;Return the colorizer as a dictionary.&#34;&#34;&#34;
        return geoengine_openapi_client.Colorizer(geoengine_openapi_client.RgbaColorizer(
            type=&#39;rgba&#39;,
        ))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="geoengine.colorizer.Colorizer" href="#geoengine.colorizer.Colorizer">Colorizer</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="geoengine.colorizer.RgbaColorizer.no_data_color"><code class="name">var <span class="ident">no_data_color</span> : Tuple[int, int, int, int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="geoengine.colorizer.RgbaColorizer.from_response_rgba"><code class="name flex">
<span>def <span class="ident">from_response_rgba</span></span>(<span>_response: geoengine_openapi_client.RgbaColorizer) ‑> <a title="geoengine.colorizer.RgbaColorizer" href="#geoengine.colorizer.RgbaColorizer">RgbaColorizer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a colorizer from a response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_response_rgba(_response: geoengine_openapi_client.RgbaColorizer) -&gt; RgbaColorizer:
    &#34;&#34;&#34;Create a colorizer from a response.&#34;&#34;&#34;

    return RgbaColorizer()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="geoengine.colorizer.RgbaColorizer.to_api_dict"><code class="name flex">
<span>def <span class="ident">to_api_dict</span></span>(<span>self) ‑> geoengine_openapi_client.models.colorizer.Colorizer</span>
</code></dt>
<dd>
<div class="desc"><p>Return the colorizer as a dictionary.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_api_dict(self) -&gt; geoengine_openapi_client.Colorizer:
    &#34;&#34;&#34;Return the colorizer as a dictionary.&#34;&#34;&#34;
    return geoengine_openapi_client.Colorizer(geoengine_openapi_client.RgbaColorizer(
        type=&#39;rgba&#39;,
    ))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="geoengine.colorizer.Colorizer" href="#geoengine.colorizer.Colorizer">Colorizer</a></b></code>:
<ul class="hlist">
<li><code><a title="geoengine.colorizer.Colorizer.from_response" href="#geoengine.colorizer.Colorizer.from_response">from_response</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.linear_with_mpl_cmap" href="#geoengine.colorizer.Colorizer.linear_with_mpl_cmap">linear_with_mpl_cmap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.logarithmic_with_mpl_cmap" href="#geoengine.colorizer.Colorizer.logarithmic_with_mpl_cmap">logarithmic_with_mpl_cmap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.palette" href="#geoengine.colorizer.Colorizer.palette">palette</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.palette_with_colormap" href="#geoengine.colorizer.Colorizer.palette_with_colormap">palette_with_colormap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.to_json" href="#geoengine.colorizer.Colorizer.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="geoengine" href="index.html">geoengine</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="geoengine.colorizer.ColorBreakpoint" href="#geoengine.colorizer.ColorBreakpoint">ColorBreakpoint</a></code></h4>
<ul class="">
<li><code><a title="geoengine.colorizer.ColorBreakpoint.color" href="#geoengine.colorizer.ColorBreakpoint.color">color</a></code></li>
<li><code><a title="geoengine.colorizer.ColorBreakpoint.from_response" href="#geoengine.colorizer.ColorBreakpoint.from_response">from_response</a></code></li>
<li><code><a title="geoengine.colorizer.ColorBreakpoint.to_api_dict" href="#geoengine.colorizer.ColorBreakpoint.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.colorizer.ColorBreakpoint.value" href="#geoengine.colorizer.ColorBreakpoint.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.colorizer.Colorizer" href="#geoengine.colorizer.Colorizer">Colorizer</a></code></h4>
<ul class="">
<li><code><a title="geoengine.colorizer.Colorizer.from_response" href="#geoengine.colorizer.Colorizer.from_response">from_response</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.linear_with_mpl_cmap" href="#geoengine.colorizer.Colorizer.linear_with_mpl_cmap">linear_with_mpl_cmap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.logarithmic_with_mpl_cmap" href="#geoengine.colorizer.Colorizer.logarithmic_with_mpl_cmap">logarithmic_with_mpl_cmap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.no_data_color" href="#geoengine.colorizer.Colorizer.no_data_color">no_data_color</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.palette" href="#geoengine.colorizer.Colorizer.palette">palette</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.palette_with_colormap" href="#geoengine.colorizer.Colorizer.palette_with_colormap">palette_with_colormap</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.rgba" href="#geoengine.colorizer.Colorizer.rgba">rgba</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.to_api_dict" href="#geoengine.colorizer.Colorizer.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.colorizer.Colorizer.to_json" href="#geoengine.colorizer.Colorizer.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.colorizer.LinearGradientColorizer" href="#geoengine.colorizer.LinearGradientColorizer">LinearGradientColorizer</a></code></h4>
<ul class="">
<li><code><a title="geoengine.colorizer.LinearGradientColorizer.breakpoints" href="#geoengine.colorizer.LinearGradientColorizer.breakpoints">breakpoints</a></code></li>
<li><code><a title="geoengine.colorizer.LinearGradientColorizer.from_response_linear" href="#geoengine.colorizer.LinearGradientColorizer.from_response_linear">from_response_linear</a></code></li>
<li><code><a title="geoengine.colorizer.LinearGradientColorizer.over_color" href="#geoengine.colorizer.LinearGradientColorizer.over_color">over_color</a></code></li>
<li><code><a title="geoengine.colorizer.LinearGradientColorizer.to_api_dict" href="#geoengine.colorizer.LinearGradientColorizer.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.colorizer.LinearGradientColorizer.under_color" href="#geoengine.colorizer.LinearGradientColorizer.under_color">under_color</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.colorizer.LogarithmicGradientColorizer" href="#geoengine.colorizer.LogarithmicGradientColorizer">LogarithmicGradientColorizer</a></code></h4>
<ul class="">
<li><code><a title="geoengine.colorizer.LogarithmicGradientColorizer.breakpoints" href="#geoengine.colorizer.LogarithmicGradientColorizer.breakpoints">breakpoints</a></code></li>
<li><code><a title="geoengine.colorizer.LogarithmicGradientColorizer.from_response_logarithmic" href="#geoengine.colorizer.LogarithmicGradientColorizer.from_response_logarithmic">from_response_logarithmic</a></code></li>
<li><code><a title="geoengine.colorizer.LogarithmicGradientColorizer.over_color" href="#geoengine.colorizer.LogarithmicGradientColorizer.over_color">over_color</a></code></li>
<li><code><a title="geoengine.colorizer.LogarithmicGradientColorizer.to_api_dict" href="#geoengine.colorizer.LogarithmicGradientColorizer.to_api_dict">to_api_dict</a></code></li>
<li><code><a title="geoengine.colorizer.LogarithmicGradientColorizer.under_color" href="#geoengine.colorizer.LogarithmicGradientColorizer.under_color">under_color</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.colorizer.PaletteColorizer" href="#geoengine.colorizer.PaletteColorizer">PaletteColorizer</a></code></h4>
<ul class="">
<li><code><a title="geoengine.colorizer.PaletteColorizer.colors" href="#geoengine.colorizer.PaletteColorizer.colors">colors</a></code></li>
<li><code><a title="geoengine.colorizer.PaletteColorizer.default_color" href="#geoengine.colorizer.PaletteColorizer.default_color">default_color</a></code></li>
<li><code><a title="geoengine.colorizer.PaletteColorizer.from_response_palette" href="#geoengine.colorizer.PaletteColorizer.from_response_palette">from_response_palette</a></code></li>
<li><code><a title="geoengine.colorizer.PaletteColorizer.to_api_dict" href="#geoengine.colorizer.PaletteColorizer.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="geoengine.colorizer.RgbaColorizer" href="#geoengine.colorizer.RgbaColorizer">RgbaColorizer</a></code></h4>
<ul class="">
<li><code><a title="geoengine.colorizer.RgbaColorizer.from_response_rgba" href="#geoengine.colorizer.RgbaColorizer.from_response_rgba">from_response_rgba</a></code></li>
<li><code><a title="geoengine.colorizer.RgbaColorizer.no_data_color" href="#geoengine.colorizer.RgbaColorizer.no_data_color">no_data_color</a></code></li>
<li><code><a title="geoengine.colorizer.RgbaColorizer.to_api_dict" href="#geoengine.colorizer.RgbaColorizer.to_api_dict">to_api_dict</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>